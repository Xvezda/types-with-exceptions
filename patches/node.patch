diff -ruN .cache/node/fs.d.ts types/node/fs.d.ts
--- .cache/node/fs.d.ts	2025-06-26 21:45:46.982210630 +0000
+++ types/node/fs.d.ts	2025-06-26 21:45:45.734225835 +0000
@@ -552,6 +552,7 @@
      *
      * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., source not found, permission denied, cross-device link)
      */
     export function renameSync(oldPath: PathLike, newPath: PathLike): void;
     /**
@@ -597,6 +598,7 @@
      * in the future.
      * @since v0.8.6
      * @param [len=0]
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function truncateSync(path: PathLike, len?: number): void;
     /**
@@ -663,6 +665,7 @@
      * this API: {@link ftruncate}.
      * @since v0.8.6
      * @param [len=0]
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function ftruncateSync(fd: number, len?: number): void;
     /**
@@ -686,6 +689,7 @@
      *
      * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
      * @since v0.1.97
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid user/group)
      */
     export function chownSync(path: PathLike, uid: number, gid: number): void;
     /**
@@ -710,6 +714,7 @@
      * @since v0.4.7
      * @param uid The file's new owner's user id.
      * @param gid The file's new group's group id.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, permission denied, invalid user/group)
      */
     export function fchownSync(fd: number, uid: number, gid: number): void;
     /**
@@ -732,6 +737,7 @@
      * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
      * @param uid The file's new owner's user id.
      * @param gid The file's new group's group id.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid user/group)
      */
     export function lchownSync(path: PathLike, uid: number, gid: number): void;
     /**
@@ -760,6 +766,7 @@
      * Returns `undefined`, or throws an exception when parameters are incorrect or
      * the operation fails. This is the synchronous version of {@link lutimes}.
      * @since v14.5.0, v12.19.0
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid timestamps)
      */
     export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -793,6 +800,7 @@
      *
      * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
      * @since v0.6.7
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid mode)
      */
     export function chmodSync(path: PathLike, mode: Mode): void;
     /**
@@ -816,6 +824,7 @@
      *
      * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
      * @since v0.4.7
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, permission denied, invalid mode)
      */
     export function fchmodSync(fd: number, mode: Mode): void;
     /**
@@ -844,6 +853,7 @@
      *
      * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
      * @deprecated Since v0.4.7
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid mode)
      */
     export function lchmodSync(path: PathLike, mode: Mode): void;
     /**
@@ -1012,6 +1022,7 @@
     /**
      * Synchronous stat(2) - Get file status.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export const statSync: StatSyncFn;
     /**
@@ -1066,6 +1077,7 @@
      *
      * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
      * @since v0.1.95
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fstatSync(
         fd: number,
@@ -1185,6 +1197,7 @@
      * In case of an error, the `err.code` will be one of `Common System Errors`.
      * @since v19.6.0, v18.15.0
      * @param path A path to an existing file or directory on the file system to be queried.
+     * @throws {NodeJS.ErrnoException} When file system operations fail (e.g., path not found, permission denied, invalid file system)
      */
     export function statfsSync(
         path: PathLike,
@@ -1202,6 +1215,7 @@
     /**
      * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export const lstatSync: StatSyncFn;
     /**
@@ -1222,6 +1236,7 @@
     /**
      * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When link operations fail (e.g., source not found, permission denied, cross-device link)
      */
     export function linkSync(existingPath: PathLike, newPath: PathLike): void;
     /**
@@ -1287,6 +1302,7 @@
      * this API: {@link symlink}.
      * @since v0.1.31
      * @param [type='null']
+     * @throws {NodeJS.ErrnoException} When symlink operations fail (e.g., permission denied, target not found, path already exists)
      */
     export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
     /**
@@ -1364,18 +1380,21 @@
      * the link path returned. If the `encoding` is set to `'buffer'`,
      * the link path returned will be passed as a `Buffer` object.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options?: EncodingOption): string;
     /**
      * Synchronous readlink(2) - read value of a symbolic link.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
     /**
      * Synchronous readlink(2) - read value of a symbolic link.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
     /**
@@ -1499,18 +1518,21 @@
      * For detailed information, see the documentation of the asynchronous version of
      * this API: {@link realpath}.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options?: EncodingOption): string;
     /**
      * Synchronous realpath(3) - return the canonicalized absolute pathname.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
     /**
      * Synchronous realpath(3) - return the canonicalized absolute pathname.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
     export namespace realpathSync {
@@ -1548,6 +1570,7 @@
     /**
      * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, file in use)
      */
     export function unlinkSync(path: PathLike): void;
     export interface RmDirOptions {
@@ -1604,6 +1627,7 @@
      *
      * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, directory not empty)
      */
     export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
     export interface RmOptions {
@@ -1650,6 +1674,7 @@
     /**
      * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
      * @since v14.14.0
+     * @throws {NodeJS.ErrnoException} When file/directory operations fail (e.g., path not found, permission denied, path in use)
      */
     export function rmSync(path: PathLike, options?: RmOptions): void;
     export interface MakeDirectoryOptions {
@@ -1786,6 +1811,7 @@
      *
      * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(
         path: PathLike,
@@ -1798,6 +1824,7 @@
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(
         path: PathLike,
@@ -1813,6 +1840,7 @@
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
     /**
@@ -1940,18 +1968,21 @@
      * The optional `options` argument can be a string specifying an encoding, or an
      * object with an `encoding` property specifying the character encoding to use.
      * @since v5.10.0
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options?: EncodingOption): string;
     /**
      * Synchronously creates a unique temporary directory.
      * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
     /**
      * Synchronously creates a unique temporary directory.
      * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
     /**
@@ -2133,6 +2164,7 @@
      *
      * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, not a directory)
      */
     export function readdirSync(
         path: PathLike,
@@ -2226,6 +2258,7 @@
      *
      * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function closeSync(fd: number): void;
     /**
@@ -2282,6 +2315,7 @@
      * @since v0.1.21
      * @param [flags='r']
      * @param [mode=0o666]
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid flags)
      */
     export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
     /**
@@ -2309,6 +2343,7 @@
      * For detailed information, see the documentation of the asynchronous version of
      * this API: {@link utimes}.
      * @since v0.4.2
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid timestamps)
      */
     export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -2329,6 +2364,7 @@
     /**
      * Synchronous version of {@link futimes}. Returns `undefined`.
      * @since v0.4.2
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, invalid timestamps)
      */
     export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -2351,6 +2387,7 @@
      * device. The specific implementation is operating system and device specific.
      * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
      * @since v0.1.96
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fsyncSync(fd: number): void;
     export interface WriteOptions {
@@ -2544,6 +2581,7 @@
      * @param [length=buffer.byteLength - offset]
      * @param [position='null']
      * @return The number of bytes written.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writeSync(
         fd: number,
@@ -2558,6 +2596,7 @@
      * @param string A string to write.
      * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
      * @param encoding The expected string encoding.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writeSync(
         fd: number,
@@ -2674,6 +2713,7 @@
      * this API: {@link read}.
      * @since v0.1.21
      * @param [position='null']
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readSync(
         fd: number,
@@ -2685,6 +2725,7 @@
     /**
      * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
      * If no `options` object is specified, it will default with the above values.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
     /**
@@ -2881,6 +2922,7 @@
      * ```
      * @since v0.1.8
      * @param path filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -2895,6 +2937,7 @@
      * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      * If a flag is not provided, it defaults to `'r'`.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -2911,6 +2954,7 @@
      * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      * If a flag is not provided, it defaults to `'r'`.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -3039,6 +3083,7 @@
      * this API: {@link writeFile}.
      * @since v0.1.29
      * @param file filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., permission denied, disk full, invalid path)
      */
     export function writeFileSync(
         file: PathOrFileDescriptor,
@@ -3176,6 +3221,7 @@
      * ```
      * @since v0.6.7
      * @param path filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., permission denied, disk full, invalid path)
      */
     export function appendFileSync(
         path: PathOrFileDescriptor,
@@ -3851,6 +3897,7 @@
      * ```
      * @since v0.11.15
      * @param [mode=fs.constants.F_OK]
+     * @throws {NodeJS.ErrnoException} When access checks fail (e.g., file not found, permission denied)
      */
     export function accessSync(path: PathLike, mode?: number): void;
     interface StreamOptions {
@@ -3992,6 +4039,7 @@
      * Forces all currently queued I/O operations associated with the file to the
      * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
      * @since v0.1.96
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fdatasyncSync(fd: number): void;
     /**
@@ -4071,6 +4119,7 @@
      * @param src source filename to copy
      * @param dest destination filename of the copy operation
      * @param [mode=0] modifiers for copy operation.
+     * @throws {NodeJS.ErrnoException} When copy operations fail (e.g., source not found, permission denied, disk full)
      */
     export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
     /**
@@ -4121,6 +4170,7 @@
      * @since v12.9.0
      * @param [position='null']
      * @return The number of bytes written.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
     /**
@@ -4166,6 +4216,7 @@
      * @since v13.13.0, v12.17.0
      * @param [position='null']
      * @return The number of bytes read.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
 
@@ -4223,6 +4274,7 @@
      * The `encoding` option sets the encoding for the `path` while opening the
      * directory and subsequent read operations.
      * @since v12.12.0
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, not a directory)
      */
     export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
     /**
@@ -4346,6 +4398,7 @@
      * @experimental
      * @param src source path to copy.
      * @param dest destination path to copy to.
+     * @throws {NodeJS.ErrnoException} When copy operations fail (e.g., source not found, permission denied, disk full)
      */
     export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;
 
@@ -4424,6 +4477,7 @@
      *
      * console.log(globSync('*.js'));
      * ```
+     * @throws {NodeJS.ErrnoException} When file system operations fail (e.g., permission denied, invalid pattern, path not found)
      * @since v22.0.0
      * @returns paths of files that match the pattern.
      */
diff -ruN .cache/node/fs.d.ts.orig types/node/fs.d.ts.orig
--- .cache/node/fs.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/fs.d.ts.orig	2025-06-26 21:45:45.736225811 +0000
@@ -0,0 +1,4446 @@
+/**
+ * The `node:fs` module enables interacting with the file system in a
+ * way modeled on standard POSIX functions.
+ *
+ * To use the promise-based APIs:
+ *
+ * ```js
+ * import * as fs from 'node:fs/promises';
+ * ```
+ *
+ * To use the callback and sync APIs:
+ *
+ * ```js
+ * import * as fs from 'node:fs';
+ * ```
+ *
+ * All file system operations have synchronous, callback, and promise-based
+ * forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).
+ * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/fs.js)
+ */
+declare module "fs" {
+    import * as stream from "node:stream";
+    import { Abortable, EventEmitter } from "node:events";
+    import { URL } from "node:url";
+    import * as promises from "node:fs/promises";
+    export { promises };
+    /**
+     * Valid types for path values in "fs".
+     */
+    export type PathLike = string | Buffer | URL;
+    export type PathOrFileDescriptor = PathLike | number;
+    export type TimeLike = string | number | Date;
+    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;
+    export type BufferEncodingOption =
+        | "buffer"
+        | {
+            encoding: "buffer";
+        };
+    export interface ObjectEncodingOptions {
+        encoding?: BufferEncoding | null | undefined;
+    }
+    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;
+    export type OpenMode = number | string;
+    export type Mode = number | string;
+    export interface StatsBase<T> {
+        isFile(): boolean;
+        isDirectory(): boolean;
+        isBlockDevice(): boolean;
+        isCharacterDevice(): boolean;
+        isSymbolicLink(): boolean;
+        isFIFO(): boolean;
+        isSocket(): boolean;
+        dev: T;
+        ino: T;
+        mode: T;
+        nlink: T;
+        uid: T;
+        gid: T;
+        rdev: T;
+        size: T;
+        blksize: T;
+        blocks: T;
+        atimeMs: T;
+        mtimeMs: T;
+        ctimeMs: T;
+        birthtimeMs: T;
+        atime: Date;
+        mtime: Date;
+        ctime: Date;
+        birthtime: Date;
+    }
+    export interface Stats extends StatsBase<number> {}
+    /**
+     * A `fs.Stats` object provides information about a file.
+     *
+     * Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and
+     * their synchronous counterparts are of this type.
+     * If `bigint` in the `options` passed to those methods is true, the numeric values
+     * will be `bigint` instead of `number`, and the object will contain additional
+     * nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.
+     *
+     * ```console
+     * Stats {
+     *   dev: 2114,
+     *   ino: 48064969,
+     *   mode: 33188,
+     *   nlink: 1,
+     *   uid: 85,
+     *   gid: 100,
+     *   rdev: 0,
+     *   size: 527,
+     *   blksize: 4096,
+     *   blocks: 8,
+     *   atimeMs: 1318289051000.1,
+     *   mtimeMs: 1318289051000.1,
+     *   ctimeMs: 1318289051000.1,
+     *   birthtimeMs: 1318289051000.1,
+     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
+     * ```
+     *
+     * `bigint` version:
+     *
+     * ```console
+     * BigIntStats {
+     *   dev: 2114n,
+     *   ino: 48064969n,
+     *   mode: 33188n,
+     *   nlink: 1n,
+     *   uid: 85n,
+     *   gid: 100n,
+     *   rdev: 0n,
+     *   size: 527n,
+     *   blksize: 4096n,
+     *   blocks: 8n,
+     *   atimeMs: 1318289051000n,
+     *   mtimeMs: 1318289051000n,
+     *   ctimeMs: 1318289051000n,
+     *   birthtimeMs: 1318289051000n,
+     *   atimeNs: 1318289051000000000n,
+     *   mtimeNs: 1318289051000000000n,
+     *   ctimeNs: 1318289051000000000n,
+     *   birthtimeNs: 1318289051000000000n,
+     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
+     * ```
+     * @since v0.1.21
+     */
+    export class Stats {
+        private constructor();
+    }
+    export interface StatsFsBase<T> {
+        /** Type of file system. */
+        type: T;
+        /**  Optimal transfer block size. */
+        bsize: T;
+        /**  Total data blocks in file system. */
+        blocks: T;
+        /** Free blocks in file system. */
+        bfree: T;
+        /** Available blocks for unprivileged users */
+        bavail: T;
+        /** Total file nodes in file system. */
+        files: T;
+        /** Free file nodes in file system. */
+        ffree: T;
+    }
+    export interface StatsFs extends StatsFsBase<number> {}
+    /**
+     * Provides information about a mounted file system.
+     *
+     * Objects returned from {@link statfs} and its synchronous counterpart are of
+     * this type. If `bigint` in the `options` passed to those methods is `true`, the
+     * numeric values will be `bigint` instead of `number`.
+     *
+     * ```console
+     * StatFs {
+     *   type: 1397114950,
+     *   bsize: 4096,
+     *   blocks: 121938943,
+     *   bfree: 61058895,
+     *   bavail: 61058895,
+     *   files: 999,
+     *   ffree: 1000000
+     * }
+     * ```
+     *
+     * `bigint` version:
+     *
+     * ```console
+     * StatFs {
+     *   type: 1397114950n,
+     *   bsize: 4096n,
+     *   blocks: 121938943n,
+     *   bfree: 61058895n,
+     *   bavail: 61058895n,
+     *   files: 999n,
+     *   ffree: 1000000n
+     * }
+     * ```
+     * @since v19.6.0, v18.15.0
+     */
+    export class StatsFs {}
+    export interface BigIntStatsFs extends StatsFsBase<bigint> {}
+    export interface StatFsOptions {
+        bigint?: boolean | undefined;
+    }
+    /**
+     * A representation of a directory entry, which can be a file or a subdirectory
+     * within the directory, as returned by reading from an `fs.Dir`. The
+     * directory entry is a combination of the file name and file type pairs.
+     *
+     * Additionally, when {@link readdir} or {@link readdirSync} is called with
+     * the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.
+     * @since v10.10.0
+     */
+    export class Dirent<Name extends string | Buffer = string> {
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a regular file.
+         * @since v10.10.0
+         */
+        isFile(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a file system
+         * directory.
+         * @since v10.10.0
+         */
+        isDirectory(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a block device.
+         * @since v10.10.0
+         */
+        isBlockDevice(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a character device.
+         * @since v10.10.0
+         */
+        isCharacterDevice(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a symbolic link.
+         * @since v10.10.0
+         */
+        isSymbolicLink(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a first-in-first-out
+         * (FIFO) pipe.
+         * @since v10.10.0
+         */
+        isFIFO(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a socket.
+         * @since v10.10.0
+         */
+        isSocket(): boolean;
+        /**
+         * The file name that this `fs.Dirent` object refers to. The type of this
+         * value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.
+         * @since v10.10.0
+         */
+        name: Name;
+        /**
+         * The path to the parent directory of the file this `fs.Dirent` object refers to.
+         * @since v20.12.0, v18.20.0
+         */
+        parentPath: string;
+    }
+    /**
+     * A class representing a directory stream.
+     *
+     * Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.
+     *
+     * ```js
+     * import { opendir } from 'node:fs/promises';
+     *
+     * try {
+     *   const dir = await opendir('./');
+     *   for await (const dirent of dir)
+     *     console.log(dirent.name);
+     * } catch (err) {
+     *   console.error(err);
+     * }
+     * ```
+     *
+     * When using the async iterator, the `fs.Dir` object will be automatically
+     * closed after the iterator exits.
+     * @since v12.12.0
+     */
+    export class Dir implements AsyncIterable<Dirent> {
+        /**
+         * The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.
+         * @since v12.12.0
+         */
+        readonly path: string;
+        /**
+         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
+         */
+        [Symbol.asyncIterator](): NodeJS.AsyncIterator<Dirent>;
+        /**
+         * Asynchronously close the directory's underlying resource handle.
+         * Subsequent reads will result in errors.
+         *
+         * A promise is returned that will be fulfilled after the resource has been
+         * closed.
+         * @since v12.12.0
+         */
+        close(): Promise<void>;
+        close(cb: NoParamCallback): void;
+        /**
+         * Synchronously close the directory's underlying resource handle.
+         * Subsequent reads will result in errors.
+         * @since v12.12.0
+         */
+        closeSync(): void;
+        /**
+         * Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.
+         *
+         * A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.
+         *
+         * Directory entries returned by this function are in no particular order as
+         * provided by the operating system's underlying directory mechanisms.
+         * Entries added or removed while iterating over the directory might not be
+         * included in the iteration results.
+         * @since v12.12.0
+         * @return containing {fs.Dirent|null}
+         */
+        read(): Promise<Dirent | null>;
+        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;
+        /**
+         * Synchronously read the next directory entry as an `fs.Dirent`. See the
+         * POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.
+         *
+         * If there are no more directory entries to read, `null` will be returned.
+         *
+         * Directory entries returned by this function are in no particular order as
+         * provided by the operating system's underlying directory mechanisms.
+         * Entries added or removed while iterating over the directory might not be
+         * included in the iteration results.
+         * @since v12.12.0
+         */
+        readSync(): Dirent | null;
+    }
+    /**
+     * Class: fs.StatWatcher
+     * @since v14.3.0, v12.20.0
+     * Extends `EventEmitter`
+     * A successful call to {@link watchFile} method will return a new fs.StatWatcher object.
+     */
+    export interface StatWatcher extends EventEmitter {
+        /**
+         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have
+         * no effect.
+         *
+         * By default, all `fs.StatWatcher` objects are "ref'ed", making it normally
+         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
+         * called previously.
+         * @since v14.3.0, v12.20.0
+         */
+        ref(): this;
+        /**
+         * When called, the active `fs.StatWatcher` object will not require the Node.js
+         * event loop to remain active. If there is no other activity keeping the
+         * event loop running, the process may exit before the `fs.StatWatcher` object's
+         * callback is invoked. Calling `watcher.unref()` multiple times will have
+         * no effect.
+         * @since v14.3.0, v12.20.0
+         */
+        unref(): this;
+    }
+    export interface FSWatcher extends EventEmitter {
+        /**
+         * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
+         * @since v0.5.8
+         */
+        close(): void;
+        /**
+         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
+         * no effect.
+         *
+         * By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
+         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
+         * called previously.
+         * @since v14.3.0, v12.20.0
+         */
+        ref(): this;
+        /**
+         * When called, the active `fs.FSWatcher` object will not require the Node.js
+         * event loop to remain active. If there is no other activity keeping the
+         * event loop running, the process may exit before the `fs.FSWatcher` object's
+         * callback is invoked. Calling `watcher.unref()` multiple times will have
+         * no effect.
+         * @since v14.3.0, v12.20.0
+         */
+        unref(): this;
+        /**
+         * events.EventEmitter
+         *   1. change
+         *   2. close
+         *   3. error
+         */
+        addListener(event: string, listener: (...args: any[]) => void): this;
+        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "error", listener: (error: Error) => void): this;
+        on(event: string, listener: (...args: any[]) => void): this;
+        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "error", listener: (error: Error) => void): this;
+        once(event: string, listener: (...args: any[]) => void): this;
+        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "error", listener: (error: Error) => void): this;
+        prependListener(event: string, listener: (...args: any[]) => void): this;
+        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "error", listener: (error: Error) => void): this;
+        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (error: Error) => void): this;
+    }
+    /**
+     * Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.
+     * @since v0.1.93
+     */
+    export class ReadStream extends stream.Readable {
+        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
+        /**
+         * The number of bytes that have been read so far.
+         * @since v6.4.0
+         */
+        bytesRead: number;
+        /**
+         * The path to the file the stream is reading from as specified in the first
+         * argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a
+         * `Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.
+         * @since v0.1.93
+         */
+        path: string | Buffer;
+        /**
+         * This property is `true` if the underlying file has not been opened yet,
+         * i.e. before the `'ready'` event is emitted.
+         * @since v11.2.0, v10.16.0
+         */
+        pending: boolean;
+        /**
+         * events.EventEmitter
+         *   1. open
+         *   2. close
+         *   3. ready
+         */
+        addListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        on<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        once<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        prependListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        prependOnceListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+    }
+
+    /**
+     * The Keys are events of the ReadStream and the values are the functions that are called when the event is emitted.
+     */
+    type ReadStreamEvents = {
+        close: () => void;
+        data: (chunk: Buffer | string) => void;
+        end: () => void;
+        error: (err: Error) => void;
+        open: (fd: number) => void;
+        pause: () => void;
+        readable: () => void;
+        ready: () => void;
+        resume: () => void;
+    } & CustomEvents;
+
+    /**
+     * string & {} allows to allow any kind of strings for the event
+     * but still allows to have auto completion for the normal events.
+     */
+    type CustomEvents = { [Key in string & {} | symbol]: (...args: any[]) => void };
+
+    /**
+     * The Keys are events of the WriteStream and the values are the functions that are called when the event is emitted.
+     */
+    type WriteStreamEvents = {
+        close: () => void;
+        drain: () => void;
+        error: (err: Error) => void;
+        finish: () => void;
+        open: (fd: number) => void;
+        pipe: (src: stream.Readable) => void;
+        ready: () => void;
+        unpipe: (src: stream.Readable) => void;
+    } & CustomEvents;
+    /**
+     * * Extends `stream.Writable`
+     *
+     * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
+     * @since v0.1.93
+     */
+    export class WriteStream extends stream.Writable {
+        /**
+         * Closes `writeStream`. Optionally accepts a
+         * callback that will be executed once the `writeStream`is closed.
+         * @since v0.9.4
+         */
+        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
+        /**
+         * The number of bytes written so far. Does not include data that is still queued
+         * for writing.
+         * @since v0.4.7
+         */
+        bytesWritten: number;
+        /**
+         * The path to the file the stream is writing to as specified in the first
+         * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
+         * `Buffer`.
+         * @since v0.1.93
+         */
+        path: string | Buffer;
+        /**
+         * This property is `true` if the underlying file has not been opened yet,
+         * i.e. before the `'ready'` event is emitted.
+         * @since v11.2.0
+         */
+        pending: boolean;
+        /**
+         * events.EventEmitter
+         *   1. open
+         *   2. close
+         *   3. ready
+         */
+        addListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        on<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        once<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        prependListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        prependOnceListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+    }
+    /**
+     * Asynchronously rename file at `oldPath` to the pathname provided
+     * as `newPath`. In the case that `newPath` already exists, it will
+     * be overwritten. If there is a directory at `newPath`, an error will
+     * be raised instead. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).
+     *
+     * ```js
+     * import { rename } from 'node:fs';
+     *
+     * rename('oldFile.txt', 'newFile.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('Rename complete!');
+     * });
+     * ```
+     * @since v0.0.2
+     */
+    export function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
+    export namespace rename {
+        /**
+         * Asynchronous rename(2) - Change the name or location of a file or directory.
+         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
+    }
+    /**
+     * Renames the file from `oldPath` to `newPath`. Returns `undefined`.
+     *
+     * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
+     * @since v0.1.21
+     */
+    export function renameSync(oldPath: PathLike, newPath: PathLike): void;
+    /**
+     * Truncates the file. No arguments other than a possible exception are
+     * given to the completion callback. A file descriptor can also be passed as the
+     * first argument. In this case, `fs.ftruncate()` is called.
+     *
+     * ```js
+     * import { truncate } from 'node:fs';
+     * // Assuming that 'path/file.txt' is a regular file.
+     * truncate('path/file.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('path/file.txt was truncated');
+     * });
+     * ```
+     *
+     * Passing a file descriptor is deprecated and may result in an error being thrown
+     * in the future.
+     *
+     * See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function truncate(path: PathLike, len: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronous truncate(2) - Truncate a file to a specified length.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function truncate(path: PathLike, callback: NoParamCallback): void;
+    export namespace truncate {
+        /**
+         * Asynchronous truncate(2) - Truncate a file to a specified length.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param len If not specified, defaults to `0`.
+         */
+        function __promisify__(path: PathLike, len?: number): Promise<void>;
+    }
+    /**
+     * Truncates the file. Returns `undefined`. A file descriptor can also be
+     * passed as the first argument. In this case, `fs.ftruncateSync()` is called.
+     *
+     * Passing a file descriptor is deprecated and may result in an error being thrown
+     * in the future.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function truncateSync(path: PathLike, len?: number): void;
+    /**
+     * Truncates the file descriptor. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.
+     *
+     * If the file referred to by the file descriptor was larger than `len` bytes, only
+     * the first `len` bytes will be retained in the file.
+     *
+     * For example, the following program retains only the first four bytes of the
+     * file:
+     *
+     * ```js
+     * import { open, close, ftruncate } from 'node:fs';
+     *
+     * function closeFd(fd) {
+     *   close(fd, (err) => {
+     *     if (err) throw err;
+     *   });
+     * }
+     *
+     * open('temp.txt', 'r+', (err, fd) => {
+     *   if (err) throw err;
+     *
+     *   try {
+     *     ftruncate(fd, 4, (err) => {
+     *       closeFd(fd);
+     *       if (err) throw err;
+     *     });
+     *   } catch (err) {
+     *     closeFd(fd);
+     *     if (err) throw err;
+     *   }
+     * });
+     * ```
+     *
+     * If the file previously was shorter than `len` bytes, it is extended, and the
+     * extended part is filled with null bytes (`'\0'`):
+     *
+     * If `len` is negative then `0` will be used.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function ftruncate(fd: number, len: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
+     * @param fd A file descriptor.
+     */
+    export function ftruncate(fd: number, callback: NoParamCallback): void;
+    export namespace ftruncate {
+        /**
+         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
+         * @param fd A file descriptor.
+         * @param len If not specified, defaults to `0`.
+         */
+        function __promisify__(fd: number, len?: number): Promise<void>;
+    }
+    /**
+     * Truncates the file descriptor. Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link ftruncate}.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function ftruncateSync(fd: number, len?: number): void;
+    /**
+     * Asynchronously changes owner and group of a file. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
+     * @since v0.1.97
+     */
+    export function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace chown {
+        /**
+         * Asynchronous chown(2) - Change ownership of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Synchronously changes owner and group of a file. Returns `undefined`.
+     * This is the synchronous version of {@link chown}.
+     *
+     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
+     * @since v0.1.97
+     */
+    export function chownSync(path: PathLike, uid: number, gid: number): void;
+    /**
+     * Sets the owner of the file. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace fchown {
+        /**
+         * Asynchronous fchown(2) - Change ownership of a file.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Sets the owner of the file. Returns `undefined`.
+     *
+     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
+     * @since v0.4.7
+     * @param uid The file's new owner's user id.
+     * @param gid The file's new group's group id.
+     */
+    export function fchownSync(fd: number, uid: number, gid: number): void;
+    /**
+     * Set the owner of the symbolic link. No arguments other than a possible
+     * exception are given to the completion callback.
+     *
+     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.
+     */
+    export function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace lchown {
+        /**
+         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Set the owner for the path. Returns `undefined`.
+     *
+     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
+     * @param uid The file's new owner's user id.
+     * @param gid The file's new group's group id.
+     */
+    export function lchownSync(path: PathLike, uid: number, gid: number): void;
+    /**
+     * Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic
+     * link, then the link is not dereferenced: instead, the timestamps of the
+     * symbolic link itself are changed.
+     *
+     * No arguments other than a possible exception are given to the completion
+     * callback.
+     * @since v14.5.0, v12.19.0
+     */
+    export function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace lutimes {
+        /**
+         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
+         * with the difference that if the path refers to a symbolic link, then the link is not
+         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Change the file system timestamps of the symbolic link referenced by `path`.
+     * Returns `undefined`, or throws an exception when parameters are incorrect or
+     * the operation fails. This is the synchronous version of {@link lutimes}.
+     * @since v14.5.0, v12.19.0
+     */
+    export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Asynchronously changes the permissions of a file. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
+     *
+     * ```js
+     * import { chmod } from 'node:fs';
+     *
+     * chmod('my_file.txt', 0o775, (err) => {
+     *   if (err) throw err;
+     *   console.log('The permissions for file "my_file.txt" have been changed!');
+     * });
+     * ```
+     * @since v0.1.30
+     */
+    export function chmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
+    export namespace chmod {
+        /**
+         * Asynchronous chmod(2) - Change permissions of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link chmod}.
+     *
+     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
+     * @since v0.6.7
+     */
+    export function chmodSync(path: PathLike, mode: Mode): void;
+    /**
+     * Sets the permissions on the file. No arguments other than a possible exception
+     * are given to the completion callback.
+     *
+     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchmod(fd: number, mode: Mode, callback: NoParamCallback): void;
+    export namespace fchmod {
+        /**
+         * Asynchronous fchmod(2) - Change permissions of a file.
+         * @param fd A file descriptor.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(fd: number, mode: Mode): Promise<void>;
+    }
+    /**
+     * Sets the permissions on the file. Returns `undefined`.
+     *
+     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchmodSync(fd: number, mode: Mode): void;
+    /**
+     * Changes the permissions on a symbolic link. No arguments other than a possible
+     * exception are given to the completion callback.
+     *
+     * This method is only implemented on macOS.
+     *
+     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
+     * @deprecated Since v0.4.7
+     */
+    export function lchmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
+    /** @deprecated */
+    export namespace lchmod {
+        /**
+         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
+    }
+    /**
+     * Changes the permissions on a symbolic link. Returns `undefined`.
+     *
+     * This method is only implemented on macOS.
+     *
+     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
+     * @deprecated Since v0.4.7
+     */
+    export function lchmodSync(path: PathLike, mode: Mode): void;
+    /**
+     * Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     *
+     * {@link stat} follows symbolic links. Use {@link lstat} to look at the
+     * links themselves.
+     *
+     * Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.
+     * Instead, user code should open/read/write the file directly and handle the
+     * error raised if the file is not available.
+     *
+     * To check if a file exists without manipulating it afterwards, {@link access} is recommended.
+     *
+     * For example, given the following directory structure:
+     *
+     * ```text
+     * - txtDir
+     * -- file.txt
+     * - app.js
+     * ```
+     *
+     * The next program will check for the stats of the given paths:
+     *
+     * ```js
+     * import { stat } from 'node:fs';
+     *
+     * const pathsToCheck = ['./txtDir', './txtDir/file.txt'];
+     *
+     * for (let i = 0; i < pathsToCheck.length; i++) {
+     *   stat(pathsToCheck[i], (err, stats) => {
+     *     console.log(stats.isDirectory());
+     *     console.log(stats);
+     *   });
+     * }
+     * ```
+     *
+     * The resulting output will resemble:
+     *
+     * ```console
+     * true
+     * Stats {
+     *   dev: 16777220,
+     *   mode: 16877,
+     *   nlink: 3,
+     *   uid: 501,
+     *   gid: 20,
+     *   rdev: 0,
+     *   blksize: 4096,
+     *   ino: 14214262,
+     *   size: 96,
+     *   blocks: 0,
+     *   atimeMs: 1561174653071.963,
+     *   mtimeMs: 1561174614583.3518,
+     *   ctimeMs: 1561174626623.5366,
+     *   birthtimeMs: 1561174126937.2893,
+     *   atime: 2019-06-22T03:37:33.072Z,
+     *   mtime: 2019-06-22T03:36:54.583Z,
+     *   ctime: 2019-06-22T03:37:06.624Z,
+     *   birthtime: 2019-06-22T03:28:46.937Z
+     * }
+     * false
+     * Stats {
+     *   dev: 16777220,
+     *   mode: 33188,
+     *   nlink: 1,
+     *   uid: 501,
+     *   gid: 20,
+     *   rdev: 0,
+     *   blksize: 4096,
+     *   ino: 14214074,
+     *   size: 8,
+     *   blocks: 8,
+     *   atimeMs: 1561174616618.8555,
+     *   mtimeMs: 1561174614584,
+     *   ctimeMs: 1561174614583.8145,
+     *   birthtimeMs: 1561174007710.7478,
+     *   atime: 2019-06-22T03:36:56.619Z,
+     *   mtime: 2019-06-22T03:36:54.584Z,
+     *   ctime: 2019-06-22T03:36:54.584Z,
+     *   birthtime: 2019-06-22T03:26:47.711Z
+     * }
+     * ```
+     * @since v0.0.2
+     */
+    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function stat(
+        path: PathLike,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function stat(
+        path: PathLike,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function stat(
+        path: PathLike,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace stat {
+        /**
+         * Asynchronous stat(2) - Get file status.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            path: PathLike,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    export interface StatSyncFn extends Function {
+        (path: PathLike, options?: undefined): Stats;
+        (
+            path: PathLike,
+            options?: StatSyncOptions & {
+                bigint?: false | undefined;
+                throwIfNoEntry: false;
+            },
+        ): Stats | undefined;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: true;
+                throwIfNoEntry: false;
+            },
+        ): BigIntStats | undefined;
+        (
+            path: PathLike,
+            options?: StatSyncOptions & {
+                bigint?: false | undefined;
+            },
+        ): Stats;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: true;
+            },
+        ): BigIntStats;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: boolean;
+                throwIfNoEntry?: false | undefined;
+            },
+        ): Stats | BigIntStats;
+        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;
+    }
+    /**
+     * Synchronous stat(2) - Get file status.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export const statSync: StatSyncFn;
+    /**
+     * Invokes the callback with the `fs.Stats` for the file descriptor.
+     *
+     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
+     * @since v0.1.95
+     */
+    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function fstat(
+        fd: number,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function fstat(
+        fd: number,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function fstat(
+        fd: number,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace fstat {
+        /**
+         * Asynchronous fstat(2) - Get file status.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(
+            fd: number,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            fd: number,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    /**
+     * Retrieves the `fs.Stats` for the file descriptor.
+     *
+     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
+     * @since v0.1.95
+     */
+    export function fstatSync(
+        fd: number,
+        options?: StatOptions & {
+            bigint?: false | undefined;
+        },
+    ): Stats;
+    export function fstatSync(
+        fd: number,
+        options: StatOptions & {
+            bigint: true;
+        },
+    ): BigIntStats;
+    export function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;
+    /**
+     * Retrieves the `fs.Stats` for the symbolic link referred to by the path.
+     * The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic
+     * link, then the link itself is stat-ed, not the file that it refers to.
+     *
+     * See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.
+     * @since v0.1.30
+     */
+    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function lstat(
+        path: PathLike,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function lstat(
+        path: PathLike,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function lstat(
+        path: PathLike,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace lstat {
+        /**
+         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            path: PathLike,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    /**
+     * Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
+     * contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     * @since v19.6.0, v18.15.0
+     * @param path A path to an existing file or directory on the file system to be queried.
+     */
+    export function statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void): void;
+    export function statfs(
+        path: PathLike,
+        options:
+            | (StatFsOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void,
+    ): void;
+    export function statfs(
+        path: PathLike,
+        options: StatFsOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStatsFs) => void,
+    ): void;
+    export function statfs(
+        path: PathLike,
+        options: StatFsOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs | BigIntStatsFs) => void,
+    ): void;
+    export namespace statfs {
+        /**
+         * Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.
+         * @param path A path to an existing file or directory on the file system to be queried.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatFsOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<StatsFs>;
+        function __promisify__(
+            path: PathLike,
+            options: StatFsOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStatsFs>;
+        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
+    }
+    /**
+     * Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
+     * contains `path`.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     * @since v19.6.0, v18.15.0
+     * @param path A path to an existing file or directory on the file system to be queried.
+     */
+    export function statfsSync(
+        path: PathLike,
+        options?: StatFsOptions & {
+            bigint?: false | undefined;
+        },
+    ): StatsFs;
+    export function statfsSync(
+        path: PathLike,
+        options: StatFsOptions & {
+            bigint: true;
+        },
+    ): BigIntStatsFs;
+    export function statfsSync(path: PathLike, options?: StatFsOptions): StatsFs | BigIntStatsFs;
+    /**
+     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export const lstatSync: StatSyncFn;
+    /**
+     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than
+     * a possible
+     * exception are given to the completion callback.
+     * @since v0.1.31
+     */
+    export function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
+    export namespace link {
+        /**
+         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
+         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
+    }
+    /**
+     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
+     * @since v0.1.31
+     */
+    export function linkSync(existingPath: PathLike, newPath: PathLike): void;
+    /**
+     * Creates the link called `path` pointing to `target`. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.
+     *
+     * The `type` argument is only available on Windows and ignored on other platforms.
+     * It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is
+     * not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.
+     * If the `target` does not exist, `'file'` will be used. Windows junction points
+     * require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction
+     * points on NTFS volumes can only point to directories.
+     *
+     * Relative targets are relative to the link's parent directory.
+     *
+     * ```js
+     * import { symlink } from 'node:fs';
+     *
+     * symlink('./mew', './mewtwo', callback);
+     * ```
+     *
+     * The above example creates a symbolic link `mewtwo` which points to `mew` in the
+     * same directory:
+     *
+     * ```bash
+     * $ tree .
+     * .
+     * ├── mew
+     * └── mewtwo -> ./mew
+     * ```
+     * @since v0.1.31
+     * @param [type='null']
+     */
+    export function symlink(
+        target: PathLike,
+        path: PathLike,
+        type: symlink.Type | undefined | null,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
+     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
+     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;
+    export namespace symlink {
+        /**
+         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
+         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
+         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
+         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
+         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
+         */
+        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
+        type Type = "dir" | "file" | "junction";
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link symlink}.
+     * @since v0.1.31
+     * @param [type='null']
+     */
+    export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
+    /**
+     * Reads the contents of the symbolic link referred to by `path`. The callback gets
+     * two arguments `(err, linkString)`.
+     *
+     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the link path passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the link path returned will be passed as a `Buffer` object.
+     * @since v0.1.31
+     */
+    export function readlink(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlink(
+        path: PathLike,
+        options: BufferEncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlink(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function readlink(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
+    ): void;
+    export namespace readlink {
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
+    }
+    /**
+     * Returns the symbolic link's string value.
+     *
+     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the link path returned. If the `encoding` is set to `'buffer'`,
+     * the link path returned will be passed as a `Buffer` object.
+     * @since v0.1.31
+     */
+    export function readlinkSync(path: PathLike, options?: EncodingOption): string;
+    /**
+     * Synchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
+    /**
+     * Asynchronously computes the canonical pathname by resolving `.`, `..`, and
+     * symbolic links.
+     *
+     * A canonical pathname is not necessarily unique. Hard links and bind mounts can
+     * expose a file system entity through many pathnames.
+     *
+     * This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:
+     *
+     * 1. No case conversion is performed on case-insensitive file systems.
+     * 2. The maximum number of symbolic links is platform-independent and generally
+     * (much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.
+     *
+     * The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.
+     *
+     * Only paths that can be converted to UTF8 strings are supported.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the path passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the path returned will be passed as a `Buffer` object.
+     *
+     * If `path` resolves to a socket or a pipe, the function will return a system
+     * dependent name for that object.
+     * @since v0.1.31
+     */
+    export function realpath(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpath(
+        path: PathLike,
+        options: BufferEncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpath(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function realpath(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+    ): void;
+    export namespace realpath {
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
+        /**
+         * Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).
+         *
+         * The `callback` gets two arguments `(err, resolvedPath)`.
+         *
+         * Only paths that can be converted to UTF8 strings are supported.
+         *
+         * The optional `options` argument can be a string specifying an encoding, or an
+         * object with an `encoding` property specifying the character encoding to use for
+         * the path passed to the callback. If the `encoding` is set to `'buffer'`,
+         * the path returned will be passed as a `Buffer` object.
+         *
+         * On Linux, when Node.js is linked against musl libc, the procfs file system must
+         * be mounted on `/proc` in order for this function to work. Glibc does not have
+         * this restriction.
+         * @since v9.2.0
+         */
+        function native(
+            path: PathLike,
+            options: EncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            options: BufferEncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            options: EncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+        ): void;
+    }
+    /**
+     * Returns the resolved pathname.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link realpath}.
+     * @since v0.1.31
+     */
+    export function realpathSync(path: PathLike, options?: EncodingOption): string;
+    /**
+     * Synchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
+    export namespace realpathSync {
+        function native(path: PathLike, options?: EncodingOption): string;
+        function native(path: PathLike, options: BufferEncodingOption): Buffer;
+        function native(path: PathLike, options?: EncodingOption): string | Buffer;
+    }
+    /**
+     * Asynchronously removes a file or symbolic link. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * ```js
+     * import { unlink } from 'node:fs';
+     * // Assuming that 'path/file.txt' is a regular file.
+     * unlink('path/file.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('path/file.txt was deleted');
+     * });
+     * ```
+     *
+     * `fs.unlink()` will not work on a directory, empty or otherwise. To remove a
+     * directory, use {@link rmdir}.
+     *
+     * See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.
+     * @since v0.0.2
+     */
+    export function unlink(path: PathLike, callback: NoParamCallback): void;
+    export namespace unlink {
+        /**
+         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike): Promise<void>;
+    }
+    /**
+     * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
+     * @since v0.1.21
+     */
+    export function unlinkSync(path: PathLike): void;
+    export interface RmDirOptions {
+        /**
+         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
+         * `EPERM` error is encountered, Node.js will retry the operation with a linear
+         * backoff wait of `retryDelay` ms longer on each try. This option represents the
+         * number of retries. This option is ignored if the `recursive` option is not
+         * `true`.
+         * @default 0
+         */
+        maxRetries?: number | undefined;
+        /**
+         * @deprecated since v14.14.0 In future versions of Node.js and will trigger a warning
+         * `fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.
+         * Use `fs.rm(path, { recursive: true, force: true })` instead.
+         *
+         * If `true`, perform a recursive directory removal. In
+         * recursive mode, operations are retried on failure.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * The amount of time in milliseconds to wait between retries.
+         * This option is ignored if the `recursive` option is not `true`.
+         * @default 100
+         */
+        retryDelay?: number | undefined;
+    }
+    /**
+     * Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given
+     * to the completion callback.
+     *
+     * Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on
+     * Windows and an `ENOTDIR` error on POSIX.
+     *
+     * To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.
+     * @since v0.0.2
+     */
+    export function rmdir(path: PathLike, callback: NoParamCallback): void;
+    export function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;
+    export namespace rmdir {
+        /**
+         * Asynchronous rmdir(2) - delete a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
+    }
+    /**
+     * Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.
+     *
+     * Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error
+     * on Windows and an `ENOTDIR` error on POSIX.
+     *
+     * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
+     * @since v0.1.21
+     */
+    export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
+    export interface RmOptions {
+        /**
+         * When `true`, exceptions will be ignored if `path` does not exist.
+         * @default false
+         */
+        force?: boolean | undefined;
+        /**
+         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
+         * `EPERM` error is encountered, Node.js will retry the operation with a linear
+         * backoff wait of `retryDelay` ms longer on each try. This option represents the
+         * number of retries. This option is ignored if the `recursive` option is not
+         * `true`.
+         * @default 0
+         */
+        maxRetries?: number | undefined;
+        /**
+         * If `true`, perform a recursive directory removal. In
+         * recursive mode, operations are retried on failure.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * The amount of time in milliseconds to wait between retries.
+         * This option is ignored if the `recursive` option is not `true`.
+         * @default 100
+         */
+        retryDelay?: number | undefined;
+    }
+    /**
+     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the
+     * completion callback.
+     * @since v14.14.0
+     */
+    export function rm(path: PathLike, callback: NoParamCallback): void;
+    export function rm(path: PathLike, options: RmOptions, callback: NoParamCallback): void;
+    export namespace rm {
+        /**
+         * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
+         */
+        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;
+    }
+    /**
+     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
+     * @since v14.14.0
+     */
+    export function rmSync(path: PathLike, options?: RmOptions): void;
+    export interface MakeDirectoryOptions {
+        /**
+         * Indicates whether parent folders should be created.
+         * If a folder was created, the path to the first created folder will be returned.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
+         * @default 0o777
+         */
+        mode?: Mode | undefined;
+    }
+    /**
+     * Asynchronously creates a directory.
+     *
+     * The callback is given a possible exception and, if `recursive` is `true`, the
+     * first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was
+     * created (for instance, if it was previously created).
+     *
+     * The optional `options` argument can be an integer specifying `mode` (permission
+     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that
+     * exists results in an error only
+     * when `recursive` is false. If `recursive` is false and the directory exists,
+     * an `EEXIST` error occurs.
+     *
+     * ```js
+     * import { mkdir } from 'node:fs';
+     *
+     * // Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.
+     * mkdir('./tmp/a/apple', { recursive: true }, (err) => {
+     *   if (err) throw err;
+     * });
+     * ```
+     *
+     * On Windows, using `fs.mkdir()` on the root directory even with recursion will
+     * result in an error:
+     *
+     * ```js
+     * import { mkdir } from 'node:fs';
+     *
+     * mkdir('/', { recursive: true }, (err) => {
+     *   // => [Error: EPERM: operation not permitted, mkdir 'C:\']
+     * });
+     * ```
+     *
+     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
+     * @since v0.1.8
+     */
+    export function mkdir(
+        path: PathLike,
+        options: MakeDirectoryOptions & {
+            recursive: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdir(
+        path: PathLike,
+        options:
+            | Mode
+            | (MakeDirectoryOptions & {
+                recursive?: false | undefined;
+            })
+            | null
+            | undefined,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdir(
+        path: PathLike,
+        options: Mode | MakeDirectoryOptions | null | undefined,
+        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function mkdir(path: PathLike, callback: NoParamCallback): void;
+    export namespace mkdir {
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options: MakeDirectoryOptions & {
+                recursive: true;
+            },
+        ): Promise<string | undefined>;
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | Mode
+                | (MakeDirectoryOptions & {
+                    recursive?: false | undefined;
+                })
+                | null,
+        ): Promise<void>;
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: Mode | MakeDirectoryOptions | null,
+        ): Promise<string | undefined>;
+    }
+    /**
+     * Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.
+     * This is the synchronous version of {@link mkdir}.
+     *
+     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
+     * @since v0.1.21
+     */
+    export function mkdirSync(
+        path: PathLike,
+        options: MakeDirectoryOptions & {
+            recursive: true;
+        },
+    ): string | undefined;
+    /**
+     * Synchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdirSync(
+        path: PathLike,
+        options?:
+            | Mode
+            | (MakeDirectoryOptions & {
+                recursive?: false | undefined;
+            })
+            | null,
+    ): void;
+    /**
+     * Synchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
+    /**
+     * Creates a unique temporary directory.
+     *
+     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform
+     * inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,
+     * notably the BSDs, can return more than six random characters, and replace
+     * trailing `X` characters in `prefix` with random characters.
+     *
+     * The created directory path is passed as a string to the callback's second
+     * parameter.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use.
+     *
+     * ```js
+     * import { mkdtemp } from 'node:fs';
+     * import { join } from 'node:path';
+     * import { tmpdir } from 'node:os';
+     *
+     * mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
+     * });
+     * ```
+     *
+     * The `fs.mkdtemp()` method will append the six randomly selected characters
+     * directly to the `prefix` string. For instance, given a directory `/tmp`, if the
+     * intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator
+     * (`import { sep } from 'node:path'`).
+     *
+     * ```js
+     * import { tmpdir } from 'node:os';
+     * import { mkdtemp } from 'node:fs';
+     *
+     * // The parent directory for the new temporary directory
+     * const tmpDir = tmpdir();
+     *
+     * // This method is *INCORRECT*:
+     * mkdtemp(tmpDir, (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Will print something similar to `/tmpabc123`.
+     *   // A new temporary directory is created at the file system root
+     *   // rather than *within* the /tmp directory.
+     * });
+     *
+     * // This method is *CORRECT*:
+     * import { sep } from 'node:path';
+     * mkdtemp(`${tmpDir}${sep}`, (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Will print something similar to `/tmp/abc123`.
+     *   // A new temporary directory is created within
+     *   // the /tmp directory.
+     * });
+     * ```
+     * @since v5.10.0
+     */
+    export function mkdtemp(
+        prefix: string,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtemp(
+        prefix: string,
+        options:
+            | "buffer"
+            | {
+                encoding: "buffer";
+            },
+        callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtemp(
+        prefix: string,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     */
+    export function mkdtemp(
+        prefix: string,
+        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
+    ): void;
+    export namespace mkdtemp {
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;
+    }
+    /**
+     * Returns the created directory path.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link mkdtemp}.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use.
+     * @since v5.10.0
+     */
+    export function mkdtempSync(prefix: string, options?: EncodingOption): string;
+    /**
+     * Synchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
+    /**
+     * Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.
+     *
+     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the filenames passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the filenames returned will be passed as `Buffer` objects.
+     *
+     * If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.
+     * @since v0.1.8
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | {
+                encoding: BufferEncoding | null;
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | {
+                encoding: "buffer";
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | "buffer",
+        callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | (ObjectEncodingOptions & {
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            })
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function readdir(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
+     */
+    export function readdir(
+        path: PathLike,
+        options: ObjectEncodingOptions & {
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+        callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+     */
+    export function readdir(
+        path: PathLike,
+        options: {
+            encoding: "buffer";
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+        callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void,
+    ): void;
+    export namespace readdir {
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | {
+                    encoding: BufferEncoding | null;
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                }
+                | BufferEncoding
+                | null,
+        ): Promise<string[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options:
+                | "buffer"
+                | {
+                    encoding: "buffer";
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                },
+        ): Promise<Buffer[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | (ObjectEncodingOptions & {
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                })
+                | BufferEncoding
+                | null,
+        ): Promise<string[] | Buffer[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent
+         */
+        function __promisify__(
+            path: PathLike,
+            options: ObjectEncodingOptions & {
+                withFileTypes: true;
+                recursive?: boolean | undefined;
+            },
+        ): Promise<Dirent[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options: {
+                encoding: "buffer";
+                withFileTypes: true;
+                recursive?: boolean | undefined;
+            },
+        ): Promise<Dirent<Buffer>[]>;
+    }
+    /**
+     * Reads the contents of the directory.
+     *
+     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the filenames returned. If the `encoding` is set to `'buffer'`,
+     * the filenames returned will be passed as `Buffer` objects.
+     *
+     * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
+     * @since v0.1.21
+     */
+    export function readdirSync(
+        path: PathLike,
+        options?:
+            | {
+                encoding: BufferEncoding | null;
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | BufferEncoding
+            | null,
+    ): string[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options:
+            | {
+                encoding: "buffer";
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | "buffer",
+    ): Buffer[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options?:
+            | (ObjectEncodingOptions & {
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            })
+            | BufferEncoding
+            | null,
+    ): string[] | Buffer[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options: ObjectEncodingOptions & {
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+    ): Dirent[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options: {
+            encoding: "buffer";
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+    ): Dirent<Buffer>[];
+    /**
+     * Closes the file descriptor. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * Calling `fs.close()` on any file descriptor (`fd`) that is currently in use
+     * through any other `fs` operation may lead to undefined behavior.
+     *
+     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
+     * @since v0.0.2
+     */
+    export function close(fd: number, callback?: NoParamCallback): void;
+    export namespace close {
+        /**
+         * Asynchronous close(2) - close a file descriptor.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Closes the file descriptor. Returns `undefined`.
+     *
+     * Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use
+     * through any other `fs` operation may lead to undefined behavior.
+     *
+     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
+     * @since v0.1.21
+     */
+    export function closeSync(fd: number): void;
+    /**
+     * Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.
+     *
+     * `mode` sets the file mode (permission and sticky bits), but only if the file was
+     * created. On Windows, only the write permission can be manipulated; see {@link chmod}.
+     *
+     * The callback gets two arguments `(err, fd)`.
+     *
+     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
+     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
+     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
+     *
+     * Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.
+     * @since v0.0.2
+     * @param [flags='r'] See `support of file system `flags``.
+     * @param [mode=0o666]
+     */
+    export function open(
+        path: PathLike,
+        flags: OpenMode | undefined,
+        mode: Mode | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
+    ): void;
+    /**
+     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param [flags='r'] See `support of file system `flags``.
+     */
+    export function open(
+        path: PathLike,
+        flags: OpenMode | undefined,
+        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
+    ): void;
+    /**
+     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;
+    export namespace open {
+        /**
+         * Asynchronous open(2) - open and possibly create a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
+         */
+        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;
+    }
+    /**
+     * Returns an integer representing the file descriptor.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link open}.
+     * @since v0.1.21
+     * @param [flags='r']
+     * @param [mode=0o666]
+     */
+    export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
+    /**
+     * Change the file system timestamps of the object referenced by `path`.
+     *
+     * The `atime` and `mtime` arguments follow these rules:
+     *
+     * * Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.
+     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
+     * @since v0.4.2
+     */
+    export function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace utimes {
+        /**
+         * Asynchronously change file timestamps of the file referenced by the supplied path.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link utimes}.
+     * @since v0.4.2
+     */
+    export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Change the file system timestamps of the object referenced by the supplied file
+     * descriptor. See {@link utimes}.
+     * @since v0.4.2
+     */
+    export function futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace futimes {
+        /**
+         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Synchronous version of {@link futimes}. Returns `undefined`.
+     * @since v0.4.2
+     */
+    export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Request that all data for the open file descriptor is flushed to the storage
+     * device. The specific implementation is operating system and device specific.
+     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other
+     * than a possible exception are given to the completion callback.
+     * @since v0.1.96
+     */
+    export function fsync(fd: number, callback: NoParamCallback): void;
+    export namespace fsync {
+        /**
+         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Request that all data for the open file descriptor is flushed to the storage
+     * device. The specific implementation is operating system and device specific.
+     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
+     * @since v0.1.96
+     */
+    export function fsyncSync(fd: number): void;
+    export interface WriteOptions {
+        /**
+         * @default 0
+         */
+        offset?: number | undefined;
+        /**
+         * @default `buffer.byteLength - offset`
+         */
+        length?: number | undefined;
+        /**
+         * @default null
+         */
+        position?: number | undefined | null;
+    }
+    /**
+     * Write `buffer` to the file specified by `fd`.
+     *
+     * `offset` determines the part of the buffer to be written, and `length` is
+     * an integer specifying the number of bytes to write.
+     *
+     * `position` refers to the offset from the beginning of the file where this data
+     * should be written. If `typeof position !== 'number'`, the data will be written
+     * at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).
+     *
+     * The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesWritten` and `buffer` properties.
+     *
+     * It is unsafe to use `fs.write()` multiple times on the same file without waiting
+     * for the callback. For this scenario, {@link createWriteStream} is
+     * recommended.
+     *
+     * On Linux, positional writes don't work when the file is opened in append mode.
+     * The kernel ignores the position argument and always appends the data to
+     * the end of the file.
+     * @since v0.0.2
+     * @param [offset=0]
+     * @param [length=buffer.byteLength - offset]
+     * @param [position='null']
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        length: number | undefined | null,
+        position: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        length: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param options An object with the following properties:
+     * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
+     * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+     * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        options: WriteOptions,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     * @param encoding The expected string encoding.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        position: number | undefined | null,
+        encoding: BufferEncoding | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        position: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    export namespace write {
+        /**
+         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer?: TBuffer,
+            offset?: number,
+            length?: number,
+            position?: number | null,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: TBuffer;
+        }>;
+        /**
+         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param options An object with the following properties:
+         * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
+         * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+         * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer?: TBuffer,
+            options?: WriteOptions,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: TBuffer;
+        }>;
+        /**
+         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param string A string to write.
+         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         * @param encoding The expected string encoding.
+         */
+        function __promisify__(
+            fd: number,
+            string: string,
+            position?: number | null,
+            encoding?: BufferEncoding | null,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: string;
+        }>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link write}.
+     * @since v0.1.21
+     * @param [offset=0]
+     * @param [length=buffer.byteLength - offset]
+     * @param [position='null']
+     * @return The number of bytes written.
+     */
+    export function writeSync(
+        fd: number,
+        buffer: NodeJS.ArrayBufferView,
+        offset?: number | null,
+        length?: number | null,
+        position?: number | null,
+    ): number;
+    /**
+     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     * @param encoding The expected string encoding.
+     */
+    export function writeSync(
+        fd: number,
+        string: string,
+        position?: number | null,
+        encoding?: BufferEncoding | null,
+    ): number;
+    export type ReadPosition = number | bigint;
+    export interface ReadSyncOptions {
+        /**
+         * @default 0
+         */
+        offset?: number | undefined;
+        /**
+         * @default `length of buffer`
+         */
+        length?: number | undefined;
+        /**
+         * @default null
+         */
+        position?: ReadPosition | null | undefined;
+    }
+    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {
+        buffer?: TBuffer;
+    }
+    /**
+     * Read data from the file specified by `fd`.
+     *
+     * The callback is given the three arguments, `(err, bytesRead, buffer)`.
+     *
+     * If the file is not modified concurrently, the end-of-file is reached when the
+     * number of bytes read is zero.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesRead` and `buffer` properties.
+     * @since v0.0.2
+     * @param buffer The buffer that the data will be written to.
+     * @param offset The position in `buffer` to write the data to.
+     * @param length The number of bytes to read.
+     * @param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If
+     * `position` is an integer, the file position will be unchanged.
+     */
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number,
+        length: number,
+        position: ReadPosition | null,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Similar to the above `fs.read` function, this version takes an optional `options` object.
+     * If not otherwise specified in an `options` object,
+     * `buffer` defaults to `Buffer.alloc(16384)`,
+     * `offset` defaults to `0`,
+     * `length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0
+     * `position` defaults to `null`
+     * @since v12.17.0, 13.11.0
+     */
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        options: ReadAsyncOptions<TBuffer>,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        options: ReadSyncOptions,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read(
+        fd: number,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: NodeJS.ArrayBufferView) => void,
+    ): void;
+    export namespace read {
+        /**
+         * @param fd A file descriptor.
+         * @param buffer The buffer that the data will be written to.
+         * @param offset The offset in the buffer at which to start writing.
+         * @param length The number of bytes to read.
+         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer: TBuffer,
+            offset: number,
+            length: number,
+            position: ReadPosition | null,
+        ): Promise<{
+            bytesRead: number;
+            buffer: TBuffer;
+        }>;
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            options: ReadAsyncOptions<TBuffer>,
+        ): Promise<{
+            bytesRead: number;
+            buffer: TBuffer;
+        }>;
+        function __promisify__(fd: number): Promise<{
+            bytesRead: number;
+            buffer: NodeJS.ArrayBufferView;
+        }>;
+    }
+    /**
+     * Returns the number of `bytesRead`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link read}.
+     * @since v0.1.21
+     * @param [position='null']
+     */
+    export function readSync(
+        fd: number,
+        buffer: NodeJS.ArrayBufferView,
+        offset: number,
+        length: number,
+        position: ReadPosition | null,
+    ): number;
+    /**
+     * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
+     * If no `options` object is specified, it will default with the above values.
+     */
+    export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * readFile('/etc/passwd', (err, data) => {
+     *   if (err) throw err;
+     *   console.log(data);
+     * });
+     * ```
+     *
+     * The callback is passed two arguments `(err, data)`, where `data` is the
+     * contents of the file.
+     *
+     * If no encoding is specified, then the raw buffer is returned.
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * readFile('/etc/passwd', 'utf8', callback);
+     * ```
+     *
+     * When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an
+     * error will be returned. On FreeBSD, a representation of the directory's contents
+     * will be returned.
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * // macOS, Linux, and Windows
+     * readFile('<directory>', (err, data) => {
+     *   // => [Error: EISDIR: illegal operation on a directory, read <directory>]
+     * });
+     *
+     * //  FreeBSD
+     * readFile('<directory>', (err, data) => {
+     *   // => null, <data>
+     * });
+     * ```
+     *
+     * It is possible to abort an ongoing request using an `AbortSignal`. If a
+     * request is aborted the callback is called with an `AbortError`:
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * const controller = new AbortController();
+     * const signal = controller.signal;
+     * readFile(fileInfo[0].name, { signal }, (err, buf) => {
+     *   // ...
+     * });
+     * // When you want to abort the request
+     * controller.abort();
+     * ```
+     *
+     * The `fs.readFile()` function buffers the entire file. To minimize memory costs,
+     * when possible prefer streaming via `fs.createReadStream()`.
+     *
+     * Aborting an ongoing request does not abort individual operating
+     * system requests but rather the internal buffering `fs.readFile` performs.
+     * @since v0.1.29
+     * @param path filename or file descriptor
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | ({
+                encoding?: null | undefined;
+                flag?: string | undefined;
+            } & Abortable)
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | ({
+                encoding: BufferEncoding;
+                flag?: string | undefined;
+            } & Abortable)
+            | BufferEncoding,
+        callback: (err: NodeJS.ErrnoException | null, data: string) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | (ObjectEncodingOptions & {
+                flag?: string | undefined;
+            } & Abortable)
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, data: string | NonSharedBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
+    ): void;
+    export namespace readFile {
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options An object that may contain an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options?: {
+                encoding?: null | undefined;
+                flag?: string | undefined;
+            } | null,
+        ): Promise<NonSharedBuffer>;
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options:
+                | {
+                    encoding: BufferEncoding;
+                    flag?: string | undefined;
+                }
+                | BufferEncoding,
+        ): Promise<string>;
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options?:
+                | (ObjectEncodingOptions & {
+                    flag?: string | undefined;
+                })
+                | BufferEncoding
+                | null,
+        ): Promise<string | NonSharedBuffer>;
+    }
+    /**
+     * Returns the contents of the `path`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link readFile}.
+     *
+     * If the `encoding` option is specified then this function returns a
+     * string. Otherwise it returns a buffer.
+     *
+     * Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.
+     *
+     * ```js
+     * import { readFileSync } from 'node:fs';
+     *
+     * // macOS, Linux, and Windows
+     * readFileSync('<directory>');
+     * // => [Error: EISDIR: illegal operation on a directory, read <directory>]
+     *
+     * //  FreeBSD
+     * readFileSync('<directory>'); // => <data>
+     * ```
+     * @since v0.1.8
+     * @param path filename or file descriptor
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options?: {
+            encoding?: null | undefined;
+            flag?: string | undefined;
+        } | null,
+    ): NonSharedBuffer;
+    /**
+     * Synchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options:
+            | {
+                encoding: BufferEncoding;
+                flag?: string | undefined;
+            }
+            | BufferEncoding,
+    ): string;
+    /**
+     * Synchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options?:
+            | (ObjectEncodingOptions & {
+                flag?: string | undefined;
+            })
+            | BufferEncoding
+            | null,
+    ): string | NonSharedBuffer;
+    export type WriteFileOptions =
+        | (
+            & ObjectEncodingOptions
+            & Abortable
+            & {
+                mode?: Mode | undefined;
+                flag?: string | undefined;
+                flush?: boolean | undefined;
+            }
+        )
+        | BufferEncoding
+        | null;
+    /**
+     * When `file` is a filename, asynchronously writes data to the file, replacing the
+     * file if it already exists. `data` can be a string or a buffer.
+     *
+     * When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using
+     * a file descriptor.
+     *
+     * The `encoding` option is ignored if `data` is a buffer.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     * import { Buffer } from 'node:buffer';
+     *
+     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
+     * writeFile('message.txt', data, (err) => {
+     *   if (err) throw err;
+     *   console.log('The file has been saved!');
+     * });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     *
+     * writeFile('message.txt', 'Hello Node.js', 'utf8', callback);
+     * ```
+     *
+     * It is unsafe to use `fs.writeFile()` multiple times on the same file without
+     * waiting for the callback. For this scenario, {@link createWriteStream} is
+     * recommended.
+     *
+     * Similarly to `fs.readFile` \- `fs.writeFile` is a convenience method that
+     * performs multiple `write` calls internally to write the buffer passed to it.
+     * For performance sensitive code consider using {@link createWriteStream}.
+     *
+     * It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.
+     * Cancelation is "best effort", and some amount of data is likely still
+     * to be written.
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     * import { Buffer } from 'node:buffer';
+     *
+     * const controller = new AbortController();
+     * const { signal } = controller;
+     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
+     * writeFile('message.txt', data, { signal }, (err) => {
+     *   // When a request is aborted - the callback is called with an AbortError
+     * });
+     * // When the request should be aborted
+     * controller.abort();
+     * ```
+     *
+     * Aborting an ongoing request does not abort individual operating
+     * system requests but rather the internal buffering `fs.writeFile` performs.
+     * @since v0.1.29
+     * @param file filename or file descriptor
+     */
+    export function writeFile(
+        file: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        options: WriteFileOptions,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronously writes data to a file, replacing the file if it already exists.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+     */
+    export function writeFile(
+        path: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        callback: NoParamCallback,
+    ): void;
+    export namespace writeFile {
+        /**
+         * Asynchronously writes data to a file, replacing the file if it already exists.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
+         * If `encoding` is not supplied, the default of `'utf8'` is used.
+         * If `mode` is not supplied, the default of `0o666` is used.
+         * If `mode` is a string, it is parsed as an octal integer.
+         * If `flag` is not supplied, the default of `'w'` is used.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            data: string | NodeJS.ArrayBufferView,
+            options?: WriteFileOptions,
+        ): Promise<void>;
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link writeFile}.
+     * @since v0.1.29
+     * @param file filename or file descriptor
+     */
+    export function writeFileSync(
+        file: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        options?: WriteFileOptions,
+    ): void;
+    /**
+     * Asynchronously append data to a file, creating the file if it does not yet
+     * exist. `data` can be a string or a `Buffer`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { appendFile } from 'node:fs';
+     *
+     * appendFile('message.txt', 'data to append', (err) => {
+     *   if (err) throw err;
+     *   console.log('The "data to append" was appended to file!');
+     * });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { appendFile } from 'node:fs';
+     *
+     * appendFile('message.txt', 'data to append', 'utf8', callback);
+     * ```
+     *
+     * The `path` may be specified as a numeric file descriptor that has been opened
+     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
+     * not be closed automatically.
+     *
+     * ```js
+     * import { open, close, appendFile } from 'node:fs';
+     *
+     * function closeFd(fd) {
+     *   close(fd, (err) => {
+     *     if (err) throw err;
+     *   });
+     * }
+     *
+     * open('message.txt', 'a', (err, fd) => {
+     *   if (err) throw err;
+     *
+     *   try {
+     *     appendFile(fd, 'data to append', 'utf8', (err) => {
+     *       closeFd(fd);
+     *       if (err) throw err;
+     *     });
+     *   } catch (err) {
+     *     closeFd(fd);
+     *     throw err;
+     *   }
+     * });
+     * ```
+     * @since v0.6.7
+     * @param path filename or file descriptor
+     */
+    export function appendFile(
+        path: PathOrFileDescriptor,
+        data: string | Uint8Array,
+        options: WriteFileOptions,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronously append data to a file, creating the file if it does not exist.
+     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+     */
+    export function appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback): void;
+    export namespace appendFile {
+        /**
+         * Asynchronously append data to a file, creating the file if it does not exist.
+         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
+         * If `encoding` is not supplied, the default of `'utf8'` is used.
+         * If `mode` is not supplied, the default of `0o666` is used.
+         * If `mode` is a string, it is parsed as an octal integer.
+         * If `flag` is not supplied, the default of `'a'` is used.
+         */
+        function __promisify__(
+            file: PathOrFileDescriptor,
+            data: string | Uint8Array,
+            options?: WriteFileOptions,
+        ): Promise<void>;
+    }
+    /**
+     * Synchronously append data to a file, creating the file if it does not yet
+     * exist. `data` can be a string or a `Buffer`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { appendFileSync } from 'node:fs';
+     *
+     * try {
+     *   appendFileSync('message.txt', 'data to append');
+     *   console.log('The "data to append" was appended to file!');
+     * } catch (err) {
+     *   // Handle the error
+     * }
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { appendFileSync } from 'node:fs';
+     *
+     * appendFileSync('message.txt', 'data to append', 'utf8');
+     * ```
+     *
+     * The `path` may be specified as a numeric file descriptor that has been opened
+     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
+     * not be closed automatically.
+     *
+     * ```js
+     * import { openSync, closeSync, appendFileSync } from 'node:fs';
+     *
+     * let fd;
+     *
+     * try {
+     *   fd = openSync('message.txt', 'a');
+     *   appendFileSync(fd, 'data to append', 'utf8');
+     * } catch (err) {
+     *   // Handle the error
+     * } finally {
+     *   if (fd !== undefined)
+     *     closeSync(fd);
+     * }
+     * ```
+     * @since v0.6.7
+     * @param path filename or file descriptor
+     */
+    export function appendFileSync(
+        path: PathOrFileDescriptor,
+        data: string | Uint8Array,
+        options?: WriteFileOptions,
+    ): void;
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each
+     * time the file is accessed.
+     *
+     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
+     * whether the process should continue to run as long as files are being watched.
+     * The `options` object may specify an `interval` property indicating how often the
+     * target should be polled in milliseconds.
+     *
+     * The `listener` gets two arguments the current stat object and the previous
+     * stat object:
+     *
+     * ```js
+     * import { watchFile } from 'node:fs';
+     *
+     * watchFile('message.text', (curr, prev) => {
+     *   console.log(`the current mtime is: ${curr.mtime}`);
+     *   console.log(`the previous mtime was: ${prev.mtime}`);
+     * });
+     * ```
+     *
+     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
+     * the numeric values in these objects are specified as `BigInt`s.
+     *
+     * To be notified when the file was modified, not just accessed, it is necessary
+     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
+     *
+     * When an `fs.watchFile` operation results in an `ENOENT` error, it
+     * will invoke the listener once, with all the fields zeroed (or, for dates, the
+     * Unix Epoch). If the file is created later on, the listener will be called
+     * again, with the latest stat objects. This is a change in functionality since
+     * v0.10.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
+     *
+     * When a file being watched by `fs.watchFile()` disappears and reappears,
+     * then the contents of `previous` in the second callback event (the file's
+     * reappearance) will be the same as the contents of `previous` in the first
+     * callback event (its disappearance).
+     *
+     * This happens when:
+     *
+     * * the file is deleted, followed by a restore
+     * * the file is renamed and then renamed a second time back to its original name
+     * @since v0.1.31
+     */
+    export interface WatchFileOptions {
+        bigint?: boolean | undefined;
+        persistent?: boolean | undefined;
+        interval?: number | undefined;
+    }
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each
+     * time the file is accessed.
+     *
+     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
+     * whether the process should continue to run as long as files are being watched.
+     * The `options` object may specify an `interval` property indicating how often the
+     * target should be polled in milliseconds.
+     *
+     * The `listener` gets two arguments the current stat object and the previous
+     * stat object:
+     *
+     * ```js
+     * import { watchFile } from 'node:fs';
+     *
+     * watchFile('message.text', (curr, prev) => {
+     *   console.log(`the current mtime is: ${curr.mtime}`);
+     *   console.log(`the previous mtime was: ${prev.mtime}`);
+     * });
+     * ```
+     *
+     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
+     * the numeric values in these objects are specified as `BigInt`s.
+     *
+     * To be notified when the file was modified, not just accessed, it is necessary
+     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
+     *
+     * When an `fs.watchFile` operation results in an `ENOENT` error, it
+     * will invoke the listener once, with all the fields zeroed (or, for dates, the
+     * Unix Epoch). If the file is created later on, the listener will be called
+     * again, with the latest stat objects. This is a change in functionality since
+     * v0.10.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
+     *
+     * When a file being watched by `fs.watchFile()` disappears and reappears,
+     * then the contents of `previous` in the second callback event (the file's
+     * reappearance) will be the same as the contents of `previous` in the first
+     * callback event (its disappearance).
+     *
+     * This happens when:
+     *
+     * * the file is deleted, followed by a restore
+     * * the file is renamed and then renamed a second time back to its original name
+     * @since v0.1.31
+     */
+    export function watchFile(
+        filename: PathLike,
+        options:
+            | (WatchFileOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        listener: StatsListener,
+    ): StatWatcher;
+    export function watchFile(
+        filename: PathLike,
+        options:
+            | (WatchFileOptions & {
+                bigint: true;
+            })
+            | undefined,
+        listener: BigIntStatsListener,
+    ): StatWatcher;
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function watchFile(filename: PathLike, listener: StatsListener): StatWatcher;
+    /**
+     * Stop watching for changes on `filename`. If `listener` is specified, only that
+     * particular listener is removed. Otherwise, _all_ listeners are removed,
+     * effectively stopping watching of `filename`.
+     *
+     * Calling `fs.unwatchFile()` with a filename that is not being watched is a
+     * no-op, not an error.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.
+     * @since v0.1.31
+     * @param listener Optional, a listener previously attached using `fs.watchFile()`
+     */
+    export function unwatchFile(filename: PathLike, listener?: StatsListener): void;
+    export function unwatchFile(filename: PathLike, listener?: BigIntStatsListener): void;
+    export interface WatchOptions extends Abortable {
+        encoding?: BufferEncoding | "buffer" | undefined;
+        persistent?: boolean | undefined;
+        recursive?: boolean | undefined;
+    }
+    export type WatchEventType = "rename" | "change";
+    export type WatchListener<T> = (event: WatchEventType, filename: T | null) => void;
+    export type StatsListener = (curr: Stats, prev: Stats) => void;
+    export type BigIntStatsListener = (curr: BigIntStats, prev: BigIntStats) => void;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a
+     * directory.
+     *
+     * The second argument is optional. If `options` is provided as a string, it
+     * specifies the `encoding`. Otherwise `options` should be passed as an object.
+     *
+     * The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file
+     * which triggered the event.
+     *
+     * On most platforms, `'rename'` is emitted whenever a filename appears or
+     * disappears in the directory.
+     *
+     * The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.
+     *
+     * If a `signal` is passed, aborting the corresponding AbortController will close
+     * the returned `fs.FSWatcher`.
+     * @since v0.5.10
+     * @param listener
+     */
+    export function watch(
+        filename: PathLike,
+        options:
+            | (WatchOptions & {
+                encoding: "buffer";
+            })
+            | "buffer",
+        listener?: WatchListener<Buffer>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
+     * If `encoding` is not supplied, the default of `'utf8'` is used.
+     * If `persistent` is not supplied, the default of `true` is used.
+     * If `recursive` is not supplied, the default of `false` is used.
+     */
+    export function watch(
+        filename: PathLike,
+        options?: WatchOptions | BufferEncoding | null,
+        listener?: WatchListener<string>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
+     * If `encoding` is not supplied, the default of `'utf8'` is used.
+     * If `persistent` is not supplied, the default of `true` is used.
+     * If `recursive` is not supplied, the default of `false` is used.
+     */
+    export function watch(
+        filename: PathLike,
+        options: WatchOptions | string,
+        listener?: WatchListener<string | Buffer>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function watch(filename: PathLike, listener?: WatchListener<string>): FSWatcher;
+    /**
+     * Test whether or not the given path exists by checking with the file system.
+     * Then call the `callback` argument with either true or false:
+     *
+     * ```js
+     * import { exists } from 'node:fs';
+     *
+     * exists('/etc/passwd', (e) => {
+     *   console.log(e ? 'it exists' : 'no passwd!');
+     * });
+     * ```
+     *
+     * **The parameters for this callback are not consistent with other Node.js**
+     * **callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback
+     * has only one boolean parameter. This is one reason `fs.access()` is recommended
+     * instead of `fs.exists()`.
+     *
+     * Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing
+     * so introduces a race condition, since other processes may change the file's
+     * state between the two calls. Instead, user code should open/read/write the
+     * file directly and handle the error raised if the file does not exist.
+     *
+     * **write (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { exists, open, close } from 'node:fs';
+     *
+     * exists('myfile', (e) => {
+     *   if (e) {
+     *     console.error('myfile already exists');
+     *   } else {
+     *     open('myfile', 'wx', (err, fd) => {
+     *       if (err) throw err;
+     *
+     *       try {
+     *         writeMyData(fd);
+     *       } finally {
+     *         close(fd, (err) => {
+     *           if (err) throw err;
+     *         });
+     *       }
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **write (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     * open('myfile', 'wx', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'EEXIST') {
+     *       console.error('myfile already exists');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     writeMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **read (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close, exists } from 'node:fs';
+     *
+     * exists('myfile', (e) => {
+     *   if (e) {
+     *     open('myfile', 'r', (err, fd) => {
+     *       if (err) throw err;
+     *
+     *       try {
+     *         readMyData(fd);
+     *       } finally {
+     *         close(fd, (err) => {
+     *           if (err) throw err;
+     *         });
+     *       }
+     *     });
+     *   } else {
+     *     console.error('myfile does not exist');
+     *   }
+     * });
+     * ```
+     *
+     * **read (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'r', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     readMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * The "not recommended" examples above check for existence and then use the
+     * file; the "recommended" examples are better because they use the file directly
+     * and handle the error, if any.
+     *
+     * In general, check for the existence of a file only if the file won't be
+     * used directly, for example when its existence is a signal from another
+     * process.
+     * @since v0.0.2
+     * @deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.
+     */
+    export function exists(path: PathLike, callback: (exists: boolean) => void): void;
+    /** @deprecated */
+    export namespace exists {
+        /**
+         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(path: PathLike): Promise<boolean>;
+    }
+    /**
+     * Returns `true` if the path exists, `false` otherwise.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link exists}.
+     *
+     * `fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other
+     * Node.js callbacks. `fs.existsSync()` does not use a callback.
+     *
+     * ```js
+     * import { existsSync } from 'node:fs';
+     *
+     * if (existsSync('/etc/passwd'))
+     *   console.log('The path exists.');
+     * ```
+     * @since v0.1.21
+     */
+    export function existsSync(path: PathLike): boolean;
+    export namespace constants {
+        // File Access Constants
+        /** Constant for fs.access(). File is visible to the calling process. */
+        const F_OK: number;
+        /** Constant for fs.access(). File can be read by the calling process. */
+        const R_OK: number;
+        /** Constant for fs.access(). File can be written by the calling process. */
+        const W_OK: number;
+        /** Constant for fs.access(). File can be executed by the calling process. */
+        const X_OK: number;
+        // File Copy Constants
+        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
+        const COPYFILE_EXCL: number;
+        /**
+         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
+         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
+         */
+        const COPYFILE_FICLONE: number;
+        /**
+         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
+         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
+         */
+        const COPYFILE_FICLONE_FORCE: number;
+        // File Open Constants
+        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
+        const O_RDONLY: number;
+        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
+        const O_WRONLY: number;
+        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
+        const O_RDWR: number;
+        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
+        const O_CREAT: number;
+        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
+        const O_EXCL: number;
+        /**
+         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
+         * opening the path shall not cause that terminal to become the controlling terminal for the process
+         * (if the process does not already have one).
+         */
+        const O_NOCTTY: number;
+        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
+        const O_TRUNC: number;
+        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
+        const O_APPEND: number;
+        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
+        const O_DIRECTORY: number;
+        /**
+         * constant for fs.open().
+         * Flag indicating reading accesses to the file system will no longer result in
+         * an update to the atime information associated with the file.
+         * This flag is available on Linux operating systems only.
+         */
+        const O_NOATIME: number;
+        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
+        const O_NOFOLLOW: number;
+        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
+        const O_SYNC: number;
+        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
+        const O_DSYNC: number;
+        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
+        const O_SYMLINK: number;
+        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
+        const O_DIRECT: number;
+        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
+        const O_NONBLOCK: number;
+        // File Type Constants
+        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
+        const S_IFMT: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
+        const S_IFREG: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
+        const S_IFDIR: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
+        const S_IFCHR: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
+        const S_IFBLK: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
+        const S_IFIFO: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
+        const S_IFLNK: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
+        const S_IFSOCK: number;
+        // File Mode Constants
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
+        const S_IRWXU: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
+        const S_IRUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
+        const S_IWUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
+        const S_IXUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
+        const S_IRWXG: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
+        const S_IRGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
+        const S_IWGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
+        const S_IXGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
+        const S_IRWXO: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
+        const S_IROTH: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
+        const S_IWOTH: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
+        const S_IXOTH: number;
+        /**
+         * When set, a memory file mapping is used to access the file. This flag
+         * is available on Windows operating systems only. On other operating systems,
+         * this flag is ignored.
+         */
+        const UV_FS_O_FILEMAP: number;
+    }
+    /**
+     * Tests a user's permissions for the file or directory specified by `path`.
+     * The `mode` argument is an optional integer that specifies the accessibility
+     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
+     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
+     * possible values of `mode`.
+     *
+     * The final argument, `callback`, is a callback function that is invoked with
+     * a possible error argument. If any of the accessibility checks fail, the error
+     * argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.
+     *
+     * ```js
+     * import { access, constants } from 'node:fs';
+     *
+     * const file = 'package.json';
+     *
+     * // Check if the file exists in the current directory.
+     * access(file, constants.F_OK, (err) => {
+     *   console.log(`${file} ${err ? 'does not exist' : 'exists'}`);
+     * });
+     *
+     * // Check if the file is readable.
+     * access(file, constants.R_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);
+     * });
+     *
+     * // Check if the file is writable.
+     * access(file, constants.W_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);
+     * });
+     *
+     * // Check if the file is readable and writable.
+     * access(file, constants.R_OK | constants.W_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);
+     * });
+     * ```
+     *
+     * Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing
+     * so introduces a race condition, since other processes may change the file's
+     * state between the two calls. Instead, user code should open/read/write the
+     * file directly and handle the error raised if the file is not accessible.
+     *
+     * **write (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { access, open, close } from 'node:fs';
+     *
+     * access('myfile', (err) => {
+     *   if (!err) {
+     *     console.error('myfile already exists');
+     *     return;
+     *   }
+     *
+     *   open('myfile', 'wx', (err, fd) => {
+     *     if (err) throw err;
+     *
+     *     try {
+     *       writeMyData(fd);
+     *     } finally {
+     *       close(fd, (err) => {
+     *         if (err) throw err;
+     *       });
+     *     }
+     *   });
+     * });
+     * ```
+     *
+     * **write (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'wx', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'EEXIST') {
+     *       console.error('myfile already exists');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     writeMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **read (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { access, open, close } from 'node:fs';
+     * access('myfile', (err) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   open('myfile', 'r', (err, fd) => {
+     *     if (err) throw err;
+     *
+     *     try {
+     *       readMyData(fd);
+     *     } finally {
+     *       close(fd, (err) => {
+     *         if (err) throw err;
+     *       });
+     *     }
+     *   });
+     * });
+     * ```
+     *
+     * **read (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'r', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     readMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * The "not recommended" examples above check for accessibility and then use the
+     * file; the "recommended" examples are better because they use the file directly
+     * and handle the error, if any.
+     *
+     * In general, check for the accessibility of a file only if the file will not be
+     * used directly, for example when its accessibility is a signal from another
+     * process.
+     *
+     * On Windows, access-control policies (ACLs) on a directory may limit access to
+     * a file or directory. The `fs.access()` function, however, does not check the
+     * ACL and therefore may report that a path is accessible even if the ACL restricts
+     * the user from reading or writing to it.
+     * @since v0.11.15
+     * @param [mode=fs.constants.F_OK]
+     */
+    export function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronously tests a user's permissions for the file specified by path.
+     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function access(path: PathLike, callback: NoParamCallback): void;
+    export namespace access {
+        /**
+         * Asynchronously tests a user's permissions for the file specified by path.
+         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(path: PathLike, mode?: number): Promise<void>;
+    }
+    /**
+     * Synchronously tests a user's permissions for the file or directory specified
+     * by `path`. The `mode` argument is an optional integer that specifies the
+     * accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and
+     * `fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
+     * possible values of `mode`.
+     *
+     * If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,
+     * the method will return `undefined`.
+     *
+     * ```js
+     * import { accessSync, constants } from 'node:fs';
+     *
+     * try {
+     *   accessSync('etc/passwd', constants.R_OK | constants.W_OK);
+     *   console.log('can read/write');
+     * } catch (err) {
+     *   console.error('no access!');
+     * }
+     * ```
+     * @since v0.11.15
+     * @param [mode=fs.constants.F_OK]
+     */
+    export function accessSync(path: PathLike, mode?: number): void;
+    interface StreamOptions {
+        flags?: string | undefined;
+        encoding?: BufferEncoding | undefined;
+        fd?: number | promises.FileHandle | undefined;
+        mode?: number | undefined;
+        autoClose?: boolean | undefined;
+        emitClose?: boolean | undefined;
+        start?: number | undefined;
+        signal?: AbortSignal | null | undefined;
+        highWaterMark?: number | undefined;
+    }
+    interface FSImplementation {
+        open?: (...args: any[]) => any;
+        close?: (...args: any[]) => any;
+    }
+    interface CreateReadStreamFSImplementation extends FSImplementation {
+        read: (...args: any[]) => any;
+    }
+    interface CreateWriteStreamFSImplementation extends FSImplementation {
+        write: (...args: any[]) => any;
+        writev?: (...args: any[]) => any;
+    }
+    interface ReadStreamOptions extends StreamOptions {
+        fs?: CreateReadStreamFSImplementation | null | undefined;
+        end?: number | undefined;
+    }
+    interface WriteStreamOptions extends StreamOptions {
+        fs?: CreateWriteStreamFSImplementation | null | undefined;
+        flush?: boolean | undefined;
+    }
+    /**
+     * `options` can include `start` and `end` values to read a range of bytes from
+     * the file instead of the entire file. Both `start` and `end` are inclusive and
+     * start counting at 0, allowed values are in the
+     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `fd` is specified and `start` is
+     * omitted or `undefined`, `fs.createReadStream()` reads sequentially from the
+     * current file position. The `encoding` can be any one of those accepted by `Buffer`.
+     *
+     * If `fd` is specified, `ReadStream` will ignore the `path` argument and will use
+     * the specified file descriptor. This means that no `'open'` event will be
+     * emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.
+     *
+     * If `fd` points to a character device that only supports blocking reads
+     * (such as keyboard or sound card), read operations do not finish until data is
+     * available. This can prevent the process from exiting and the stream from
+     * closing naturally.
+     *
+     * By default, the stream will emit a `'close'` event after it has been
+     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
+     *
+     * By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,
+     * an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is
+     * also required.
+     *
+     * ```js
+     * import { createReadStream } from 'node:fs';
+     *
+     * // Create a stream from some character device.
+     * const stream = createReadStream('/dev/input/event0');
+     * setTimeout(() => {
+     *   stream.close(); // This may not close the stream.
+     *   // Artificially marking end-of-stream, as if the underlying resource had
+     *   // indicated end-of-file by itself, allows the stream to close.
+     *   // This does not cancel pending read operations, and if there is such an
+     *   // operation, the process may still not be able to exit successfully
+     *   // until it finishes.
+     *   stream.push(null);
+     *   stream.read(0);
+     * }, 100);
+     * ```
+     *
+     * If `autoClose` is false, then the file descriptor won't be closed, even if
+     * there's an error. It is the application's responsibility to close it and make
+     * sure there's no file descriptor leak. If `autoClose` is set to true (default
+     * behavior), on `'error'` or `'end'` the file descriptor will be closed
+     * automatically.
+     *
+     * `mode` sets the file mode (permission and sticky bits), but only if the
+     * file was created.
+     *
+     * An example to read the last 10 bytes of a file which is 100 bytes long:
+     *
+     * ```js
+     * import { createReadStream } from 'node:fs';
+     *
+     * createReadStream('sample.txt', { start: 90, end: 99 });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding.
+     * @since v0.1.31
+     */
+    export function createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions): ReadStream;
+    /**
+     * `options` may also include a `start` option to allow writing data at some
+     * position past the beginning of the file, allowed values are in the
+     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
+     * replacing it may require the `flags` option to be set to `r+` rather than the
+     * default `w`. The `encoding` can be any one of those accepted by `Buffer`.
+     *
+     * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
+     * then the file descriptor won't be closed, even if there's an error.
+     * It is the application's responsibility to close it and make sure there's no
+     * file descriptor leak.
+     *
+     * By default, the stream will emit a `'close'` event after it has been
+     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
+     *
+     * By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce
+     * performance as some optimizations (`_writev()`)
+     * will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override
+     * for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.
+     *
+     * Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be
+     * emitted. `fd` should be blocking; non-blocking `fd`s
+     * should be passed to `net.Socket`.
+     *
+     * If `options` is a string, then it specifies the encoding.
+     * @since v0.1.31
+     */
+    export function createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions): WriteStream;
+    /**
+     * Forces all currently queued I/O operations associated with the file to the
+     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other
+     * than a possible
+     * exception are given to the completion callback.
+     * @since v0.1.96
+     */
+    export function fdatasync(fd: number, callback: NoParamCallback): void;
+    export namespace fdatasync {
+        /**
+         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Forces all currently queued I/O operations associated with the file to the
+     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
+     * @since v0.1.96
+     */
+    export function fdatasyncSync(fd: number): void;
+    /**
+     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
+     * already exists. No arguments other than a possible exception are given to the
+     * callback function. Node.js makes no guarantees about the atomicity of the copy
+     * operation. If an error occurs after the destination file has been opened for
+     * writing, Node.js will attempt to remove the destination.
+     *
+     * `mode` is an optional integer that specifies the behavior
+     * of the copy operation. It is possible to create a mask consisting of the bitwise
+     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
+     *
+     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
+     * exists.
+     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
+     * copy-on-write reflink. If the platform does not support copy-on-write, then a
+     * fallback copy mechanism is used.
+     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
+     * create a copy-on-write reflink. If the platform does not support
+     * copy-on-write, then the operation will fail.
+     *
+     * ```js
+     * import { copyFile, constants } from 'node:fs';
+     *
+     * function callback(err) {
+     *   if (err) throw err;
+     *   console.log('source.txt was copied to destination.txt');
+     * }
+     *
+     * // destination.txt will be created or overwritten by default.
+     * copyFile('source.txt', 'destination.txt', callback);
+     *
+     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
+     * copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);
+     * ```
+     * @since v8.5.0
+     * @param src source filename to copy
+     * @param dest destination filename of the copy operation
+     * @param [mode=0] modifiers for copy operation.
+     */
+    export function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;
+    export function copyFile(src: PathLike, dest: PathLike, mode: number, callback: NoParamCallback): void;
+    export namespace copyFile {
+        function __promisify__(src: PathLike, dst: PathLike, mode?: number): Promise<void>;
+    }
+    /**
+     * Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it
+     * already exists. Returns `undefined`. Node.js makes no guarantees about the
+     * atomicity of the copy operation. If an error occurs after the destination file
+     * has been opened for writing, Node.js will attempt to remove the destination.
+     *
+     * `mode` is an optional integer that specifies the behavior
+     * of the copy operation. It is possible to create a mask consisting of the bitwise
+     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
+     *
+     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
+     * exists.
+     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
+     * copy-on-write reflink. If the platform does not support copy-on-write, then a
+     * fallback copy mechanism is used.
+     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
+     * create a copy-on-write reflink. If the platform does not support
+     * copy-on-write, then the operation will fail.
+     *
+     * ```js
+     * import { copyFileSync, constants } from 'node:fs';
+     *
+     * // destination.txt will be created or overwritten by default.
+     * copyFileSync('source.txt', 'destination.txt');
+     * console.log('source.txt was copied to destination.txt');
+     *
+     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
+     * copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
+     * ```
+     * @since v8.5.0
+     * @param src source filename to copy
+     * @param dest destination filename of the copy operation
+     * @param [mode=0] modifiers for copy operation.
+     */
+    export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
+    /**
+     * Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.
+     *
+     * `position` is the offset from the beginning of the file where this data
+     * should be written. If `typeof position !== 'number'`, the data will be written
+     * at the current position.
+     *
+     * The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.
+     *
+     * If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.
+     *
+     * It is unsafe to use `fs.writev()` multiple times on the same file without
+     * waiting for the callback. For this scenario, use {@link createWriteStream}.
+     *
+     * On Linux, positional writes don't work when the file is opened in append mode.
+     * The kernel ignores the position argument and always appends the data to
+     * the end of the file.
+     * @since v12.9.0
+     * @param [position='null']
+     */
+    export function writev(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export function writev(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        position: number | null,
+        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export interface WriteVResult {
+        bytesWritten: number;
+        buffers: NodeJS.ArrayBufferView[];
+    }
+    export namespace writev {
+        function __promisify__(
+            fd: number,
+            buffers: readonly NodeJS.ArrayBufferView[],
+            position?: number,
+        ): Promise<WriteVResult>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link writev}.
+     * @since v12.9.0
+     * @param [position='null']
+     * @return The number of bytes written.
+     */
+    export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
+    /**
+     * Read from a file specified by `fd` and write to an array of `ArrayBufferView`s
+     * using `readv()`.
+     *
+     * `position` is the offset from the beginning of the file from where data
+     * should be read. If `typeof position !== 'number'`, the data will be read
+     * from the current position.
+     *
+     * The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesRead` and `buffers` properties.
+     * @since v13.13.0, v12.17.0
+     * @param [position='null']
+     */
+    export function readv(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export function readv(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        position: number | null,
+        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export interface ReadVResult {
+        bytesRead: number;
+        buffers: NodeJS.ArrayBufferView[];
+    }
+    export namespace readv {
+        function __promisify__(
+            fd: number,
+            buffers: readonly NodeJS.ArrayBufferView[],
+            position?: number,
+        ): Promise<ReadVResult>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link readv}.
+     * @since v13.13.0, v12.17.0
+     * @param [position='null']
+     * @return The number of bytes read.
+     */
+    export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
+
+    export interface OpenAsBlobOptions {
+        /**
+         * An optional mime type for the blob.
+         *
+         * @default 'undefined'
+         */
+        type?: string | undefined;
+    }
+
+    /**
+     * Returns a `Blob` whose data is backed by the given file.
+     *
+     * The file must not be modified after the `Blob` is created. Any modifications
+     * will cause reading the `Blob` data to fail with a `DOMException` error.
+     * Synchronous stat operations on the file when the `Blob` is created, and before
+     * each read in order to detect whether the file data has been modified on disk.
+     *
+     * ```js
+     * import { openAsBlob } from 'node:fs';
+     *
+     * const blob = await openAsBlob('the.file.txt');
+     * const ab = await blob.arrayBuffer();
+     * blob.stream();
+     * ```
+     * @since v19.8.0
+     */
+    export function openAsBlob(path: PathLike, options?: OpenAsBlobOptions): Promise<Blob>;
+
+    export interface OpenDirOptions {
+        /**
+         * @default 'utf8'
+         */
+        encoding?: BufferEncoding | undefined;
+        /**
+         * Number of directory entries that are buffered
+         * internally when reading from the directory. Higher values lead to better
+         * performance but higher memory usage.
+         * @default 32
+         */
+        bufferSize?: number | undefined;
+        /**
+         * @default false
+         */
+        recursive?: boolean;
+    }
+    /**
+     * Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).
+     *
+     * Creates an `fs.Dir`, which contains all further functions for reading from
+     * and cleaning up the directory.
+     *
+     * The `encoding` option sets the encoding for the `path` while opening the
+     * directory and subsequent read operations.
+     * @since v12.12.0
+     */
+    export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
+    /**
+     * Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for
+     * more details.
+     *
+     * Creates an `fs.Dir`, which contains all further functions for reading from
+     * and cleaning up the directory.
+     *
+     * The `encoding` option sets the encoding for the `path` while opening the
+     * directory and subsequent read operations.
+     * @since v12.12.0
+     */
+    export function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;
+    export function opendir(
+        path: PathLike,
+        options: OpenDirOptions,
+        cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void,
+    ): void;
+    export namespace opendir {
+        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
+    }
+    export interface BigIntStats extends StatsBase<bigint> {
+        atimeNs: bigint;
+        mtimeNs: bigint;
+        ctimeNs: bigint;
+        birthtimeNs: bigint;
+    }
+    export interface BigIntOptions {
+        bigint: true;
+    }
+    export interface StatOptions {
+        bigint?: boolean | undefined;
+    }
+    export interface StatSyncOptions extends StatOptions {
+        throwIfNoEntry?: boolean | undefined;
+    }
+    interface CopyOptionsBase {
+        /**
+         * Dereference symlinks
+         * @default false
+         */
+        dereference?: boolean;
+        /**
+         * When `force` is `false`, and the destination
+         * exists, throw an error.
+         * @default false
+         */
+        errorOnExist?: boolean;
+        /**
+         * Overwrite existing file or directory. _The copy
+         * operation will ignore errors if you set this to false and the destination
+         * exists. Use the `errorOnExist` option to change this behavior.
+         * @default true
+         */
+        force?: boolean;
+        /**
+         * Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}
+         */
+        mode?: number;
+        /**
+         * When `true` timestamps from `src` will
+         * be preserved.
+         * @default false
+         */
+        preserveTimestamps?: boolean;
+        /**
+         * Copy directories recursively.
+         * @default false
+         */
+        recursive?: boolean;
+        /**
+         * When true, path resolution for symlinks will be skipped
+         * @default false
+         */
+        verbatimSymlinks?: boolean;
+    }
+    export interface CopyOptions extends CopyOptionsBase {
+        /**
+         * Function to filter copied files/directories. Return
+         * `true` to copy the item, `false` to ignore it.
+         */
+        filter?(source: string, destination: string): boolean | Promise<boolean>;
+    }
+    export interface CopySyncOptions extends CopyOptionsBase {
+        /**
+         * Function to filter copied files/directories. Return
+         * `true` to copy the item, `false` to ignore it.
+         */
+        filter?(source: string, destination: string): boolean;
+    }
+    /**
+     * Asynchronously copies the entire directory structure from `src` to `dest`,
+     * including subdirectories and files.
+     *
+     * When copying a directory to another directory, globs are not supported and
+     * behavior is similar to `cp dir1/ dir2/`.
+     * @since v16.7.0
+     * @experimental
+     * @param src source path to copy.
+     * @param dest destination path to copy to.
+     */
+    export function cp(
+        source: string | URL,
+        destination: string | URL,
+        callback: (err: NodeJS.ErrnoException | null) => void,
+    ): void;
+    export function cp(
+        source: string | URL,
+        destination: string | URL,
+        opts: CopyOptions,
+        callback: (err: NodeJS.ErrnoException | null) => void,
+    ): void;
+    /**
+     * Synchronously copies the entire directory structure from `src` to `dest`,
+     * including subdirectories and files.
+     *
+     * When copying a directory to another directory, globs are not supported and
+     * behavior is similar to `cp dir1/ dir2/`.
+     * @since v16.7.0
+     * @experimental
+     * @param src source path to copy.
+     * @param dest destination path to copy to.
+     */
+    export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;
+
+    interface _GlobOptions<T extends Dirent | string> {
+        /**
+         * Current working directory.
+         * @default process.cwd()
+         */
+        cwd?: string | undefined;
+        /**
+         * `true` if the glob should return paths as `Dirent`s, `false` otherwise.
+         * @default false
+         * @since v22.2.0
+         */
+        withFileTypes?: boolean | undefined;
+        /**
+         * Function to filter out files/directories or a
+         * list of glob patterns to be excluded. If a function is provided, return
+         * `true` to exclude the item, `false` to include it.
+         * @default undefined
+         */
+        exclude?: ((fileName: T) => boolean) | readonly string[] | undefined;
+    }
+    export interface GlobOptions extends _GlobOptions<Dirent | string> {}
+    export interface GlobOptionsWithFileTypes extends _GlobOptions<Dirent> {
+        withFileTypes: true;
+    }
+    export interface GlobOptionsWithoutFileTypes extends _GlobOptions<string> {
+        withFileTypes?: false | undefined;
+    }
+
+    /**
+     * Retrieves the files matching the specified pattern.
+     *
+     * ```js
+     * import { glob } from 'node:fs';
+     *
+     * glob('*.js', (err, matches) => {
+     *   if (err) throw err;
+     *   console.log(matches);
+     * });
+     * ```
+     * @since v22.0.0
+     */
+    export function glob(
+        pattern: string | readonly string[],
+        callback: (err: NodeJS.ErrnoException | null, matches: string[]) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithFileTypes,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: Dirent[],
+        ) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithoutFileTypes,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: string[],
+        ) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptions,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: Dirent[] | string[],
+        ) => void,
+    ): void;
+    /**
+     * ```js
+     * import { globSync } from 'node:fs';
+     *
+     * console.log(globSync('*.js'));
+     * ```
+     * @since v22.0.0
+     * @returns paths of files that match the pattern.
+     */
+    export function globSync(pattern: string | readonly string[]): string[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithFileTypes,
+    ): Dirent[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithoutFileTypes,
+    ): string[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptions,
+    ): Dirent[] | string[];
+}
+declare module "node:fs" {
+    export * from "fs";
+}
diff -ruN .cache/node/fs.d.ts.rej types/node/fs.d.ts.rej
--- .cache/node/fs.d.ts.rej	1970-01-01 00:00:00.000000000 +0000
+++ types/node/fs.d.ts.rej	2025-06-26 21:45:45.736225811 +0000
@@ -0,0 +1,8 @@
+@@ -4411,6 +4464,7 @@
+     ): void;
+     /**
+      * Retrieves the files matching the specified pattern.
++     * @throws {NodeJS.ErrnoException} When file system operations fail (e.g., permission denied, invalid pattern, path not found)
+      */
+     export function globSync(pattern: string | string[]): string[];
+     export function globSync(
diff -ruN .cache/node/globals.d.ts types/node/globals.d.ts
--- .cache/node/globals.d.ts	2025-06-26 21:45:46.983210618 +0000
+++ types/node/globals.d.ts	2025-06-26 21:45:45.736225811 +0000
@@ -310,6 +310,16 @@
     // #region fetch
     interface RequestInit extends _RequestInit {}
 
+    /**
+     * @throws {Promise<DOMException>} AbortError if the request is aborted.
+     */
+    function fetch(
+        input: string | URL | globalThis.Request,
+        init: { signal: AbortSignal } & RequestInit,
+    ): Promise<Response>;
+    /**
+     * https://nodejs.org/docs/latest/api/globals.html#fetch
+     */
     function fetch(
         input: string | URL | globalThis.Request,
         init?: RequestInit,
diff -ruN .cache/node/globals.d.ts.orig types/node/globals.d.ts.orig
--- .cache/node/globals.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/globals.d.ts.orig	2025-06-26 21:45:45.737225799 +0000
@@ -0,0 +1,367 @@
+export {}; // Make this a module
+
+// #region Fetch and friends
+// Conditional type aliases, used at the end of this file.
+// Will either be empty if lib.dom (or lib.webworker) is included, or the undici version otherwise.
+type _Request = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Request;
+type _Response = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Response;
+type _FormData = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").FormData;
+type _Headers = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").Headers;
+type _MessageEvent = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").MessageEvent;
+type _RequestInit = typeof globalThis extends { onmessage: any } ? {}
+    : import("undici-types").RequestInit;
+type _ResponseInit = typeof globalThis extends { onmessage: any } ? {}
+    : import("undici-types").ResponseInit;
+type _WebSocket = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").WebSocket;
+type _EventSource = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").EventSource;
+type _CloseEvent = typeof globalThis extends { onmessage: any } ? {} : import("undici-types").CloseEvent;
+// #endregion Fetch and friends
+
+// Conditional type definitions for webstorage interface, which conflicts with lib.dom otherwise.
+type _Storage = typeof globalThis extends { onabort: any } ? {} : {
+    readonly length: number;
+    clear(): void;
+    getItem(key: string): string | null;
+    key(index: number): string | null;
+    removeItem(key: string): void;
+    setItem(key: string, value: string): void;
+    [key: string]: any;
+};
+
+// #region DOMException
+type _DOMException = typeof globalThis extends { onmessage: any } ? {} : NodeDOMException;
+interface NodeDOMException extends Error {
+    readonly code: number;
+    readonly message: string;
+    readonly name: string;
+    readonly INDEX_SIZE_ERR: 1;
+    readonly DOMSTRING_SIZE_ERR: 2;
+    readonly HIERARCHY_REQUEST_ERR: 3;
+    readonly WRONG_DOCUMENT_ERR: 4;
+    readonly INVALID_CHARACTER_ERR: 5;
+    readonly NO_DATA_ALLOWED_ERR: 6;
+    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
+    readonly NOT_FOUND_ERR: 8;
+    readonly NOT_SUPPORTED_ERR: 9;
+    readonly INUSE_ATTRIBUTE_ERR: 10;
+    readonly INVALID_STATE_ERR: 11;
+    readonly SYNTAX_ERR: 12;
+    readonly INVALID_MODIFICATION_ERR: 13;
+    readonly NAMESPACE_ERR: 14;
+    readonly INVALID_ACCESS_ERR: 15;
+    readonly VALIDATION_ERR: 16;
+    readonly TYPE_MISMATCH_ERR: 17;
+    readonly SECURITY_ERR: 18;
+    readonly NETWORK_ERR: 19;
+    readonly ABORT_ERR: 20;
+    readonly URL_MISMATCH_ERR: 21;
+    readonly QUOTA_EXCEEDED_ERR: 22;
+    readonly TIMEOUT_ERR: 23;
+    readonly INVALID_NODE_TYPE_ERR: 24;
+    readonly DATA_CLONE_ERR: 25;
+}
+interface NodeDOMExceptionConstructor {
+    prototype: DOMException;
+    new(message?: string, nameOrOptions?: string | { name?: string; cause?: unknown }): DOMException;
+    readonly INDEX_SIZE_ERR: 1;
+    readonly DOMSTRING_SIZE_ERR: 2;
+    readonly HIERARCHY_REQUEST_ERR: 3;
+    readonly WRONG_DOCUMENT_ERR: 4;
+    readonly INVALID_CHARACTER_ERR: 5;
+    readonly NO_DATA_ALLOWED_ERR: 6;
+    readonly NO_MODIFICATION_ALLOWED_ERR: 7;
+    readonly NOT_FOUND_ERR: 8;
+    readonly NOT_SUPPORTED_ERR: 9;
+    readonly INUSE_ATTRIBUTE_ERR: 10;
+    readonly INVALID_STATE_ERR: 11;
+    readonly SYNTAX_ERR: 12;
+    readonly INVALID_MODIFICATION_ERR: 13;
+    readonly NAMESPACE_ERR: 14;
+    readonly INVALID_ACCESS_ERR: 15;
+    readonly VALIDATION_ERR: 16;
+    readonly TYPE_MISMATCH_ERR: 17;
+    readonly SECURITY_ERR: 18;
+    readonly NETWORK_ERR: 19;
+    readonly ABORT_ERR: 20;
+    readonly URL_MISMATCH_ERR: 21;
+    readonly QUOTA_EXCEEDED_ERR: 22;
+    readonly TIMEOUT_ERR: 23;
+    readonly INVALID_NODE_TYPE_ERR: 24;
+    readonly DATA_CLONE_ERR: 25;
+}
+// #endregion DOMException
+
+declare global {
+    var global: typeof globalThis;
+
+    var process: NodeJS.Process;
+    var console: Console;
+
+    interface ErrorConstructor {
+        /**
+         * Creates a `.stack` property on `targetObject`, which when accessed returns
+         * a string representing the location in the code at which
+         * `Error.captureStackTrace()` was called.
+         *
+         * ```js
+         * const myObject = {};
+         * Error.captureStackTrace(myObject);
+         * myObject.stack;  // Similar to `new Error().stack`
+         * ```
+         *
+         * The first line of the trace will be prefixed with
+         * `${myObject.name}: ${myObject.message}`.
+         *
+         * The optional `constructorOpt` argument accepts a function. If given, all frames
+         * above `constructorOpt`, including `constructorOpt`, will be omitted from the
+         * generated stack trace.
+         *
+         * The `constructorOpt` argument is useful for hiding implementation
+         * details of error generation from the user. For instance:
+         *
+         * ```js
+         * function a() {
+         *   b();
+         * }
+         *
+         * function b() {
+         *   c();
+         * }
+         *
+         * function c() {
+         *   // Create an error without stack trace to avoid calculating the stack trace twice.
+         *   const { stackTraceLimit } = Error;
+         *   Error.stackTraceLimit = 0;
+         *   const error = new Error();
+         *   Error.stackTraceLimit = stackTraceLimit;
+         *
+         *   // Capture the stack trace above function b
+         *   Error.captureStackTrace(error, b); // Neither function c, nor b is included in the stack trace
+         *   throw error;
+         * }
+         *
+         * a();
+         * ```
+         */
+        captureStackTrace(targetObject: object, constructorOpt?: Function): void;
+        /**
+         * @see https://v8.dev/docs/stack-trace-api#customizing-stack-traces
+         */
+        prepareStackTrace(err: Error, stackTraces: NodeJS.CallSite[]): any;
+        /**
+         * The `Error.stackTraceLimit` property specifies the number of stack frames
+         * collected by a stack trace (whether generated by `new Error().stack` or
+         * `Error.captureStackTrace(obj)`).
+         *
+         * The default value is `10` but may be set to any valid JavaScript number. Changes
+         * will affect any stack trace captured _after_ the value has been changed.
+         *
+         * If set to a non-number value, or set to a negative number, stack traces will
+         * not capture any frames.
+         */
+        stackTraceLimit: number;
+    }
+
+    /**
+     * Enable this API with the `--expose-gc` CLI flag.
+     */
+    var gc: NodeJS.GCFunction | undefined;
+
+    namespace NodeJS {
+        interface CallSite {
+            getColumnNumber(): number | null;
+            getEnclosingColumnNumber(): number | null;
+            getEnclosingLineNumber(): number | null;
+            getEvalOrigin(): string | undefined;
+            getFileName(): string | null;
+            getFunction(): Function | undefined;
+            getFunctionName(): string | null;
+            getLineNumber(): number | null;
+            getMethodName(): string | null;
+            getPosition(): number;
+            getPromiseIndex(): number | null;
+            getScriptHash(): string;
+            getScriptNameOrSourceURL(): string | null;
+            getThis(): unknown;
+            getTypeName(): string | null;
+            isAsync(): boolean;
+            isConstructor(): boolean;
+            isEval(): boolean;
+            isNative(): boolean;
+            isPromiseAll(): boolean;
+            isToplevel(): boolean;
+        }
+
+        interface ErrnoException extends Error {
+            errno?: number | undefined;
+            code?: string | undefined;
+            path?: string | undefined;
+            syscall?: string | undefined;
+        }
+
+        interface ReadableStream extends EventEmitter {
+            readable: boolean;
+            read(size?: number): string | Buffer;
+            setEncoding(encoding: BufferEncoding): this;
+            pause(): this;
+            resume(): this;
+            isPaused(): boolean;
+            pipe<T extends WritableStream>(destination: T, options?: { end?: boolean | undefined }): T;
+            unpipe(destination?: WritableStream): this;
+            unshift(chunk: string | Uint8Array, encoding?: BufferEncoding): void;
+            wrap(oldStream: ReadableStream): this;
+            [Symbol.asyncIterator](): AsyncIterableIterator<string | Buffer>;
+        }
+
+        interface WritableStream extends EventEmitter {
+            writable: boolean;
+            write(buffer: Uint8Array | string, cb?: (err?: Error | null) => void): boolean;
+            write(str: string, encoding?: BufferEncoding, cb?: (err?: Error | null) => void): boolean;
+            end(cb?: () => void): this;
+            end(data: string | Uint8Array, cb?: () => void): this;
+            end(str: string, encoding?: BufferEncoding, cb?: () => void): this;
+        }
+
+        interface ReadWriteStream extends ReadableStream, WritableStream {}
+
+        interface RefCounted {
+            ref(): this;
+            unref(): this;
+        }
+
+        interface Dict<T> {
+            [key: string]: T | undefined;
+        }
+
+        interface ReadOnlyDict<T> {
+            readonly [key: string]: T | undefined;
+        }
+
+        interface GCFunction {
+            (minor?: boolean): void;
+            (options: NodeJS.GCOptions & { execution: "async" }): Promise<void>;
+            (options: NodeJS.GCOptions): void;
+        }
+
+        interface GCOptions {
+            execution?: "sync" | "async" | undefined;
+            flavor?: "regular" | "last-resort" | undefined;
+            type?: "major-snapshot" | "major" | "minor" | undefined;
+            filename?: string | undefined;
+        }
+
+        /** An iterable iterator returned by the Node.js API. */
+        interface Iterator<T, TReturn = undefined, TNext = any> extends IteratorObject<T, TReturn, TNext> {
+            [Symbol.iterator](): NodeJS.Iterator<T, TReturn, TNext>;
+        }
+
+        /** An async iterable iterator returned by the Node.js API. */
+        interface AsyncIterator<T, TReturn = undefined, TNext = any> extends AsyncIteratorObject<T, TReturn, TNext> {
+            [Symbol.asyncIterator](): NodeJS.AsyncIterator<T, TReturn, TNext>;
+        }
+    }
+
+    // Global DOM types
+
+    interface DOMException extends _DOMException {}
+    var DOMException: typeof globalThis extends { onmessage: any; DOMException: infer T } ? T
+        : NodeDOMExceptionConstructor;
+
+    // #region AbortController
+    interface AbortController {
+        readonly signal: AbortSignal;
+        abort(reason?: any): void;
+    }
+    var AbortController: typeof globalThis extends { onmessage: any; AbortController: infer T } ? T
+        : {
+            prototype: AbortController;
+            new(): AbortController;
+        };
+
+    interface AbortSignal extends EventTarget {
+        readonly aborted: boolean;
+        onabort: ((this: AbortSignal, ev: Event) => any) | null;
+        readonly reason: any;
+        throwIfAborted(): void;
+    }
+    var AbortSignal: typeof globalThis extends { onmessage: any; AbortSignal: infer T } ? T
+        : {
+            prototype: AbortSignal;
+            new(): AbortSignal;
+            abort(reason?: any): AbortSignal;
+            any(signals: AbortSignal[]): AbortSignal;
+            timeout(milliseconds: number): AbortSignal;
+        };
+    // #endregion AbortController
+
+    // #region Storage
+    interface Storage extends _Storage {}
+    // Conditional on `onabort` rather than `onmessage`, in order to exclude lib.webworker
+    var Storage: typeof globalThis extends { onabort: any; Storage: infer T } ? T
+        : {
+            prototype: Storage;
+            new(): Storage;
+        };
+
+    var localStorage: Storage;
+    var sessionStorage: Storage;
+    // #endregion Storage
+
+    // #region fetch
+    interface RequestInit extends _RequestInit {}
+
+    function fetch(
+        input: string | URL | globalThis.Request,
+        init?: RequestInit,
+    ): Promise<Response>;
+
+    interface Request extends _Request {}
+    var Request: typeof globalThis extends {
+        onmessage: any;
+        Request: infer T;
+    } ? T
+        : typeof import("undici-types").Request;
+
+    interface ResponseInit extends _ResponseInit {}
+
+    interface Response extends _Response {}
+    var Response: typeof globalThis extends {
+        onmessage: any;
+        Response: infer T;
+    } ? T
+        : typeof import("undici-types").Response;
+
+    interface FormData extends _FormData {}
+    var FormData: typeof globalThis extends {
+        onmessage: any;
+        FormData: infer T;
+    } ? T
+        : typeof import("undici-types").FormData;
+
+    interface Headers extends _Headers {}
+    var Headers: typeof globalThis extends {
+        onmessage: any;
+        Headers: infer T;
+    } ? T
+        : typeof import("undici-types").Headers;
+
+    interface MessageEvent extends _MessageEvent {}
+    var MessageEvent: typeof globalThis extends {
+        onmessage: any;
+        MessageEvent: infer T;
+    } ? T
+        : typeof import("undici-types").MessageEvent;
+
+    interface WebSocket extends _WebSocket {}
+    var WebSocket: typeof globalThis extends { onmessage: any; WebSocket: infer T } ? T
+        : typeof import("undici-types").WebSocket;
+
+    interface EventSource extends _EventSource {}
+    var EventSource: typeof globalThis extends { onmessage: any; EventSource: infer T } ? T
+        : typeof import("undici-types").EventSource;
+
+    interface CloseEvent extends _CloseEvent {}
+    var CloseEvent: typeof globalThis extends { onmessage: any; CloseEvent: infer T } ? T
+        : typeof import("undici-types").CloseEvent;
+    // #endregion fetch
+}
diff -ruN .cache/node/http2.d.ts types/node/http2.d.ts
--- .cache/node/http2.d.ts	2025-06-26 21:45:46.962210874 +0000
+++ types/node/http2.d.ts	2025-06-26 21:45:45.737225799 +0000
@@ -1226,66 +1226,14 @@
     }
     // Http2Server
     export interface SessionOptions {
-        /**
-         * Sets the maximum dynamic table size for deflating header fields.
-         * @default 4Kib
-         */
         maxDeflateDynamicTableSize?: number | undefined;
-        /**
-         * Sets the maximum number of settings entries per `SETTINGS` frame.
-         * The minimum value allowed is `1`.
-         * @default 32
-         */
-        maxSettings?: number | undefined;
-        /**
-         * Sets the maximum memory that the `Http2Session` is permitted to use.
-         * The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
-         * The minimum value allowed is `1`.
-         * This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
-         * but new `Http2Stream` instances will be rejected while this limit is exceeded.
-         * The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
-         * current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
-         * @default 10
-         */
         maxSessionMemory?: number | undefined;
-        /**
-         * Sets the maximum number of header entries.
-         * This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
-         * The minimum value is `1`.
-         * @default 128
-         */
         maxHeaderListPairs?: number | undefined;
-        /**
-         * Sets the maximum number of outstanding, unacknowledged pings.
-         * @default 10
-         */
         maxOutstandingPings?: number | undefined;
-        /**
-         * Sets the maximum allowed size for a serialized, compressed block of headers.
-         * Attempts to send headers that exceed this limit will result in
-         * a `'frameError'` event being emitted and the stream being closed and destroyed.
-         */
         maxSendHeaderBlockLength?: number | undefined;
-        /**
-         * Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
-         * @default http2.constants.PADDING_STRATEGY_NONE
-         */
         paddingStrategy?: number | undefined;
-        /**
-         * Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
-         * Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
-         * @default 100
-         */
         peerMaxConcurrentStreams?: number | undefined;
-        /**
-         * The initial settings to send to the remote peer upon connection.
-         */
         settings?: Settings | undefined;
-        /**
-         * The array of integer values determines the settings types,
-         * which are included in the `CustomSettings`-property of the received remoteSettings.
-         * Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
-         */
         remoteCustomSettings?: number[] | undefined;
         /**
          * Specifies a timeout in milliseconds that
@@ -1294,27 +1242,11 @@
          * @default 100000
          */
         unknownProtocolTimeout?: number | undefined;
+        selectPadding?(frameLen: number, maxFrameLen: number): number;
     }
     export interface ClientSessionOptions extends SessionOptions {
-        /**
-         * Sets the maximum number of reserved push streams the client will accept at any given time.
-         * Once the current number of currently reserved push streams exceeds reaches this limit,
-         * new push streams sent by the server will be automatically rejected.
-         * The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
-         * A negative value sets this option to the maximum allowed value.
-         * @default 200
-         */
         maxReservedRemoteStreams?: number | undefined;
-        /**
-         * An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
-         * and returns any `Duplex` stream that is to be used as the connection for this session.
-         */
         createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
-        /**
-         * The protocol to connect with, if not set in the `authority`.
-         * Value may be either `'http:'` or `'https:'`.
-         * @default 'https:'
-         */
         protocol?: "http:" | "https:" | undefined;
     }
     export interface ServerSessionOptions<
diff -ruN .cache/node/http2.d.ts.orig types/node/http2.d.ts.orig
--- .cache/node/http2.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/http2.d.ts.orig	2025-06-26 21:45:45.738225787 +0000
@@ -0,0 +1,2628 @@
+/**
+ * The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.
+ * It can be accessed using:
+ *
+ * ```js
+ * import http2 from 'node:http2';
+ * ```
+ * @since v8.4.0
+ * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/http2.js)
+ */
+declare module "http2" {
+    import EventEmitter = require("node:events");
+    import * as fs from "node:fs";
+    import * as net from "node:net";
+    import * as stream from "node:stream";
+    import * as tls from "node:tls";
+    import * as url from "node:url";
+    import {
+        IncomingHttpHeaders as Http1IncomingHttpHeaders,
+        IncomingMessage,
+        OutgoingHttpHeaders,
+        ServerResponse,
+    } from "node:http";
+    export { OutgoingHttpHeaders } from "node:http";
+    export interface IncomingHttpStatusHeader {
+        ":status"?: number | undefined;
+    }
+    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
+        ":path"?: string | undefined;
+        ":method"?: string | undefined;
+        ":authority"?: string | undefined;
+        ":scheme"?: string | undefined;
+    }
+    // Http2Stream
+    export interface StreamPriorityOptions {
+        exclusive?: boolean | undefined;
+        parent?: number | undefined;
+        weight?: number | undefined;
+        silent?: boolean | undefined;
+    }
+    export interface StreamState {
+        localWindowSize?: number | undefined;
+        state?: number | undefined;
+        localClose?: number | undefined;
+        remoteClose?: number | undefined;
+        sumDependencyWeight?: number | undefined;
+        weight?: number | undefined;
+    }
+    export interface ServerStreamResponseOptions {
+        endStream?: boolean | undefined;
+        waitForTrailers?: boolean | undefined;
+    }
+    export interface StatOptions {
+        offset: number;
+        length: number;
+    }
+    export interface ServerStreamFileResponseOptions {
+        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
+        waitForTrailers?: boolean | undefined;
+        offset?: number | undefined;
+        length?: number | undefined;
+    }
+    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
+        onError?(err: NodeJS.ErrnoException): void;
+    }
+    export interface Http2Stream extends stream.Duplex {
+        /**
+         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
+         * the `'aborted'` event will have been emitted.
+         * @since v8.4.0
+         */
+        readonly aborted: boolean;
+        /**
+         * This property shows the number of characters currently buffered to be written.
+         * See `net.Socket.bufferSize` for details.
+         * @since v11.2.0, v10.16.0
+         */
+        readonly bufferSize: number;
+        /**
+         * Set to `true` if the `Http2Stream` instance has been closed.
+         * @since v9.4.0
+         */
+        readonly closed: boolean;
+        /**
+         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
+         * usable.
+         * @since v8.4.0
+         */
+        readonly destroyed: boolean;
+        /**
+         * Set to `true` if the `END_STREAM` flag was set in the request or response
+         * HEADERS frame received, indicating that no additional data should be received
+         * and the readable side of the `Http2Stream` will be closed.
+         * @since v10.11.0
+         */
+        readonly endAfterHeaders: boolean;
+        /**
+         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.
+         * @since v8.4.0
+         */
+        readonly id?: number | undefined;
+        /**
+         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
+         * numeric stream identifier.
+         * @since v9.4.0
+         */
+        readonly pending: boolean;
+        /**
+         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
+         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
+         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.
+         * @since v8.4.0
+         */
+        readonly rstCode: number;
+        /**
+         * An object containing the outbound headers sent for this `Http2Stream`.
+         * @since v9.5.0
+         */
+        readonly sentHeaders: OutgoingHttpHeaders;
+        /**
+         * An array of objects containing the outbound informational (additional) headers
+         * sent for this `Http2Stream`.
+         * @since v9.5.0
+         */
+        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
+        /**
+         * An object containing the outbound trailers sent for this `HttpStream`.
+         * @since v9.5.0
+         */
+        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
+        /**
+         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
+         * value will be `undefined` after the `Http2Stream` instance is destroyed.
+         * @since v8.4.0
+         */
+        readonly session: Http2Session | undefined;
+        /**
+         * Provides miscellaneous information about the current state of the `Http2Stream`.
+         *
+         * A current state of this `Http2Stream`.
+         * @since v8.4.0
+         */
+        readonly state: StreamState;
+        /**
+         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
+         * connected HTTP/2 peer.
+         * @since v8.4.0
+         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
+         * @param callback An optional function registered to listen for the `'close'` event.
+         */
+        close(code?: number, callback?: () => void): void;
+        /**
+         * Updates the priority for this `Http2Stream` instance.
+         * @since v8.4.0
+         */
+        priority(options: StreamPriorityOptions): void;
+        /**
+         * ```js
+         * import http2 from 'node:http2';
+         * const client = http2.connect('http://example.org:8000');
+         * const { NGHTTP2_CANCEL } = http2.constants;
+         * const req = client.request({ ':path': '/' });
+         *
+         * // Cancel the stream if there's no activity after 5 seconds
+         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
+         * ```
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
+         * will cause the `Http2Stream` to be immediately closed and must only be
+         * called after the `'wantTrailers'` event has been emitted. When sending a
+         * request or sending a response, the `options.waitForTrailers` option must be set
+         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
+         * trailers can be sent.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond(undefined, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ xyz: 'abc' });
+         *   });
+         *   stream.end('Hello World');
+         * });
+         * ```
+         *
+         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
+         * fields (e.g. `':method'`, `':path'`, etc).
+         * @since v10.0.0
+         */
+        sendTrailers(headers: OutgoingHttpHeaders): void;
+        addListener(event: "aborted", listener: () => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        addListener(event: "drain", listener: () => void): this;
+        addListener(event: "end", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(event: "finish", listener: () => void): this;
+        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "streamClosed", listener: (code: number) => void): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        addListener(event: "wantTrailers", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "aborted"): boolean;
+        emit(event: "close"): boolean;
+        emit(event: "data", chunk: Buffer | string): boolean;
+        emit(event: "drain"): boolean;
+        emit(event: "end"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: "finish"): boolean;
+        emit(event: "frameError", frameType: number, errorCode: number): boolean;
+        emit(event: "pipe", src: stream.Readable): boolean;
+        emit(event: "unpipe", src: stream.Readable): boolean;
+        emit(event: "streamClosed", code: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "wantTrailers"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "aborted", listener: () => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "data", listener: (chunk: Buffer | string) => void): this;
+        on(event: "drain", listener: () => void): this;
+        on(event: "end", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: "finish", listener: () => void): this;
+        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        on(event: "pipe", listener: (src: stream.Readable) => void): this;
+        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        on(event: "streamClosed", listener: (code: number) => void): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        on(event: "wantTrailers", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "aborted", listener: () => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "data", listener: (chunk: Buffer | string) => void): this;
+        once(event: "drain", listener: () => void): this;
+        once(event: "end", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: "finish", listener: () => void): this;
+        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        once(event: "pipe", listener: (src: stream.Readable) => void): this;
+        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        once(event: "streamClosed", listener: (code: number) => void): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        once(event: "wantTrailers", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "aborted", listener: () => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependListener(event: "drain", listener: () => void): this;
+        prependListener(event: "end", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(event: "finish", listener: () => void): this;
+        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "streamClosed", listener: (code: number) => void): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        prependListener(event: "wantTrailers", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "aborted", listener: () => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependOnceListener(event: "drain", listener: () => void): this;
+        prependOnceListener(event: "end", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(event: "finish", listener: () => void): this;
+        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        prependOnceListener(event: "wantTrailers", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ClientHttp2Stream extends Http2Stream {
+        addListener(event: "continue", listener: () => {}): this;
+        addListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        addListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "continue"): boolean;
+        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
+        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "continue", listener: () => {}): this;
+        on(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        on(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "continue", listener: () => {}): this;
+        once(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        once(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "continue", listener: () => {}): this;
+        prependListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        prependListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "continue", listener: () => {}): this;
+        prependOnceListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        prependOnceListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ServerHttp2Stream extends Http2Stream {
+        /**
+         * True if headers were sent, false otherwise (read-only).
+         * @since v8.4.0
+         */
+        readonly headersSent: boolean;
+        /**
+         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
+         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
+         * accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.
+         * @since v8.4.0
+         */
+        readonly pushAllowed: boolean;
+        /**
+         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
+         * @since v8.4.0
+         */
+        additionalHeaders(headers: OutgoingHttpHeaders): void;
+        /**
+         * Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 });
+         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
+         *     if (err) throw err;
+         *     pushStream.respond({ ':status': 200 });
+         *     pushStream.end('some pushed data');
+         *   });
+         *   stream.end('some data');
+         * });
+         * ```
+         *
+         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
+         * a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.
+         *
+         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
+         * and will throw an error.
+         * @since v8.4.0
+         * @param callback Callback that is called once the push stream has been initiated.
+         */
+        pushStream(
+            headers: OutgoingHttpHeaders,
+            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
+        ): void;
+        pushStream(
+            headers: OutgoingHttpHeaders,
+            options?: StreamPriorityOptions,
+            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
+        ): void;
+        /**
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 });
+         *   stream.end('some data');
+         * });
+         * ```
+         *
+         * Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be sent.
+         * The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         *   stream.end('some data');
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
+        /**
+         * Initiates a response whose data is read from the given file descriptor. No
+         * validation is performed on the given file descriptor. If an error occurs while
+         * attempting to read data using the file descriptor, the `Http2Stream` will be
+         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
+         *
+         * When used, the `Http2Stream` object's `Duplex` interface will be closed
+         * automatically.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * import fs from 'node:fs';
+         *
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   const fd = fs.openSync('/some/file', 'r');
+         *
+         *   const stat = fs.fstatSync(fd);
+         *   const headers = {
+         *     'content-length': stat.size,
+         *     'last-modified': stat.mtime.toUTCString(),
+         *     'content-type': 'text/plain; charset=utf-8',
+         *   };
+         *   stream.respondWithFD(fd, headers);
+         *   stream.on('close', () => fs.closeSync(fd));
+         * });
+         * ```
+         *
+         * The optional `options.statCheck` function may be specified to give user code
+         * an opportunity to set additional content headers based on the `fs.Stat` details
+         * of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will
+         * perform an `fs.fstat()` call to collect details on the provided file descriptor.
+         *
+         * The `offset` and `length` options may be used to limit the response to a
+         * specific range subset. This can be used, for instance, to support HTTP Range
+         * requests.
+         *
+         * The file descriptor or `FileHandle` is not closed when the stream is closed,
+         * so it will need to be closed manually once it is no longer needed.
+         * Using the same file descriptor concurrently for multiple streams
+         * is not supported and may result in data loss. Re-using a file descriptor
+         * after a stream has finished is supported.
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be
+         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
+         * header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`
+         * or `http2stream.close()` to close the `Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * import fs from 'node:fs';
+         *
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   const fd = fs.openSync('/some/file', 'r');
+         *
+         *   const stat = fs.fstatSync(fd);
+         *   const headers = {
+         *     'content-length': stat.size,
+         *     'last-modified': stat.mtime.toUTCString(),
+         *     'content-type': 'text/plain; charset=utf-8',
+         *   };
+         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         *
+         *   stream.on('close', () => fs.closeSync(fd));
+         * });
+         * ```
+         * @since v8.4.0
+         * @param fd A readable file descriptor.
+         */
+        respondWithFD(
+            fd: number | fs.promises.FileHandle,
+            headers?: OutgoingHttpHeaders,
+            options?: ServerStreamFileResponseOptions,
+        ): void;
+        /**
+         * Sends a regular file as the response. The `path` must specify a regular file
+         * or an `'error'` event will be emitted on the `Http2Stream` object.
+         *
+         * When used, the `Http2Stream` object's `Duplex` interface will be closed
+         * automatically.
+         *
+         * The optional `options.statCheck` function may be specified to give user code
+         * an opportunity to set additional content headers based on the `fs.Stat` details
+         * of the given file:
+         *
+         * If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an
+         * `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
+         * If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.
+         *
+         * Example using a file path:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   function statCheck(stat, headers) {
+         *     headers['last-modified'] = stat.mtime.toUTCString();
+         *   }
+         *
+         *   function onError(err) {
+         *     // stream.respond() can throw if the stream has been destroyed by
+         *     // the other side.
+         *     try {
+         *       if (err.code === 'ENOENT') {
+         *         stream.respond({ ':status': 404 });
+         *       } else {
+         *         stream.respond({ ':status': 500 });
+         *       }
+         *     } catch (err) {
+         *       // Perform actual error handling.
+         *       console.error(err);
+         *     }
+         *     stream.end();
+         *   }
+         *
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { statCheck, onError });
+         * });
+         * ```
+         *
+         * The `options.statCheck` function may also be used to cancel the send operation
+         * by returning `false`. For instance, a conditional request may check the stat
+         * results to determine if the file has been modified to return an appropriate `304` response:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   function statCheck(stat, headers) {
+         *     // Check the stat here...
+         *     stream.respond({ ':status': 304 });
+         *     return false; // Cancel the send operation
+         *   }
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { statCheck });
+         * });
+         * ```
+         *
+         * The `content-length` header field will be automatically set.
+         *
+         * The `offset` and `length` options may be used to limit the response to a
+         * specific range subset. This can be used, for instance, to support HTTP Range
+         * requests.
+         *
+         * The `options.onError` function may also be used to handle all the errors
+         * that could happen before the delivery of the file is initiated. The
+         * default behavior is to destroy the stream.
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be
+         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
+         * header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        respondWithFile(
+            path: string,
+            headers?: OutgoingHttpHeaders,
+            options?: ServerStreamFileResponseOptionsWithError,
+        ): void;
+    }
+    // Http2Session
+    export interface Settings {
+        headerTableSize?: number | undefined;
+        enablePush?: boolean | undefined;
+        initialWindowSize?: number | undefined;
+        maxFrameSize?: number | undefined;
+        maxConcurrentStreams?: number | undefined;
+        maxHeaderListSize?: number | undefined;
+        enableConnectProtocol?: boolean | undefined;
+    }
+    export interface ClientSessionRequestOptions {
+        endStream?: boolean | undefined;
+        exclusive?: boolean | undefined;
+        parent?: number | undefined;
+        weight?: number | undefined;
+        waitForTrailers?: boolean | undefined;
+        signal?: AbortSignal | undefined;
+    }
+    export interface SessionState {
+        effectiveLocalWindowSize?: number | undefined;
+        effectiveRecvDataLength?: number | undefined;
+        nextStreamID?: number | undefined;
+        localWindowSize?: number | undefined;
+        lastProcStreamID?: number | undefined;
+        remoteWindowSize?: number | undefined;
+        outboundQueueSize?: number | undefined;
+        deflateDynamicTableSize?: number | undefined;
+        inflateDynamicTableSize?: number | undefined;
+    }
+    export interface Http2Session extends EventEmitter {
+        /**
+         * Value will be `undefined` if the `Http2Session` is not yet connected to a
+         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
+         * will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.
+         * @since v9.4.0
+         */
+        readonly alpnProtocol?: string | undefined;
+        /**
+         * Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.
+         * @since v9.4.0
+         */
+        readonly closed: boolean;
+        /**
+         * Will be `true` if this `Http2Session` instance is still connecting, will be set
+         * to `false` before emitting `connect` event and/or calling the `http2.connect` callback.
+         * @since v10.0.0
+         */
+        readonly connecting: boolean;
+        /**
+         * Will be `true` if this `Http2Session` instance has been destroyed and must no
+         * longer be used, otherwise `false`.
+         * @since v8.4.0
+         */
+        readonly destroyed: boolean;
+        /**
+         * Value is `undefined` if the `Http2Session` session socket has not yet been
+         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
+         * and `false` if the `Http2Session` is connected to any other kind of socket
+         * or stream.
+         * @since v9.4.0
+         */
+        readonly encrypted?: boolean | undefined;
+        /**
+         * A prototype-less object describing the current local settings of this `Http2Session`.
+         * The local settings are local to _this_`Http2Session` instance.
+         * @since v8.4.0
+         */
+        readonly localSettings: Settings;
+        /**
+         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
+         * will return an `Array` of origins for which the `Http2Session` may be
+         * considered authoritative.
+         *
+         * The `originSet` property is only available when using a secure TLS connection.
+         * @since v9.4.0
+         */
+        readonly originSet?: string[] | undefined;
+        /**
+         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
+         * a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.
+         * Will be `false` once all sent `SETTINGS` frames have been acknowledged.
+         * @since v8.4.0
+         */
+        readonly pendingSettingsAck: boolean;
+        /**
+         * A prototype-less object describing the current remote settings of this`Http2Session`.
+         * The remote settings are set by the _connected_ HTTP/2 peer.
+         * @since v8.4.0
+         */
+        readonly remoteSettings: Settings;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * limits available methods to ones safe to use with HTTP/2.
+         *
+         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
+         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
+         *
+         * `setTimeout` method will be called on this `Http2Session`.
+         *
+         * All other interactions will be routed directly to the socket.
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * Provides miscellaneous information about the current state of the`Http2Session`.
+         *
+         * An object describing the current status of this `Http2Session`.
+         * @since v8.4.0
+         */
+        readonly state: SessionState;
+        /**
+         * The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
+         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
+         * client.
+         * @since v8.4.0
+         */
+        readonly type: number;
+        /**
+         * Gracefully closes the `Http2Session`, allowing any existing streams to
+         * complete on their own and preventing new `Http2Stream` instances from being
+         * created. Once closed, `http2session.destroy()`_might_ be called if there
+         * are no open `Http2Stream` instances.
+         *
+         * If specified, the `callback` function is registered as a handler for the`'close'` event.
+         * @since v9.4.0
+         */
+        close(callback?: () => void): void;
+        /**
+         * Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.
+         *
+         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.
+         *
+         * If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.
+         * @since v8.4.0
+         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
+         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
+         */
+        destroy(error?: Error, code?: number): void;
+        /**
+         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
+         * @since v9.4.0
+         * @param code An HTTP/2 error code
+         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
+         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
+         */
+        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
+        /**
+         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
+         * be provided. The method will return `true` if the `PING` was sent, `false` otherwise.
+         *
+         * The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.
+         *
+         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and
+         * returned with the ping acknowledgment.
+         *
+         * The callback will be invoked with three arguments: an error argument that will
+         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
+         * that reports the number of milliseconds elapsed since the ping was sent and the
+         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.
+         *
+         * ```js
+         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
+         *   if (!err) {
+         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
+         *     console.log(`With payload '${payload.toString()}'`);
+         *   }
+         * });
+         * ```
+         *
+         * If the `payload` argument is not specified, the default payload will be the
+         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
+         * @since v8.9.3
+         * @param payload Optional ping payload.
+         */
+        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
+        ping(
+            payload: NodeJS.ArrayBufferView,
+            callback: (err: Error | null, duration: number, payload: Buffer) => void,
+        ): boolean;
+        /**
+         * Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.
+         * @since v9.4.0
+         */
+        ref(): void;
+        /**
+         * Sets the local endpoint's window size.
+         * The `windowSize` is the total window size to set, not
+         * the delta.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         *
+         * const server = http2.createServer();
+         * const expectedWindowSize = 2 ** 20;
+         * server.on('connect', (session) => {
+         *
+         *   // Set local window size to be 2 ** 20
+         *   session.setLocalWindowSize(expectedWindowSize);
+         * });
+         * ```
+         * @since v15.3.0, v14.18.0
+         */
+        setLocalWindowSize(windowSize: number): void;
+        /**
+         * Used to set a callback function that is called when there is no activity on
+         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
+         * registered as a listener on the `'timeout'` event.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.
+         *
+         * Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new
+         * settings.
+         *
+         * The new settings will not become effective until the `SETTINGS` acknowledgment
+         * is received and the `'localSettings'` event is emitted. It is possible to send
+         * multiple `SETTINGS` frames while acknowledgment is still pending.
+         * @since v8.4.0
+         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
+         */
+        settings(
+            settings: Settings,
+            callback?: (err: Error | null, settings: Settings, duration: number) => void,
+        ): void;
+        /**
+         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
+         * @since v9.4.0
+         */
+        unref(): void;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        addListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        addListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        addListener(event: "ping", listener: () => void): this;
+        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "close"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;
+        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;
+        emit(event: "localSettings", settings: Settings): boolean;
+        emit(event: "ping"): boolean;
+        emit(event: "remoteSettings", settings: Settings): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "close", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
+        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
+        on(event: "localSettings", listener: (settings: Settings) => void): this;
+        on(event: "ping", listener: () => void): this;
+        on(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
+        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
+        once(event: "localSettings", listener: (settings: Settings) => void): this;
+        once(event: "ping", listener: () => void): this;
+        once(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        prependListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        prependListener(event: "ping", listener: () => void): this;
+        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        prependOnceListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        prependOnceListener(event: "ping", listener: () => void): this;
+        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ClientHttp2Session extends Http2Session {
+        /**
+         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an
+         * HTTP/2 request to the connected server.
+         *
+         * When a `ClientHttp2Session` is first created, the socket may not yet be
+         * connected. if `clienthttp2session.request()` is called during this time, the
+         * actual request will be deferred until the socket is ready to go.
+         * If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.
+         *
+         * This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const clientSession = http2.connect('https://localhost:1234');
+         * const {
+         *   HTTP2_HEADER_PATH,
+         *   HTTP2_HEADER_STATUS,
+         * } = http2.constants;
+         *
+         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
+         * req.on('response', (headers) => {
+         *   console.log(headers[HTTP2_HEADER_STATUS]);
+         *   req.on('data', (chunk) => { // ..  });
+         *   req.on('end', () => { // ..  });
+         * });
+         * ```
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * is emitted immediately after queuing the last chunk of payload data to be sent.
+         * The `http2stream.sendTrailers()` method can then be called to send trailing
+         * headers to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
+         *
+         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
+         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
+         *
+         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
+         * they respectively default to:
+         *
+         * * `:method` \= `'GET'`
+         * * `:path` \= `/`
+         * @since v8.4.0
+         */
+        request(
+            headers?: OutgoingHttpHeaders | readonly string[],
+            options?: ClientSessionRequestOptions,
+        ): ClientHttp2Stream;
+        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        addListener(event: "origin", listener: (origins: string[]) => void): this;
+        addListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        addListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;
+        emit(event: "origin", origins: readonly string[]): boolean;
+        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
+        emit(
+            event: "stream",
+            stream: ClientHttp2Stream,
+            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+            flags: number,
+        ): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        on(event: "origin", listener: (origins: string[]) => void): this;
+        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
+        on(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        once(event: "origin", listener: (origins: string[]) => void): this;
+        once(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        once(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        prependListener(event: "origin", listener: (origins: string[]) => void): this;
+        prependListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        prependListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        prependOnceListener(event: "origin", listener: (origins: string[]) => void): this;
+        prependOnceListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface AlternativeServiceOptions {
+        origin: number | string | url.URL;
+    }
+    export interface ServerHttp2Session<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends Http2Session {
+        readonly server:
+            | Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>
+            | Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
+        /**
+         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         *
+         * const server = http2.createServer();
+         * server.on('session', (session) => {
+         *   // Set altsvc for origin https://example.org:80
+         *   session.altsvc('h2=":8000"', 'https://example.org:80');
+         * });
+         *
+         * server.on('stream', (stream) => {
+         *   // Set altsvc for a specific stream
+         *   stream.session.altsvc('h2=":8000"', stream.id);
+         * });
+         * ```
+         *
+         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
+         * service is associated with the origin of the given `Http2Stream`.
+         *
+         * The `alt` and origin string _must_ contain only ASCII bytes and are
+         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
+         * domain.
+         *
+         * When a string is passed for the `originOrStream` argument, it will be parsed as
+         * a URL and the origin will be derived. For instance, the origin for the
+         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
+         * cannot be parsed as a URL or if a valid origin cannot be derived.
+         *
+         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
+         * used. The value of the `origin` property _must_ be a properly serialized
+         * ASCII origin.
+         * @since v9.4.0
+         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
+         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
+         * `http2stream.id` property.
+         */
+        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
+        /**
+         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
+         * to advertise the set of origins for which the server is capable of providing
+         * authoritative responses.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const options = getSecureOptionsSomehow();
+         * const server = http2.createSecureServer(options);
+         * server.on('stream', (stream) => {
+         *   stream.respond();
+         *   stream.end('ok');
+         * });
+         * server.on('session', (session) => {
+         *   session.origin('https://example.com', 'https://example.org');
+         * });
+         * ```
+         *
+         * When a string is passed as an `origin`, it will be parsed as a URL and the
+         * origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given
+         * string
+         * cannot be parsed as a URL or if a valid origin cannot be derived.
+         *
+         * A `URL` object, or any object with an `origin` property, may be passed as
+         * an `origin`, in which case the value of the `origin` property will be
+         * used. The value of the `origin` property _must_ be a properly serialized
+         * ASCII origin.
+         *
+         * Alternatively, the `origins` option may be used when creating a new HTTP/2
+         * server using the `http2.createSecureServer()` method:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const options = getSecureOptionsSomehow();
+         * options.origins = ['https://example.com', 'https://example.org'];
+         * const server = http2.createSecureServer(options);
+         * server.on('stream', (stream) => {
+         *   stream.respond();
+         *   stream.end('ok');
+         * });
+         * ```
+         * @since v10.12.0
+         * @param origins One or more URL Strings passed as separate arguments.
+         */
+        origin(
+            ...origins: Array<
+                | string
+                | url.URL
+                | {
+                    origin: string;
+                }
+            >
+        ): void;
+        addListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "connect",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+            socket: net.Socket | tls.TLSSocket,
+        ): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    // Http2Server
+    export interface SessionOptions {
+        /**
+         * Sets the maximum dynamic table size for deflating header fields.
+         * @default 4Kib
+         */
+        maxDeflateDynamicTableSize?: number | undefined;
+        /**
+         * Sets the maximum number of settings entries per `SETTINGS` frame.
+         * The minimum value allowed is `1`.
+         * @default 32
+         */
+        maxSettings?: number | undefined;
+        /**
+         * Sets the maximum memory that the `Http2Session` is permitted to use.
+         * The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
+         * The minimum value allowed is `1`.
+         * This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
+         * but new `Http2Stream` instances will be rejected while this limit is exceeded.
+         * The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
+         * current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
+         * @default 10
+         */
+        maxSessionMemory?: number | undefined;
+        /**
+         * Sets the maximum number of header entries.
+         * This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
+         * The minimum value is `1`.
+         * @default 128
+         */
+        maxHeaderListPairs?: number | undefined;
+        /**
+         * Sets the maximum number of outstanding, unacknowledged pings.
+         * @default 10
+         */
+        maxOutstandingPings?: number | undefined;
+        /**
+         * Sets the maximum allowed size for a serialized, compressed block of headers.
+         * Attempts to send headers that exceed this limit will result in
+         * a `'frameError'` event being emitted and the stream being closed and destroyed.
+         */
+        maxSendHeaderBlockLength?: number | undefined;
+        /**
+         * Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
+         * @default http2.constants.PADDING_STRATEGY_NONE
+         */
+        paddingStrategy?: number | undefined;
+        /**
+         * Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
+         * Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
+         * @default 100
+         */
+        peerMaxConcurrentStreams?: number | undefined;
+        /**
+         * The initial settings to send to the remote peer upon connection.
+         */
+        settings?: Settings | undefined;
+        /**
+         * The array of integer values determines the settings types,
+         * which are included in the `CustomSettings`-property of the received remoteSettings.
+         * Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
+         */
+        remoteCustomSettings?: number[] | undefined;
+        /**
+         * Specifies a timeout in milliseconds that
+         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the
+         * socket has not been destroyed by that time the server will destroy it.
+         * @default 100000
+         */
+        unknownProtocolTimeout?: number | undefined;
+    }
+    export interface ClientSessionOptions extends SessionOptions {
+        /**
+         * Sets the maximum number of reserved push streams the client will accept at any given time.
+         * Once the current number of currently reserved push streams exceeds reaches this limit,
+         * new push streams sent by the server will be automatically rejected.
+         * The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
+         * A negative value sets this option to the maximum allowed value.
+         * @default 200
+         */
+        maxReservedRemoteStreams?: number | undefined;
+        /**
+         * An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
+         * and returns any `Duplex` stream that is to be used as the connection for this session.
+         */
+        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
+        /**
+         * The protocol to connect with, if not set in the `authority`.
+         * Value may be either `'http:'` or `'https:'`.
+         * @default 'https:'
+         */
+        protocol?: "http:" | "https:" | undefined;
+    }
+    export interface ServerSessionOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends SessionOptions {
+        streamResetBurst?: number | undefined;
+        streamResetRate?: number | undefined;
+        Http1IncomingMessage?: Http1Request | undefined;
+        Http1ServerResponse?: Http1Response | undefined;
+        Http2ServerRequest?: Http2Request | undefined;
+        Http2ServerResponse?: Http2Response | undefined;
+    }
+    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
+    export interface SecureServerSessionOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>, tls.TlsOptions {}
+    export interface ServerOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {}
+    export interface SecureServerOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
+        allowHTTP1?: boolean | undefined;
+        origins?: string[] | undefined;
+    }
+    interface HTTP2ServerCommon {
+        setTimeout(msec?: number, callback?: () => void): this;
+        /**
+         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
+         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
+         */
+        updateSettings(settings: Settings): void;
+    }
+    export interface Http2Server<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends net.Server, HTTP2ServerCommon {
+        addListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        addListener(event: "sessionError", listener: (err: Error) => void): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "checkContinue",
+            request: InstanceType<Http2Request>,
+            response: InstanceType<Http2Response>,
+        ): boolean;
+        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
+        emit(
+            event: "session",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+        ): boolean;
+        emit(event: "sessionError", err: Error): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        on(event: "sessionError", listener: (err: Error) => void): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        once(event: "sessionError", listener: (err: Error) => void): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface Http2SecureServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends tls.Server, HTTP2ServerCommon {
+        addListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        addListener(event: "sessionError", listener: (err: Error) => void): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "checkContinue",
+            request: InstanceType<Http2Request>,
+            response: InstanceType<Http2Response>,
+        ): boolean;
+        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
+        emit(
+            event: "session",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+        ): boolean;
+        emit(event: "sessionError", err: Error): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        on(event: "sessionError", listener: (err: Error) => void): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        once(event: "sessionError", listener: (err: Error) => void): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    /**
+     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
+     * headers, and
+     * data.
+     * @since v8.4.0
+     */
+    export class Http2ServerRequest extends stream.Readable {
+        constructor(
+            stream: ServerHttp2Stream,
+            headers: IncomingHttpHeaders,
+            options: stream.ReadableOptions,
+            rawHeaders: readonly string[],
+        );
+        /**
+         * The `request.aborted` property will be `true` if the request has
+         * been aborted.
+         * @since v10.1.0
+         */
+        readonly aborted: boolean;
+        /**
+         * The request authority pseudo header field. Because HTTP/2 allows requests
+         * to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.
+         * @since v8.4.0
+         */
+        readonly authority: string;
+        /**
+         * See `request.socket`.
+         * @since v8.4.0
+         * @deprecated Since v13.0.0 - Use `socket`.
+         */
+        readonly connection: net.Socket | tls.TLSSocket;
+        /**
+         * The `request.complete` property will be `true` if the request has
+         * been completed, aborted, or destroyed.
+         * @since v12.10.0
+         */
+        readonly complete: boolean;
+        /**
+         * The request/response headers object.
+         *
+         * Key-value pairs of header names and values. Header names are lower-cased.
+         *
+         * ```js
+         * // Prints something like:
+         * //
+         * // { 'user-agent': 'curl/7.22.0',
+         * //   host: '127.0.0.1:8000',
+         * //   accept: '*' }
+         * console.log(request.headers);
+         * ```
+         *
+         * See `HTTP/2 Headers Object`.
+         *
+         * In HTTP/2, the request path, host name, protocol, and method are represented as
+         * special headers prefixed with the `:` character (e.g. `':path'`). These special
+         * headers will be included in the `request.headers` object. Care must be taken not
+         * to inadvertently modify these special headers or errors may occur. For instance,
+         * removing all headers from the request will cause errors to occur:
+         *
+         * ```js
+         * removeAllHeaders(request.headers);
+         * assert(request.url);   // Fails because the :path header has been removed
+         * ```
+         * @since v8.4.0
+         */
+        readonly headers: IncomingHttpHeaders;
+        /**
+         * In case of server request, the HTTP version sent by the client. In the case of
+         * client response, the HTTP version of the connected-to server. Returns `'2.0'`.
+         *
+         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
+         * @since v8.4.0
+         */
+        readonly httpVersion: string;
+        readonly httpVersionMinor: number;
+        readonly httpVersionMajor: number;
+        /**
+         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
+         * @since v8.4.0
+         */
+        readonly method: string;
+        /**
+         * The raw request/response headers list exactly as they were received.
+         *
+         * The keys and values are in the same list. It is _not_ a
+         * list of tuples. So, the even-numbered offsets are key values, and the
+         * odd-numbered offsets are the associated values.
+         *
+         * Header names are not lowercased, and duplicates are not merged.
+         *
+         * ```js
+         * // Prints something like:
+         * //
+         * // [ 'user-agent',
+         * //   'this is invalid because there can be only one',
+         * //   'User-Agent',
+         * //   'curl/7.22.0',
+         * //   'Host',
+         * //   '127.0.0.1:8000',
+         * //   'ACCEPT',
+         * //   '*' ]
+         * console.log(request.rawHeaders);
+         * ```
+         * @since v8.4.0
+         */
+        readonly rawHeaders: string[];
+        /**
+         * The raw request/response trailer keys and values exactly as they were
+         * received. Only populated at the `'end'` event.
+         * @since v8.4.0
+         */
+        readonly rawTrailers: string[];
+        /**
+         * The request scheme pseudo header field indicating the scheme
+         * portion of the target URL.
+         * @since v8.4.0
+         */
+        readonly scheme: string;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * applies getters, setters, and methods based on HTTP/2 logic.
+         *
+         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
+         * set on `request.stream`.
+         *
+         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.
+         *
+         * `setTimeout` method will be called on `request.stream.session`.
+         *
+         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
+         * more information.
+         *
+         * All other interactions will be routed directly to the socket. With TLS support,
+         * use `request.socket.getPeerCertificate()` to obtain the client's
+         * authentication details.
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * The `Http2Stream` object backing the request.
+         * @since v8.4.0
+         */
+        readonly stream: ServerHttp2Stream;
+        /**
+         * The request/response trailers object. Only populated at the `'end'` event.
+         * @since v8.4.0
+         */
+        readonly trailers: IncomingHttpHeaders;
+        /**
+         * Request URL string. This contains only the URL that is present in the actual
+         * HTTP request. If the request is:
+         *
+         * ```http
+         * GET /status?name=ryan HTTP/1.1
+         * Accept: text/plain
+         * ```
+         *
+         * Then `request.url` will be:
+         *
+         * ```js
+         * '/status?name=ryan'
+         * ```
+         *
+         * To parse the url into its parts, `new URL()` can be used:
+         *
+         * ```console
+         * $ node
+         * > new URL('/status?name=ryan', 'http://example.com')
+         * URL {
+         *   href: 'http://example.com/status?name=ryan',
+         *   origin: 'http://example.com',
+         *   protocol: 'http:',
+         *   username: '',
+         *   password: '',
+         *   host: 'example.com',
+         *   hostname: 'example.com',
+         *   port: '',
+         *   pathname: '/status',
+         *   search: '?name=ryan',
+         *   searchParams: URLSearchParams { 'name' => 'ryan' },
+         *   hash: ''
+         * }
+         * ```
+         * @since v8.4.0
+         */
+        url: string;
+        /**
+         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
+         * provided, then it is added as a listener on the `'timeout'` event on
+         * the response object.
+         *
+         * If no `'timeout'` listener is added to the request, the response, or
+         * the server, then `Http2Stream`s are destroyed when they time out. If a
+         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        read(size?: number): Buffer | string | null;
+        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        addListener(event: "end", listener: () => void): this;
+        addListener(event: "readable", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "aborted", hadError: boolean, code: number): boolean;
+        emit(event: "close"): boolean;
+        emit(event: "data", chunk: Buffer | string): boolean;
+        emit(event: "end"): boolean;
+        emit(event: "readable"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "data", listener: (chunk: Buffer | string) => void): this;
+        on(event: "end", listener: () => void): this;
+        on(event: "readable", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "data", listener: (chunk: Buffer | string) => void): this;
+        once(event: "end", listener: () => void): this;
+        once(event: "readable", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependListener(event: "end", listener: () => void): this;
+        prependListener(event: "readable", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependOnceListener(event: "end", listener: () => void): this;
+        prependOnceListener(event: "readable", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    /**
+     * This object is created internally by an HTTP server, not by the user. It is
+     * passed as the second parameter to the `'request'` event.
+     * @since v8.4.0
+     */
+    export class Http2ServerResponse<Request extends Http2ServerRequest = Http2ServerRequest> extends stream.Writable {
+        constructor(stream: ServerHttp2Stream);
+        /**
+         * See `response.socket`.
+         * @since v8.4.0
+         * @deprecated Since v13.0.0 - Use `socket`.
+         */
+        readonly connection: net.Socket | tls.TLSSocket;
+        /**
+         * Append a single header value to the header object.
+         *
+         * If the value is an array, this is equivalent to calling this method multiple times.
+         *
+         * If there were no previous values for the header, this is equivalent to calling {@link setHeader}.
+         *
+         * Attempting to set a header field name or value that contains invalid characters will result in a
+         * [TypeError](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-typeerror) being thrown.
+         *
+         * ```js
+         * // Returns headers including "set-cookie: a" and "set-cookie: b"
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('set-cookie', 'a');
+         *   res.appendHeader('set-cookie', 'b');
+         *   res.writeHead(200);
+         *   res.end('ok');
+         * });
+         * ```
+         * @since v20.12.0
+         */
+        appendHeader(name: string, value: string | string[]): void;
+        /**
+         * Boolean value that indicates whether the response has completed. Starts
+         * as `false`. After `response.end()` executes, the value will be `true`.
+         * @since v8.4.0
+         * @deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.
+         */
+        readonly finished: boolean;
+        /**
+         * True if headers were sent, false otherwise (read-only).
+         * @since v8.4.0
+         */
+        readonly headersSent: boolean;
+        /**
+         * A reference to the original HTTP2 `request` object.
+         * @since v15.7.0
+         */
+        readonly req: Request;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * applies getters, setters, and methods based on HTTP/2 logic.
+         *
+         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
+         * set on `response.stream`.
+         *
+         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.
+         *
+         * `setTimeout` method will be called on `response.stream.session`.
+         *
+         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
+         * more information.
+         *
+         * All other interactions will be routed directly to the socket.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer((req, res) => {
+         *   const ip = req.socket.remoteAddress;
+         *   const port = req.socket.remotePort;
+         *   res.end(`Your IP address is ${ip} and your source port is ${port}.`);
+         * }).listen(3000);
+         * ```
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * The `Http2Stream` object backing the response.
+         * @since v8.4.0
+         */
+        readonly stream: ServerHttp2Stream;
+        /**
+         * When true, the Date header will be automatically generated and sent in
+         * the response if it is not already present in the headers. Defaults to true.
+         *
+         * This should only be disabled for testing; HTTP requires the Date header
+         * in responses.
+         * @since v8.4.0
+         */
+        sendDate: boolean;
+        /**
+         * When using implicit headers (not calling `response.writeHead()` explicitly),
+         * this property controls the status code that will be sent to the client when
+         * the headers get flushed.
+         *
+         * ```js
+         * response.statusCode = 404;
+         * ```
+         *
+         * After response header was sent to the client, this property indicates the
+         * status code which was sent out.
+         * @since v8.4.0
+         */
+        statusCode: number;
+        /**
+         * Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
+         * an empty string.
+         * @since v8.4.0
+         */
+        statusMessage: "";
+        /**
+         * This method adds HTTP trailing headers (a header but at the end of the
+         * message) to the response.
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         * @since v8.4.0
+         */
+        addTrailers(trailers: OutgoingHttpHeaders): void;
+        /**
+         * This method signals to the server that all of the response headers and body
+         * have been sent; that server should consider this message complete.
+         * The method, `response.end()`, MUST be called on each response.
+         *
+         * If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.
+         *
+         * If `callback` is specified, it will be called when the response stream
+         * is finished.
+         * @since v8.4.0
+         */
+        end(callback?: () => void): this;
+        end(data: string | Uint8Array, callback?: () => void): this;
+        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;
+        /**
+         * Reads out a header that has already been queued but not sent to the client.
+         * The name is case-insensitive.
+         *
+         * ```js
+         * const contentType = response.getHeader('content-type');
+         * ```
+         * @since v8.4.0
+         */
+        getHeader(name: string): string;
+        /**
+         * Returns an array containing the unique names of the current outgoing headers.
+         * All header names are lowercase.
+         *
+         * ```js
+         * response.setHeader('Foo', 'bar');
+         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
+         *
+         * const headerNames = response.getHeaderNames();
+         * // headerNames === ['foo', 'set-cookie']
+         * ```
+         * @since v8.4.0
+         */
+        getHeaderNames(): string[];
+        /**
+         * Returns a shallow copy of the current outgoing headers. Since a shallow copy
+         * is used, array values may be mutated without additional calls to various
+         * header-related http module methods. The keys of the returned object are the
+         * header names and the values are the respective header values. All header names
+         * are lowercase.
+         *
+         * The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
+         * `obj.hasOwnProperty()`, and others
+         * are not defined and _will not work_.
+         *
+         * ```js
+         * response.setHeader('Foo', 'bar');
+         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
+         *
+         * const headers = response.getHeaders();
+         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
+         * ```
+         * @since v8.4.0
+         */
+        getHeaders(): OutgoingHttpHeaders;
+        /**
+         * Returns `true` if the header identified by `name` is currently set in the
+         * outgoing headers. The header name matching is case-insensitive.
+         *
+         * ```js
+         * const hasContentType = response.hasHeader('content-type');
+         * ```
+         * @since v8.4.0
+         */
+        hasHeader(name: string): boolean;
+        /**
+         * Removes a header that has been queued for implicit sending.
+         *
+         * ```js
+         * response.removeHeader('Content-Encoding');
+         * ```
+         * @since v8.4.0
+         */
+        removeHeader(name: string): void;
+        /**
+         * Sets a single header value for implicit headers. If this header already exists
+         * in the to-be-sent headers, its value will be replaced. Use an array of strings
+         * here to send multiple headers with the same name.
+         *
+         * ```js
+         * response.setHeader('Content-Type', 'text/html; charset=utf-8');
+         * ```
+         *
+         * or
+         *
+         * ```js
+         * response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
+         * ```
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         *
+         * When headers have been set with `response.setHeader()`, they will be merged
+         * with any headers passed to `response.writeHead()`, with the headers passed
+         * to `response.writeHead()` given precedence.
+         *
+         * ```js
+         * // Returns content-type = text/plain
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
+         *   res.setHeader('X-Foo', 'bar');
+         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
+         *   res.end('ok');
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        setHeader(name: string, value: number | string | readonly string[]): void;
+        /**
+         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
+         * provided, then it is added as a listener on the `'timeout'` event on
+         * the response object.
+         *
+         * If no `'timeout'` listener is added to the request, the response, or
+         * the server, then `Http2Stream` s are destroyed when they time out. If a
+         * handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * If this method is called and `response.writeHead()` has not been called,
+         * it will switch to implicit header mode and flush the implicit headers.
+         *
+         * This sends a chunk of the response body. This method may
+         * be called multiple times to provide successive parts of the body.
+         *
+         * In the `node:http` module, the response body is omitted when the
+         * request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.
+         *
+         * `chunk` can be a string or a buffer. If `chunk` is a string,
+         * the second parameter specifies how to encode it into a byte stream.
+         * By default the `encoding` is `'utf8'`. `callback` will be called when this chunk
+         * of data is flushed.
+         *
+         * This is the raw HTTP body and has nothing to do with higher-level multi-part
+         * body encodings that may be used.
+         *
+         * The first time `response.write()` is called, it will send the buffered
+         * header information and the first chunk of the body to the client. The second
+         * time `response.write()` is called, Node.js assumes data will be streamed,
+         * and sends the new data separately. That is, the response is buffered up to the
+         * first chunk of the body.
+         *
+         * Returns `true` if the entire data was flushed successfully to the kernel
+         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
+         * @since v8.4.0
+         */
+        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
+        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
+        /**
+         * Sends a status `100 Continue` to the client, indicating that the request body
+         * should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.
+         * @since v8.4.0
+         */
+        writeContinue(): void;
+        /**
+         * Sends a status `103 Early Hints` to the client with a Link header,
+         * indicating that the user agent can preload/preconnect the linked resources.
+         * The `hints` is an object containing the values of headers to be sent with
+         * early hints message.
+         *
+         * **Example**
+         *
+         * ```js
+         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
+         * response.writeEarlyHints({
+         *   'link': earlyHintsLink,
+         * });
+         *
+         * const earlyHintsLinks = [
+         *   '</styles.css>; rel=preload; as=style',
+         *   '</scripts.js>; rel=preload; as=script',
+         * ];
+         * response.writeEarlyHints({
+         *   'link': earlyHintsLinks,
+         * });
+         * ```
+         * @since v18.11.0
+         */
+        writeEarlyHints(hints: Record<string, string | string[]>): void;
+        /**
+         * Sends a response header to the request. The status code is a 3-digit HTTP
+         * status code, like `404`. The last argument, `headers`, are the response headers.
+         *
+         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.
+         *
+         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
+         * passed as the second argument. However, because the `statusMessage` has no
+         * meaning within HTTP/2, the argument will have no effect and a process warning
+         * will be emitted.
+         *
+         * ```js
+         * const body = 'hello world';
+         * response.writeHead(200, {
+         *   'Content-Length': Buffer.byteLength(body),
+         *   'Content-Type': 'text/plain; charset=utf-8',
+         * });
+         * ```
+         *
+         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
+         * given encoding. On outbound messages, Node.js does not check if Content-Length
+         * and the length of the body being transmitted are equal or not. However, when
+         * receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.
+         *
+         * This method may be called at most one time on a message before `response.end()` is called.
+         *
+         * If `response.write()` or `response.end()` are called before calling
+         * this, the implicit/mutable headers will be calculated and call this function.
+         *
+         * When headers have been set with `response.setHeader()`, they will be merged
+         * with any headers passed to `response.writeHead()`, with the headers passed
+         * to `response.writeHead()` given precedence.
+         *
+         * ```js
+         * // Returns content-type = text/plain
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
+         *   res.setHeader('X-Foo', 'bar');
+         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
+         *   res.end('ok');
+         * });
+         * ```
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         * @since v8.4.0
+         */
+        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
+        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
+        /**
+         * Call `http2stream.pushStream()` with the given headers, and wrap the
+         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
+         * parameter if successful. When `Http2ServerRequest` is closed, the callback is
+         * called with an error `ERR_HTTP2_INVALID_STREAM`.
+         * @since v8.4.0
+         * @param headers An object describing the headers
+         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
+         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
+         */
+        createPushResponse(
+            headers: OutgoingHttpHeaders,
+            callback: (err: Error | null, res: Http2ServerResponse) => void,
+        ): void;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "drain", listener: () => void): this;
+        addListener(event: "error", listener: (error: Error) => void): this;
+        addListener(event: "finish", listener: () => void): this;
+        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "close"): boolean;
+        emit(event: "drain"): boolean;
+        emit(event: "error", error: Error): boolean;
+        emit(event: "finish"): boolean;
+        emit(event: "pipe", src: stream.Readable): boolean;
+        emit(event: "unpipe", src: stream.Readable): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "close", listener: () => void): this;
+        on(event: "drain", listener: () => void): this;
+        on(event: "error", listener: (error: Error) => void): this;
+        on(event: "finish", listener: () => void): this;
+        on(event: "pipe", listener: (src: stream.Readable) => void): this;
+        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "drain", listener: () => void): this;
+        once(event: "error", listener: (error: Error) => void): this;
+        once(event: "finish", listener: () => void): this;
+        once(event: "pipe", listener: (src: stream.Readable) => void): this;
+        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "drain", listener: () => void): this;
+        prependListener(event: "error", listener: (error: Error) => void): this;
+        prependListener(event: "finish", listener: () => void): this;
+        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "drain", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (error: Error) => void): this;
+        prependOnceListener(event: "finish", listener: () => void): this;
+        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export namespace constants {
+        const NGHTTP2_SESSION_SERVER: number;
+        const NGHTTP2_SESSION_CLIENT: number;
+        const NGHTTP2_STREAM_STATE_IDLE: number;
+        const NGHTTP2_STREAM_STATE_OPEN: number;
+        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
+        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
+        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
+        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
+        const NGHTTP2_STREAM_STATE_CLOSED: number;
+        const NGHTTP2_NO_ERROR: number;
+        const NGHTTP2_PROTOCOL_ERROR: number;
+        const NGHTTP2_INTERNAL_ERROR: number;
+        const NGHTTP2_FLOW_CONTROL_ERROR: number;
+        const NGHTTP2_SETTINGS_TIMEOUT: number;
+        const NGHTTP2_STREAM_CLOSED: number;
+        const NGHTTP2_FRAME_SIZE_ERROR: number;
+        const NGHTTP2_REFUSED_STREAM: number;
+        const NGHTTP2_CANCEL: number;
+        const NGHTTP2_COMPRESSION_ERROR: number;
+        const NGHTTP2_CONNECT_ERROR: number;
+        const NGHTTP2_ENHANCE_YOUR_CALM: number;
+        const NGHTTP2_INADEQUATE_SECURITY: number;
+        const NGHTTP2_HTTP_1_1_REQUIRED: number;
+        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
+        const NGHTTP2_FLAG_NONE: number;
+        const NGHTTP2_FLAG_END_STREAM: number;
+        const NGHTTP2_FLAG_END_HEADERS: number;
+        const NGHTTP2_FLAG_ACK: number;
+        const NGHTTP2_FLAG_PADDED: number;
+        const NGHTTP2_FLAG_PRIORITY: number;
+        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
+        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
+        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
+        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
+        const MAX_MAX_FRAME_SIZE: number;
+        const MIN_MAX_FRAME_SIZE: number;
+        const MAX_INITIAL_WINDOW_SIZE: number;
+        const NGHTTP2_DEFAULT_WEIGHT: number;
+        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
+        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
+        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
+        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
+        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
+        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
+        const PADDING_STRATEGY_NONE: number;
+        const PADDING_STRATEGY_MAX: number;
+        const PADDING_STRATEGY_CALLBACK: number;
+        const HTTP2_HEADER_STATUS: string;
+        const HTTP2_HEADER_METHOD: string;
+        const HTTP2_HEADER_AUTHORITY: string;
+        const HTTP2_HEADER_SCHEME: string;
+        const HTTP2_HEADER_PATH: string;
+        const HTTP2_HEADER_ACCEPT_CHARSET: string;
+        const HTTP2_HEADER_ACCEPT_ENCODING: string;
+        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
+        const HTTP2_HEADER_ACCEPT_RANGES: string;
+        const HTTP2_HEADER_ACCEPT: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;
+        const HTTP2_HEADER_AGE: string;
+        const HTTP2_HEADER_ALLOW: string;
+        const HTTP2_HEADER_AUTHORIZATION: string;
+        const HTTP2_HEADER_CACHE_CONTROL: string;
+        const HTTP2_HEADER_CONNECTION: string;
+        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
+        const HTTP2_HEADER_CONTENT_ENCODING: string;
+        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
+        const HTTP2_HEADER_CONTENT_LENGTH: string;
+        const HTTP2_HEADER_CONTENT_LOCATION: string;
+        const HTTP2_HEADER_CONTENT_MD5: string;
+        const HTTP2_HEADER_CONTENT_RANGE: string;
+        const HTTP2_HEADER_CONTENT_TYPE: string;
+        const HTTP2_HEADER_COOKIE: string;
+        const HTTP2_HEADER_DATE: string;
+        const HTTP2_HEADER_ETAG: string;
+        const HTTP2_HEADER_EXPECT: string;
+        const HTTP2_HEADER_EXPIRES: string;
+        const HTTP2_HEADER_FROM: string;
+        const HTTP2_HEADER_HOST: string;
+        const HTTP2_HEADER_IF_MATCH: string;
+        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
+        const HTTP2_HEADER_IF_NONE_MATCH: string;
+        const HTTP2_HEADER_IF_RANGE: string;
+        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
+        const HTTP2_HEADER_LAST_MODIFIED: string;
+        const HTTP2_HEADER_LINK: string;
+        const HTTP2_HEADER_LOCATION: string;
+        const HTTP2_HEADER_MAX_FORWARDS: string;
+        const HTTP2_HEADER_PREFER: string;
+        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
+        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
+        const HTTP2_HEADER_RANGE: string;
+        const HTTP2_HEADER_REFERER: string;
+        const HTTP2_HEADER_REFRESH: string;
+        const HTTP2_HEADER_RETRY_AFTER: string;
+        const HTTP2_HEADER_SERVER: string;
+        const HTTP2_HEADER_SET_COOKIE: string;
+        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
+        const HTTP2_HEADER_TRANSFER_ENCODING: string;
+        const HTTP2_HEADER_TE: string;
+        const HTTP2_HEADER_UPGRADE: string;
+        const HTTP2_HEADER_USER_AGENT: string;
+        const HTTP2_HEADER_VARY: string;
+        const HTTP2_HEADER_VIA: string;
+        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
+        const HTTP2_HEADER_HTTP2_SETTINGS: string;
+        const HTTP2_HEADER_KEEP_ALIVE: string;
+        const HTTP2_HEADER_PROXY_CONNECTION: string;
+        const HTTP2_METHOD_ACL: string;
+        const HTTP2_METHOD_BASELINE_CONTROL: string;
+        const HTTP2_METHOD_BIND: string;
+        const HTTP2_METHOD_CHECKIN: string;
+        const HTTP2_METHOD_CHECKOUT: string;
+        const HTTP2_METHOD_CONNECT: string;
+        const HTTP2_METHOD_COPY: string;
+        const HTTP2_METHOD_DELETE: string;
+        const HTTP2_METHOD_GET: string;
+        const HTTP2_METHOD_HEAD: string;
+        const HTTP2_METHOD_LABEL: string;
+        const HTTP2_METHOD_LINK: string;
+        const HTTP2_METHOD_LOCK: string;
+        const HTTP2_METHOD_MERGE: string;
+        const HTTP2_METHOD_MKACTIVITY: string;
+        const HTTP2_METHOD_MKCALENDAR: string;
+        const HTTP2_METHOD_MKCOL: string;
+        const HTTP2_METHOD_MKREDIRECTREF: string;
+        const HTTP2_METHOD_MKWORKSPACE: string;
+        const HTTP2_METHOD_MOVE: string;
+        const HTTP2_METHOD_OPTIONS: string;
+        const HTTP2_METHOD_ORDERPATCH: string;
+        const HTTP2_METHOD_PATCH: string;
+        const HTTP2_METHOD_POST: string;
+        const HTTP2_METHOD_PRI: string;
+        const HTTP2_METHOD_PROPFIND: string;
+        const HTTP2_METHOD_PROPPATCH: string;
+        const HTTP2_METHOD_PUT: string;
+        const HTTP2_METHOD_REBIND: string;
+        const HTTP2_METHOD_REPORT: string;
+        const HTTP2_METHOD_SEARCH: string;
+        const HTTP2_METHOD_TRACE: string;
+        const HTTP2_METHOD_UNBIND: string;
+        const HTTP2_METHOD_UNCHECKOUT: string;
+        const HTTP2_METHOD_UNLINK: string;
+        const HTTP2_METHOD_UNLOCK: string;
+        const HTTP2_METHOD_UPDATE: string;
+        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
+        const HTTP2_METHOD_VERSION_CONTROL: string;
+        const HTTP_STATUS_CONTINUE: number;
+        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
+        const HTTP_STATUS_PROCESSING: number;
+        const HTTP_STATUS_OK: number;
+        const HTTP_STATUS_CREATED: number;
+        const HTTP_STATUS_ACCEPTED: number;
+        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
+        const HTTP_STATUS_NO_CONTENT: number;
+        const HTTP_STATUS_RESET_CONTENT: number;
+        const HTTP_STATUS_PARTIAL_CONTENT: number;
+        const HTTP_STATUS_MULTI_STATUS: number;
+        const HTTP_STATUS_ALREADY_REPORTED: number;
+        const HTTP_STATUS_IM_USED: number;
+        const HTTP_STATUS_MULTIPLE_CHOICES: number;
+        const HTTP_STATUS_MOVED_PERMANENTLY: number;
+        const HTTP_STATUS_FOUND: number;
+        const HTTP_STATUS_SEE_OTHER: number;
+        const HTTP_STATUS_NOT_MODIFIED: number;
+        const HTTP_STATUS_USE_PROXY: number;
+        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
+        const HTTP_STATUS_PERMANENT_REDIRECT: number;
+        const HTTP_STATUS_BAD_REQUEST: number;
+        const HTTP_STATUS_UNAUTHORIZED: number;
+        const HTTP_STATUS_PAYMENT_REQUIRED: number;
+        const HTTP_STATUS_FORBIDDEN: number;
+        const HTTP_STATUS_NOT_FOUND: number;
+        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
+        const HTTP_STATUS_NOT_ACCEPTABLE: number;
+        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
+        const HTTP_STATUS_REQUEST_TIMEOUT: number;
+        const HTTP_STATUS_CONFLICT: number;
+        const HTTP_STATUS_GONE: number;
+        const HTTP_STATUS_LENGTH_REQUIRED: number;
+        const HTTP_STATUS_PRECONDITION_FAILED: number;
+        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
+        const HTTP_STATUS_URI_TOO_LONG: number;
+        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
+        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
+        const HTTP_STATUS_EXPECTATION_FAILED: number;
+        const HTTP_STATUS_TEAPOT: number;
+        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
+        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
+        const HTTP_STATUS_LOCKED: number;
+        const HTTP_STATUS_FAILED_DEPENDENCY: number;
+        const HTTP_STATUS_UNORDERED_COLLECTION: number;
+        const HTTP_STATUS_UPGRADE_REQUIRED: number;
+        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
+        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
+        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
+        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
+        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
+        const HTTP_STATUS_NOT_IMPLEMENTED: number;
+        const HTTP_STATUS_BAD_GATEWAY: number;
+        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
+        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
+        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
+        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
+        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
+        const HTTP_STATUS_LOOP_DETECTED: number;
+        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
+        const HTTP_STATUS_NOT_EXTENDED: number;
+        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
+    }
+    /**
+     * This symbol can be set as a property on the HTTP/2 headers object with
+     * an array value in order to provide a list of headers considered sensitive.
+     */
+    export const sensitiveHeaders: symbol;
+    /**
+     * Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called
+     * so instances returned may be safely modified for use.
+     * @since v8.4.0
+     */
+    export function getDefaultSettings(): Settings;
+    /**
+     * Returns a `Buffer` instance containing serialized representation of the given
+     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
+     * for use with the `HTTP2-Settings` header field.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     *
+     * const packed = http2.getPackedSettings({ enablePush: false });
+     *
+     * console.log(packed.toString('base64'));
+     * // Prints: AAIAAAAA
+     * ```
+     * @since v8.4.0
+     */
+    export function getPackedSettings(settings: Settings): Buffer;
+    /**
+     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
+     * the given `Buffer` as generated by `http2.getPackedSettings()`.
+     * @since v8.4.0
+     * @param buf The packed settings.
+     */
+    export function getUnpackedSettings(buf: Uint8Array): Settings;
+    /**
+     * Returns a `net.Server` instance that creates and manages `Http2Session` instances.
+     *
+     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
+     * communicating
+     * with browser clients.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     *
+     * // Create an unencrypted HTTP/2 server.
+     * // Since there are no browsers known that support
+     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
+     * // is necessary when communicating with browser clients.
+     * const server = http2.createServer();
+     *
+     * server.on('stream', (stream, headers) => {
+     *   stream.respond({
+     *     'content-type': 'text/html; charset=utf-8',
+     *     ':status': 200,
+     *   });
+     *   stream.end('<h1>Hello World</h1>');
+     * });
+     *
+     * server.listen(8000);
+     * ```
+     * @since v8.4.0
+     * @param onRequestHandler See `Compatibility API`
+     */
+    export function createServer(
+        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
+    ): Http2Server;
+    export function createServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        options: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+    ): Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;
+    /**
+     * Returns a `tls.Server` instance that creates and manages `Http2Session` instances.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     * import fs from 'node:fs';
+     *
+     * const options = {
+     *   key: fs.readFileSync('server-key.pem'),
+     *   cert: fs.readFileSync('server-cert.pem'),
+     * };
+     *
+     * // Create a secure HTTP/2 server
+     * const server = http2.createSecureServer(options);
+     *
+     * server.on('stream', (stream, headers) => {
+     *   stream.respond({
+     *     'content-type': 'text/html; charset=utf-8',
+     *     ':status': 200,
+     *   });
+     *   stream.end('<h1>Hello World</h1>');
+     * });
+     *
+     * server.listen(8443);
+     * ```
+     * @since v8.4.0
+     * @param onRequestHandler See `Compatibility API`
+     */
+    export function createSecureServer(
+        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
+    ): Http2SecureServer;
+    export function createSecureServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        options: SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+    ): Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
+    /**
+     * Returns a `ClientHttp2Session` instance.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     * const client = http2.connect('https://localhost:1234');
+     *
+     * // Use the client
+     *
+     * client.close();
+     * ```
+     * @since v8.4.0
+     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
+     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
+     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
+     */
+    export function connect(
+        authority: string | url.URL,
+        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+    ): ClientHttp2Session;
+    export function connect(
+        authority: string | url.URL,
+        options?: ClientSessionOptions | SecureClientSessionOptions,
+        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+    ): ClientHttp2Session;
+    /**
+     * Create an HTTP/2 server session from an existing socket.
+     * @param socket A Duplex Stream
+     * @param options Any `{@link createServer}` options can be provided.
+     * @since v20.12.0
+     */
+    export function performServerHandshake<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        socket: stream.Duplex,
+        options?: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+    ): ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
+}
+declare module "node:http2" {
+    export * from "http2";
+}
diff -ruN .cache/node/package.json types/node/package.json
--- .cache/node/package.json	2025-06-26 21:45:46.975210715 +0000
+++ types/node/package.json	2025-06-26 21:45:45.738225787 +0000
@@ -1,8 +1,8 @@
 {
-    "name": "@types/node",
+    "name": "@types-with-exceptions/node",
     "version": "24.0.4",
-    "description": "TypeScript definitions for node",
-    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
+    "description": "TypeScript definitions with exceptions for node",
+    "homepage": "https://github.com/Xvezda/types-with-exceptions/tree/main/types/node",
     "license": "MIT",
     "contributors": [
         {
@@ -199,6 +199,11 @@
             "name": "René",
             "githubUsername": "Renegade334",
             "url": "https://github.com/Renegade334"
+        },
+        {
+            "name": "Xvezda",
+            "githubUsername": "Xvezda",
+            "url": "https://github.com/Xvezda"
         }
     ],
     "main": "",
@@ -222,7 +227,7 @@
     },
     "repository": {
         "type": "git",
-        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
+        "url": "https://github.com/Xvezda/types-with-exceptions.git",
         "directory": "types/node"
     },
     "scripts": {},
@@ -232,4 +237,4 @@
     "peerDependencies": {},
     "typesPublisherContentHash": "f9e3c8097c627227b80629b4332d37093a1127e7391935d57c7005db57159523",
     "typeScriptVersion": "5.1"
-}
\ No newline at end of file
+}
diff -ruN .cache/node/package.json.orig types/node/package.json.orig
--- .cache/node/package.json.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/package.json.orig	2025-06-26 21:45:45.739225775 +0000
@@ -0,0 +1,235 @@
+{
+    "name": "@types/node",
+    "version": "24.0.4",
+    "description": "TypeScript definitions for node",
+    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
+    "license": "MIT",
+    "contributors": [
+        {
+            "name": "Microsoft TypeScript",
+            "githubUsername": "Microsoft",
+            "url": "https://github.com/Microsoft"
+        },
+        {
+            "name": "Alberto Schiabel",
+            "githubUsername": "jkomyno",
+            "url": "https://github.com/jkomyno"
+        },
+        {
+            "name": "Alvis HT Tang",
+            "githubUsername": "alvis",
+            "url": "https://github.com/alvis"
+        },
+        {
+            "name": "Andrew Makarov",
+            "githubUsername": "r3nya",
+            "url": "https://github.com/r3nya"
+        },
+        {
+            "name": "Benjamin Toueg",
+            "githubUsername": "btoueg",
+            "url": "https://github.com/btoueg"
+        },
+        {
+            "name": "Chigozirim C.",
+            "githubUsername": "smac89",
+            "url": "https://github.com/smac89"
+        },
+        {
+            "name": "David Junger",
+            "githubUsername": "touffy",
+            "url": "https://github.com/touffy"
+        },
+        {
+            "name": "Deividas Bakanas",
+            "githubUsername": "DeividasBakanas",
+            "url": "https://github.com/DeividasBakanas"
+        },
+        {
+            "name": "Eugene Y. Q. Shen",
+            "githubUsername": "eyqs",
+            "url": "https://github.com/eyqs"
+        },
+        {
+            "name": "Hannes Magnusson",
+            "githubUsername": "Hannes-Magnusson-CK",
+            "url": "https://github.com/Hannes-Magnusson-CK"
+        },
+        {
+            "name": "Huw",
+            "githubUsername": "hoo29",
+            "url": "https://github.com/hoo29"
+        },
+        {
+            "name": "Kelvin Jin",
+            "githubUsername": "kjin",
+            "url": "https://github.com/kjin"
+        },
+        {
+            "name": "Klaus Meinhardt",
+            "githubUsername": "ajafff",
+            "url": "https://github.com/ajafff"
+        },
+        {
+            "name": "Lishude",
+            "githubUsername": "islishude",
+            "url": "https://github.com/islishude"
+        },
+        {
+            "name": "Mariusz Wiktorczyk",
+            "githubUsername": "mwiktorczyk",
+            "url": "https://github.com/mwiktorczyk"
+        },
+        {
+            "name": "Mohsen Azimi",
+            "githubUsername": "mohsen1",
+            "url": "https://github.com/mohsen1"
+        },
+        {
+            "name": "Nikita Galkin",
+            "githubUsername": "galkin",
+            "url": "https://github.com/galkin"
+        },
+        {
+            "name": "Parambir Singh",
+            "githubUsername": "parambirs",
+            "url": "https://github.com/parambirs"
+        },
+        {
+            "name": "Sebastian Silbermann",
+            "githubUsername": "eps1lon",
+            "url": "https://github.com/eps1lon"
+        },
+        {
+            "name": "Thomas den Hollander",
+            "githubUsername": "ThomasdenH",
+            "url": "https://github.com/ThomasdenH"
+        },
+        {
+            "name": "Wilco Bakker",
+            "githubUsername": "WilcoBakker",
+            "url": "https://github.com/WilcoBakker"
+        },
+        {
+            "name": "wwwy3y3",
+            "githubUsername": "wwwy3y3",
+            "url": "https://github.com/wwwy3y3"
+        },
+        {
+            "name": "Samuel Ainsworth",
+            "githubUsername": "samuela",
+            "url": "https://github.com/samuela"
+        },
+        {
+            "name": "Kyle Uehlein",
+            "githubUsername": "kuehlein",
+            "url": "https://github.com/kuehlein"
+        },
+        {
+            "name": "Thanik Bhongbhibhat",
+            "githubUsername": "bhongy",
+            "url": "https://github.com/bhongy"
+        },
+        {
+            "name": "Marcin Kopacz",
+            "githubUsername": "chyzwar",
+            "url": "https://github.com/chyzwar"
+        },
+        {
+            "name": "Trivikram Kamat",
+            "githubUsername": "trivikr",
+            "url": "https://github.com/trivikr"
+        },
+        {
+            "name": "Junxiao Shi",
+            "githubUsername": "yoursunny",
+            "url": "https://github.com/yoursunny"
+        },
+        {
+            "name": "Ilia Baryshnikov",
+            "githubUsername": "qwelias",
+            "url": "https://github.com/qwelias"
+        },
+        {
+            "name": "ExE Boss",
+            "githubUsername": "ExE-Boss",
+            "url": "https://github.com/ExE-Boss"
+        },
+        {
+            "name": "Piotr Błażejewicz",
+            "githubUsername": "peterblazejewicz",
+            "url": "https://github.com/peterblazejewicz"
+        },
+        {
+            "name": "Anna Henningsen",
+            "githubUsername": "addaleax",
+            "url": "https://github.com/addaleax"
+        },
+        {
+            "name": "Victor Perin",
+            "githubUsername": "victorperin",
+            "url": "https://github.com/victorperin"
+        },
+        {
+            "name": "NodeJS Contributors",
+            "githubUsername": "NodeJS",
+            "url": "https://github.com/NodeJS"
+        },
+        {
+            "name": "Linus Unnebäck",
+            "githubUsername": "LinusU",
+            "url": "https://github.com/LinusU"
+        },
+        {
+            "name": "wafuwafu13",
+            "githubUsername": "wafuwafu13",
+            "url": "https://github.com/wafuwafu13"
+        },
+        {
+            "name": "Matteo Collina",
+            "githubUsername": "mcollina",
+            "url": "https://github.com/mcollina"
+        },
+        {
+            "name": "Dmitry Semigradsky",
+            "githubUsername": "Semigradsky",
+            "url": "https://github.com/Semigradsky"
+        },
+        {
+            "name": "René",
+            "githubUsername": "Renegade334",
+            "url": "https://github.com/Renegade334"
+        }
+    ],
+    "main": "",
+    "types": "index.d.ts",
+    "typesVersions": {
+        "<=5.1": {
+            "*": [
+                "ts5.1/*"
+            ]
+        },
+        "<=5.6": {
+            "*": [
+                "ts5.6/*"
+            ]
+        },
+        "<=5.7": {
+            "*": [
+                "ts5.7/*"
+            ]
+        }
+    },
+    "repository": {
+        "type": "git",
+        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
+        "directory": "types/node"
+    },
+    "scripts": {},
+    "dependencies": {
+        "undici-types": "~7.8.0"
+    },
+    "peerDependencies": {},
+    "typesPublisherContentHash": "f9e3c8097c627227b80629b4332d37093a1127e7391935d57c7005db57159523",
+    "typeScriptVersion": "5.1"
+}
\ No newline at end of file
diff -ruN .cache/node/package.json.rej types/node/package.json.rej
--- .cache/node/package.json.rej	1970-01-01 00:00:00.000000000 +0000
+++ types/node/package.json.rej	2025-06-26 21:45:45.739225775 +0000
@@ -0,0 +1,23 @@
+@@ -1,8 +1,8 @@
+ {
+-    "name": "@types/node",
+-    "version": "22.15.30",
+-    "description": "TypeScript definitions for node",
+-    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
++    "name": "@types-with-exceptions/node",
++    "version": "22.15.29",
++    "description": "TypeScript definitions with exceptions for node",
++    "homepage": "https://github.com/Xvezda/types-with-exceptions/tree/main/types/node",
+     "license": "MIT",
+     "contributors": [
+         {
+@@ -230,6 +235,6 @@
+         "undici-types": "~6.21.0"
+     },
+     "peerDependencies": {},
+-    "typesPublisherContentHash": "e608b189ccd6623034719d736dfcdaf6bae11f1e8fe989b19c4a6d3221277a64",
++    "typesPublisherContentHash": "98b7a6aabffc6588a0865305b51b9dd48e81a270354b592630e8d37772f1f57a",
+     "typeScriptVersion": "5.1"
+-}
+\ No newline at end of line
++}
diff -ruN .cache/node/util.d.ts types/node/util.d.ts
--- .cache/node/util.d.ts	2025-06-26 21:45:46.968210800 +0000
+++ types/node/util.d.ts	2025-06-26 21:45:45.739225775 +0000
@@ -1121,7 +1121,7 @@
      * @param content The raw contents of a `.env` file.
      * @since v20.12.0
      */
-    export function parseEnv(content: string): NodeJS.Dict<string>;
+    export function parseEnv(content: string): object;
     // https://nodejs.org/docs/latest/api/util.html#foreground-colors
     type ForegroundColors =
         | "black"
diff -ruN .cache/node/util.d.ts.orig types/node/util.d.ts.orig
--- .cache/node/util.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/util.d.ts.orig	2025-06-26 21:45:45.740225762 +0000
@@ -0,0 +1,2305 @@
+/**
+ * The `node:util` module supports the needs of Node.js internal APIs. Many of the
+ * utilities are useful for application and module developers as well. To access
+ * it:
+ *
+ * ```js
+ * import util from 'node:util';
+ * ```
+ * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/util.js)
+ */
+declare module "util" {
+    import * as types from "node:util/types";
+    export interface InspectOptions {
+        /**
+         * If `true`, object's non-enumerable symbols and properties are included in the formatted result.
+         * `WeakMap` and `WeakSet` entries are also included as well as user defined prototype properties (excluding method properties).
+         * @default false
+         */
+        showHidden?: boolean | undefined;
+        /**
+         * Specifies the number of times to recurse while formatting object.
+         * This is useful for inspecting large objects.
+         * To recurse up to the maximum call stack size pass `Infinity` or `null`.
+         * @default 2
+         */
+        depth?: number | null | undefined;
+        /**
+         * If `true`, the output is styled with ANSI color codes. Colors are customizable.
+         */
+        colors?: boolean | undefined;
+        /**
+         * If `false`, `[util.inspect.custom](depth, opts, inspect)` functions are not invoked.
+         * @default true
+         */
+        customInspect?: boolean | undefined;
+        /**
+         * If `true`, `Proxy` inspection includes the target and handler objects.
+         * @default false
+         */
+        showProxy?: boolean | undefined;
+        /**
+         * Specifies the maximum number of `Array`, `TypedArray`, `WeakMap`, and `WeakSet` elements
+         * to include when formatting. Set to `null` or `Infinity` to show all elements.
+         * Set to `0` or negative to show no elements.
+         * @default 100
+         */
+        maxArrayLength?: number | null | undefined;
+        /**
+         * Specifies the maximum number of characters to
+         * include when formatting. Set to `null` or `Infinity` to show all elements.
+         * Set to `0` or negative to show no characters.
+         * @default 10000
+         */
+        maxStringLength?: number | null | undefined;
+        /**
+         * The length at which input values are split across multiple lines.
+         * Set to `Infinity` to format the input as a single line
+         * (in combination with `compact` set to `true` or any number >= `1`).
+         * @default 80
+         */
+        breakLength?: number | undefined;
+        /**
+         * Setting this to `false` causes each object key
+         * to be displayed on a new line. It will also add new lines to text that is
+         * longer than `breakLength`. If set to a number, the most `n` inner elements
+         * are united on a single line as long as all properties fit into
+         * `breakLength`. Short array elements are also grouped together. Note that no
+         * text will be reduced below 16 characters, no matter the `breakLength` size.
+         * For more information, see the example below.
+         * @default true
+         */
+        compact?: boolean | number | undefined;
+        /**
+         * If set to `true` or a function, all properties of an object, and `Set` and `Map`
+         * entries are sorted in the resulting string.
+         * If set to `true` the default sort is used.
+         * If set to a function, it is used as a compare function.
+         */
+        sorted?: boolean | ((a: string, b: string) => number) | undefined;
+        /**
+         * If set to `true`, getters are going to be
+         * inspected as well. If set to `'get'` only getters without setter are going
+         * to be inspected. If set to `'set'` only getters having a corresponding
+         * setter are going to be inspected. This might cause side effects depending on
+         * the getter function.
+         * @default false
+         */
+        getters?: "get" | "set" | boolean | undefined;
+        /**
+         * If set to `true`, an underscore is used to separate every three digits in all bigints and numbers.
+         * @default false
+         */
+        numericSeparator?: boolean | undefined;
+    }
+    export type Style =
+        | "special"
+        | "number"
+        | "bigint"
+        | "boolean"
+        | "undefined"
+        | "null"
+        | "string"
+        | "symbol"
+        | "date"
+        | "regexp"
+        | "module";
+    export type CustomInspectFunction = (depth: number, options: InspectOptionsStylized) => any; // TODO: , inspect: inspect
+    export interface InspectOptionsStylized extends InspectOptions {
+        stylize(text: string, styleType: Style): string;
+    }
+    export interface CallSiteObject {
+        /**
+         * Returns the name of the function associated with this call site.
+         */
+        functionName: string;
+        /**
+         * Returns the name of the resource that contains the script for the
+         * function for this call site.
+         */
+        scriptName: string;
+        /**
+         * Returns the unique id of the script, as in Chrome DevTools protocol
+         * [`Runtime.ScriptId`](https://chromedevtools.github.io/devtools-protocol/1-3/Runtime/#type-ScriptId).
+         * @since v22.14.0
+         */
+        scriptId: string;
+        /**
+         * Returns the number, 1-based, of the line for the associate function call.
+         */
+        lineNumber: number;
+        /**
+         * Returns the 1-based column offset on the line for the associated function call.
+         */
+        columnNumber: number;
+    }
+    export type DiffEntry = [operation: -1 | 0 | 1, value: string];
+    /**
+     * `util.diff()` compares two string or array values and returns an array of difference entries.
+     * It uses the Myers diff algorithm to compute minimal differences, which is the same algorithm
+     * used internally by assertion error messages.
+     *
+     * If the values are equal, an empty array is returned.
+     *
+     * ```js
+     * const { diff } = require('node:util');
+     *
+     * // Comparing strings
+     * const actualString = '12345678';
+     * const expectedString = '12!!5!7!';
+     * console.log(diff(actualString, expectedString));
+     * // [
+     * //   [0, '1'],
+     * //   [0, '2'],
+     * //   [1, '3'],
+     * //   [1, '4'],
+     * //   [-1, '!'],
+     * //   [-1, '!'],
+     * //   [0, '5'],
+     * //   [1, '6'],
+     * //   [-1, '!'],
+     * //   [0, '7'],
+     * //   [1, '8'],
+     * //   [-1, '!'],
+     * // ]
+     * // Comparing arrays
+     * const actualArray = ['1', '2', '3'];
+     * const expectedArray = ['1', '3', '4'];
+     * console.log(diff(actualArray, expectedArray));
+     * // [
+     * //   [0, '1'],
+     * //   [1, '2'],
+     * //   [0, '3'],
+     * //   [-1, '4'],
+     * // ]
+     * // Equal values return empty array
+     * console.log(diff('same', 'same'));
+     * // []
+     * ```
+     * @since v22.15.0
+     * @experimental
+     * @param actual The first value to compare
+     * @param expected The second value to compare
+     * @returns An array of difference entries. Each entry is an array with two elements:
+     * * Index 0: `number` Operation code: `-1` for delete, `0` for no-op/unchanged, `1` for insert
+     * * Index 1: `string` The value associated with the operation
+     */
+    export function diff(actual: string | readonly string[], expected: string | readonly string[]): DiffEntry[];
+    /**
+     * The `util.format()` method returns a formatted string using the first argument
+     * as a `printf`-like format string which can contain zero or more format
+     * specifiers. Each specifier is replaced with the converted value from the
+     * corresponding argument. Supported specifiers are:
+     *
+     * If a specifier does not have a corresponding argument, it is not replaced:
+     *
+     * ```js
+     * util.format('%s:%s', 'foo');
+     * // Returns: 'foo:%s'
+     * ```
+     *
+     * Values that are not part of the format string are formatted using `util.inspect()` if their type is not `string`.
+     *
+     * If there are more arguments passed to the `util.format()` method than the
+     * number of specifiers, the extra arguments are concatenated to the returned
+     * string, separated by spaces:
+     *
+     * ```js
+     * util.format('%s:%s', 'foo', 'bar', 'baz');
+     * // Returns: 'foo:bar baz'
+     * ```
+     *
+     * If the first argument does not contain a valid format specifier, `util.format()` returns a string that is the concatenation of all arguments separated by spaces:
+     *
+     * ```js
+     * util.format(1, 2, 3);
+     * // Returns: '1 2 3'
+     * ```
+     *
+     * If only one argument is passed to `util.format()`, it is returned as it is
+     * without any formatting:
+     *
+     * ```js
+     * util.format('%% %s');
+     * // Returns: '%% %s'
+     * ```
+     *
+     * `util.format()` is a synchronous method that is intended as a debugging tool.
+     * Some input values can have a significant performance overhead that can block the
+     * event loop. Use this function with care and never in a hot code path.
+     * @since v0.5.3
+     * @param format A `printf`-like format string.
+     */
+    export function format(format?: any, ...param: any[]): string;
+    /**
+     * This function is identical to {@link format}, except in that it takes
+     * an `inspectOptions` argument which specifies options that are passed along to {@link inspect}.
+     *
+     * ```js
+     * util.formatWithOptions({ colors: true }, 'See object %O', { foo: 42 });
+     * // Returns 'See object { foo: 42 }', where `42` is colored as a number
+     * // when printed to a terminal.
+     * ```
+     * @since v10.0.0
+     */
+    export function formatWithOptions(inspectOptions: InspectOptions, format?: any, ...param: any[]): string;
+    interface GetCallSitesOptions {
+        /**
+         * Reconstruct the original location in the stacktrace from the source-map.
+         * Enabled by default with the flag `--enable-source-maps`.
+         */
+        sourceMap?: boolean | undefined;
+    }
+    /**
+     * Returns an array of call site objects containing the stack of
+     * the caller function.
+     *
+     * ```js
+     * import { getCallSites } from 'node:util';
+     *
+     * function exampleFunction() {
+     *   const callSites = getCallSites();
+     *
+     *   console.log('Call Sites:');
+     *   callSites.forEach((callSite, index) => {
+     *     console.log(`CallSite ${index + 1}:`);
+     *     console.log(`Function Name: ${callSite.functionName}`);
+     *     console.log(`Script Name: ${callSite.scriptName}`);
+     *     console.log(`Line Number: ${callSite.lineNumber}`);
+     *     console.log(`Column Number: ${callSite.column}`);
+     *   });
+     *   // CallSite 1:
+     *   // Function Name: exampleFunction
+     *   // Script Name: /home/example.js
+     *   // Line Number: 5
+     *   // Column Number: 26
+     *
+     *   // CallSite 2:
+     *   // Function Name: anotherFunction
+     *   // Script Name: /home/example.js
+     *   // Line Number: 22
+     *   // Column Number: 3
+     *
+     *   // ...
+     * }
+     *
+     * // A function to simulate another stack layer
+     * function anotherFunction() {
+     *   exampleFunction();
+     * }
+     *
+     * anotherFunction();
+     * ```
+     *
+     * It is possible to reconstruct the original locations by setting the option `sourceMap` to `true`.
+     * If the source map is not available, the original location will be the same as the current location.
+     * When the `--enable-source-maps` flag is enabled, for example when using `--experimental-transform-types`,
+     * `sourceMap` will be true by default.
+     *
+     * ```ts
+     * import { getCallSites } from 'node:util';
+     *
+     * interface Foo {
+     *   foo: string;
+     * }
+     *
+     * const callSites = getCallSites({ sourceMap: true });
+     *
+     * // With sourceMap:
+     * // Function Name: ''
+     * // Script Name: example.js
+     * // Line Number: 7
+     * // Column Number: 26
+     *
+     * // Without sourceMap:
+     * // Function Name: ''
+     * // Script Name: example.js
+     * // Line Number: 2
+     * // Column Number: 26
+     * ```
+     * @param frameCount Number of frames to capture as call site objects.
+     * **Default:** `10`. Allowable range is between 1 and 200.
+     * @return An array of call site objects
+     * @since v22.9.0
+     */
+    export function getCallSites(frameCount?: number, options?: GetCallSitesOptions): CallSiteObject[];
+    export function getCallSites(options: GetCallSitesOptions): CallSiteObject[];
+    /**
+     * Returns the string name for a numeric error code that comes from a Node.js API.
+     * The mapping between error codes and error names is platform-dependent.
+     * See `Common System Errors` for the names of common errors.
+     *
+     * ```js
+     * fs.access('file/that/does/not/exist', (err) => {
+     *   const name = util.getSystemErrorName(err.errno);
+     *   console.error(name);  // ENOENT
+     * });
+     * ```
+     * @since v9.7.0
+     */
+    export function getSystemErrorName(err: number): string;
+    /**
+     * Returns a Map of all system error codes available from the Node.js API.
+     * The mapping between error codes and error names is platform-dependent.
+     * See `Common System Errors` for the names of common errors.
+     *
+     * ```js
+     * fs.access('file/that/does/not/exist', (err) => {
+     *   const errorMap = util.getSystemErrorMap();
+     *   const name = errorMap.get(err.errno);
+     *   console.error(name);  // ENOENT
+     * });
+     * ```
+     * @since v16.0.0, v14.17.0
+     */
+    export function getSystemErrorMap(): Map<number, [string, string]>;
+    /**
+     * Returns the string message for a numeric error code that comes from a Node.js
+     * API.
+     * The mapping between error codes and string messages is platform-dependent.
+     *
+     * ```js
+     * fs.access('file/that/does/not/exist', (err) => {
+     *   const message = util.getSystemErrorMessage(err.errno);
+     *   console.error(message);  // no such file or directory
+     * });
+     * ```
+     * @since v22.12.0
+     */
+    export function getSystemErrorMessage(err: number): string;
+    /**
+     * Returns the `string` after replacing any surrogate code points
+     * (or equivalently, any unpaired surrogate code units) with the
+     * Unicode "replacement character" U+FFFD.
+     * @since v16.8.0, v14.18.0
+     */
+    export function toUSVString(string: string): string;
+    /**
+     * Creates and returns an `AbortController` instance whose `AbortSignal` is marked
+     * as transferable and can be used with `structuredClone()` or `postMessage()`.
+     * @since v18.11.0
+     * @returns A transferable AbortController
+     */
+    export function transferableAbortController(): AbortController;
+    /**
+     * Marks the given `AbortSignal` as transferable so that it can be used with`structuredClone()` and `postMessage()`.
+     *
+     * ```js
+     * const signal = transferableAbortSignal(AbortSignal.timeout(100));
+     * const channel = new MessageChannel();
+     * channel.port2.postMessage(signal, [signal]);
+     * ```
+     * @since v18.11.0
+     * @param signal The AbortSignal
+     * @returns The same AbortSignal
+     */
+    export function transferableAbortSignal(signal: AbortSignal): AbortSignal;
+    /**
+     * Listens to abort event on the provided `signal` and returns a promise that resolves when the `signal` is aborted.
+     * If `resource` is provided, it weakly references the operation's associated object,
+     * so if `resource` is garbage collected before the `signal` aborts,
+     * then returned promise shall remain pending.
+     * This prevents memory leaks in long-running or non-cancelable operations.
+     *
+     * ```js
+     * import { aborted } from 'node:util';
+     *
+     * // Obtain an object with an abortable signal, like a custom resource or operation.
+     * const dependent = obtainSomethingAbortable();
+     *
+     * // Pass `dependent` as the resource, indicating the promise should only resolve
+     * // if `dependent` is still in memory when the signal is aborted.
+     * aborted(dependent.signal, dependent).then(() => {
+     *   // This code runs when `dependent` is aborted.
+     *   console.log('Dependent resource was aborted.');
+     * });
+     *
+     * // Simulate an event that triggers the abort.
+     * dependent.on('event', () => {
+     *   dependent.abort(); // This will cause the `aborted` promise to resolve.
+     * });
+     * ```
+     * @since v19.7.0
+     * @param resource Any non-null object tied to the abortable operation and held weakly.
+     * If `resource` is garbage collected before the `signal` aborts, the promise remains pending,
+     * allowing Node.js to stop tracking it.
+     * This helps prevent memory leaks in long-running or non-cancelable operations.
+     */
+    export function aborted(signal: AbortSignal, resource: any): Promise<void>;
+    /**
+     * The `util.inspect()` method returns a string representation of `object` that is
+     * intended for debugging. The output of `util.inspect` may change at any time
+     * and should not be depended upon programmatically. Additional `options` may be
+     * passed that alter the result.
+     * `util.inspect()` will use the constructor's name and/or `@@toStringTag` to make
+     * an identifiable tag for an inspected value.
+     *
+     * ```js
+     * class Foo {
+     *   get [Symbol.toStringTag]() {
+     *     return 'bar';
+     *   }
+     * }
+     *
+     * class Bar {}
+     *
+     * const baz = Object.create(null, { [Symbol.toStringTag]: { value: 'foo' } });
+     *
+     * util.inspect(new Foo()); // 'Foo [bar] {}'
+     * util.inspect(new Bar()); // 'Bar {}'
+     * util.inspect(baz);       // '[foo] {}'
+     * ```
+     *
+     * Circular references point to their anchor by using a reference index:
+     *
+     * ```js
+     * import { inspect } from 'node:util';
+     *
+     * const obj = {};
+     * obj.a = [obj];
+     * obj.b = {};
+     * obj.b.inner = obj.b;
+     * obj.b.obj = obj;
+     *
+     * console.log(inspect(obj));
+     * // <ref *1> {
+     * //   a: [ [Circular *1] ],
+     * //   b: <ref *2> { inner: [Circular *2], obj: [Circular *1] }
+     * // }
+     * ```
+     *
+     * The following example inspects all properties of the `util` object:
+     *
+     * ```js
+     * import util from 'node:util';
+     *
+     * console.log(util.inspect(util, { showHidden: true, depth: null }));
+     * ```
+     *
+     * The following example highlights the effect of the `compact` option:
+     *
+     * ```js
+     * import { inspect } from 'node:util';
+     *
+     * const o = {
+     *   a: [1, 2, [[
+     *     'Lorem ipsum dolor sit amet,\nconsectetur adipiscing elit, sed do ' +
+     *       'eiusmod \ntempor incididunt ut labore et dolore magna aliqua.',
+     *     'test',
+     *     'foo']], 4],
+     *   b: new Map([['za', 1], ['zb', 'test']]),
+     * };
+     * console.log(inspect(o, { compact: true, depth: 5, breakLength: 80 }));
+     *
+     * // { a:
+     * //   [ 1,
+     * //     2,
+     * //     [ [ 'Lorem ipsum dolor sit amet,\nconsectetur [...]', // A long line
+     * //           'test',
+     * //           'foo' ] ],
+     * //     4 ],
+     * //   b: Map(2) { 'za' => 1, 'zb' => 'test' } }
+     *
+     * // Setting `compact` to false or an integer creates more reader friendly output.
+     * console.log(inspect(o, { compact: false, depth: 5, breakLength: 80 }));
+     *
+     * // {
+     * //   a: [
+     * //     1,
+     * //     2,
+     * //     [
+     * //       [
+     * //         'Lorem ipsum dolor sit amet,\n' +
+     * //           'consectetur adipiscing elit, sed do eiusmod \n' +
+     * //           'tempor incididunt ut labore et dolore magna aliqua.',
+     * //         'test',
+     * //         'foo'
+     * //       ]
+     * //     ],
+     * //     4
+     * //   ],
+     * //   b: Map(2) {
+     * //     'za' => 1,
+     * //     'zb' => 'test'
+     * //   }
+     * // }
+     *
+     * // Setting `breakLength` to e.g. 150 will print the "Lorem ipsum" text in a
+     * // single line.
+     * ```
+     *
+     * The `showHidden` option allows `WeakMap` and `WeakSet` entries to be
+     * inspected. If there are more entries than `maxArrayLength`, there is no
+     * guarantee which entries are displayed. That means retrieving the same
+     * `WeakSet` entries twice may result in different output. Furthermore, entries
+     * with no remaining strong references may be garbage collected at any time.
+     *
+     * ```js
+     * import { inspect } from 'node:util';
+     *
+     * const obj = { a: 1 };
+     * const obj2 = { b: 2 };
+     * const weakSet = new WeakSet([obj, obj2]);
+     *
+     * console.log(inspect(weakSet, { showHidden: true }));
+     * // WeakSet { { a: 1 }, { b: 2 } }
+     * ```
+     *
+     * The `sorted` option ensures that an object's property insertion order does not
+     * impact the result of `util.inspect()`.
+     *
+     * ```js
+     * import { inspect } from 'node:util';
+     * import assert from 'node:assert';
+     *
+     * const o1 = {
+     *   b: [2, 3, 1],
+     *   a: '`a` comes before `b`',
+     *   c: new Set([2, 3, 1]),
+     * };
+     * console.log(inspect(o1, { sorted: true }));
+     * // { a: '`a` comes before `b`', b: [ 2, 3, 1 ], c: Set(3) { 1, 2, 3 } }
+     * console.log(inspect(o1, { sorted: (a, b) => b.localeCompare(a) }));
+     * // { c: Set(3) { 3, 2, 1 }, b: [ 2, 3, 1 ], a: '`a` comes before `b`' }
+     *
+     * const o2 = {
+     *   c: new Set([2, 1, 3]),
+     *   a: '`a` comes before `b`',
+     *   b: [2, 3, 1],
+     * };
+     * assert.strict.equal(
+     *   inspect(o1, { sorted: true }),
+     *   inspect(o2, { sorted: true }),
+     * );
+     * ```
+     *
+     * The `numericSeparator` option adds an underscore every three digits to all
+     * numbers.
+     *
+     * ```js
+     * import { inspect } from 'node:util';
+     *
+     * const thousand = 1000;
+     * const million = 1000000;
+     * const bigNumber = 123456789n;
+     * const bigDecimal = 1234.12345;
+     *
+     * console.log(inspect(thousand, { numericSeparator: true }));
+     * // 1_000
+     * console.log(inspect(million, { numericSeparator: true }));
+     * // 1_000_000
+     * console.log(inspect(bigNumber, { numericSeparator: true }));
+     * // 123_456_789n
+     * console.log(inspect(bigDecimal, { numericSeparator: true }));
+     * // 1_234.123_45
+     * ```
+     *
+     * `util.inspect()` is a synchronous method intended for debugging. Its maximum
+     * output length is approximately 128 MiB. Inputs that result in longer output will
+     * be truncated.
+     * @since v0.3.0
+     * @param object Any JavaScript primitive or `Object`.
+     * @return The representation of `object`.
+     */
+    export function inspect(object: any, showHidden?: boolean, depth?: number | null, color?: boolean): string;
+    export function inspect(object: any, options?: InspectOptions): string;
+    export namespace inspect {
+        let colors: NodeJS.Dict<[number, number]>;
+        let styles: {
+            [K in Style]: string;
+        };
+        let defaultOptions: InspectOptions;
+        /**
+         * Allows changing inspect settings from the repl.
+         */
+        let replDefaults: InspectOptions;
+        /**
+         * That can be used to declare custom inspect functions.
+         */
+        const custom: unique symbol;
+    }
+    /**
+     * Alias for [`Array.isArray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).
+     *
+     * Returns `true` if the given `object` is an `Array`. Otherwise, returns `false`.
+     *
+     * ```js
+     * import util from 'node:util';
+     *
+     * util.isArray([]);
+     * // Returns: true
+     * util.isArray(new Array());
+     * // Returns: true
+     * util.isArray({});
+     * // Returns: false
+     * ```
+     * @since v0.6.0
+     * @deprecated Since v4.0.0 - Use `isArray` instead.
+     */
+    export function isArray(object: unknown): object is unknown[];
+    /**
+     * Usage of `util.inherits()` is discouraged. Please use the ES6 `class` and
+     * `extends` keywords to get language level inheritance support. Also note
+     * that the two styles are [semantically incompatible](https://github.com/nodejs/node/issues/4179).
+     *
+     * Inherit the prototype methods from one
+     * [constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor) into another. The
+     * prototype of `constructor` will be set to a new object created from
+     * `superConstructor`.
+     *
+     * This mainly adds some input validation on top of
+     * `Object.setPrototypeOf(constructor.prototype, superConstructor.prototype)`.
+     * As an additional convenience, `superConstructor` will be accessible
+     * through the `constructor.super_` property.
+     *
+     * ```js
+     * const util = require('node:util');
+     * const EventEmitter = require('node:events');
+     *
+     * function MyStream() {
+     *   EventEmitter.call(this);
+     * }
+     *
+     * util.inherits(MyStream, EventEmitter);
+     *
+     * MyStream.prototype.write = function(data) {
+     *   this.emit('data', data);
+     * };
+     *
+     * const stream = new MyStream();
+     *
+     * console.log(stream instanceof EventEmitter); // true
+     * console.log(MyStream.super_ === EventEmitter); // true
+     *
+     * stream.on('data', (data) => {
+     *   console.log(`Received data: "${data}"`);
+     * });
+     * stream.write('It works!'); // Received data: "It works!"
+     * ```
+     *
+     * ES6 example using `class` and `extends`:
+     *
+     * ```js
+     * import EventEmitter from 'node:events';
+     *
+     * class MyStream extends EventEmitter {
+     *   write(data) {
+     *     this.emit('data', data);
+     *   }
+     * }
+     *
+     * const stream = new MyStream();
+     *
+     * stream.on('data', (data) => {
+     *   console.log(`Received data: "${data}"`);
+     * });
+     * stream.write('With ES6');
+     * ```
+     * @since v0.3.0
+     * @legacy Use ES2015 class syntax and `extends` keyword instead.
+     */
+    export function inherits(constructor: unknown, superConstructor: unknown): void;
+    export type DebugLoggerFunction = (msg: string, ...param: unknown[]) => void;
+    export interface DebugLogger extends DebugLoggerFunction {
+        /**
+         * The `util.debuglog().enabled` getter is used to create a test that can be used
+         * in conditionals based on the existence of the `NODE_DEBUG` environment variable.
+         * If the `section` name appears within the value of that environment variable,
+         * then the returned value will be `true`. If not, then the returned value will be
+         * `false`.
+         *
+         * ```js
+         * import { debuglog } from 'node:util';
+         * const enabled = debuglog('foo').enabled;
+         * if (enabled) {
+         *   console.log('hello from foo [%d]', 123);
+         * }
+         * ```
+         *
+         * If this program is run with `NODE_DEBUG=foo` in the environment, then it will
+         * output something like:
+         *
+         * ```console
+         * hello from foo [123]
+         * ```
+         */
+        enabled: boolean;
+    }
+    /**
+     * The `util.debuglog()` method is used to create a function that conditionally
+     * writes debug messages to `stderr` based on the existence of the `NODE_DEBUG`
+     * environment variable. If the `section` name appears within the value of that
+     * environment variable, then the returned function operates similar to
+     * `console.error()`. If not, then the returned function is a no-op.
+     *
+     * ```js
+     * import { debuglog } from 'node:util';
+     * const log = debuglog('foo');
+     *
+     * log('hello from foo [%d]', 123);
+     * ```
+     *
+     * If this program is run with `NODE_DEBUG=foo` in the environment, then
+     * it will output something like:
+     *
+     * ```console
+     * FOO 3245: hello from foo [123]
+     * ```
+     *
+     * where `3245` is the process id. If it is not run with that
+     * environment variable set, then it will not print anything.
+     *
+     * The `section` supports wildcard also:
+     *
+     * ```js
+     * import { debuglog } from 'node:util';
+     * const log = debuglog('foo');
+     *
+     * log('hi there, it\'s foo-bar [%d]', 2333);
+     * ```
+     *
+     * if it is run with `NODE_DEBUG=foo*` in the environment, then it will output
+     * something like:
+     *
+     * ```console
+     * FOO-BAR 3257: hi there, it's foo-bar [2333]
+     * ```
+     *
+     * Multiple comma-separated `section` names may be specified in the `NODE_DEBUG`
+     * environment variable: `NODE_DEBUG=fs,net,tls`.
+     *
+     * The optional `callback` argument can be used to replace the logging function
+     * with a different function that doesn't have any initialization or
+     * unnecessary wrapping.
+     *
+     * ```js
+     * import { debuglog } from 'node:util';
+     * let log = debuglog('internals', (debug) => {
+     *   // Replace with a logging function that optimizes out
+     *   // testing if the section is enabled
+     *   log = debug;
+     * });
+     * ```
+     * @since v0.11.3
+     * @param section A string identifying the portion of the application for which the `debuglog` function is being created.
+     * @param callback A callback invoked the first time the logging function is called with a function argument that is a more optimized logging function.
+     * @return The logging function
+     */
+    export function debuglog(section: string, callback?: (fn: DebugLoggerFunction) => void): DebugLogger;
+    export { debuglog as debug };
+    /**
+     * The `util.deprecate()` method wraps `fn` (which may be a function or class) in
+     * such a way that it is marked as deprecated.
+     *
+     * ```js
+     * import { deprecate } from 'node:util';
+     *
+     * export const obsoleteFunction = deprecate(() => {
+     *   // Do something here.
+     * }, 'obsoleteFunction() is deprecated. Use newShinyFunction() instead.');
+     * ```
+     *
+     * When called, `util.deprecate()` will return a function that will emit a
+     * `DeprecationWarning` using the `'warning'` event. The warning will
+     * be emitted and printed to `stderr` the first time the returned function is
+     * called. After the warning is emitted, the wrapped function is called without
+     * emitting a warning.
+     *
+     * If the same optional `code` is supplied in multiple calls to `util.deprecate()`,
+     * the warning will be emitted only once for that `code`.
+     *
+     * ```js
+     * import { deprecate } from 'node:util';
+     *
+     * const fn1 = deprecate(
+     *   () => 'a value',
+     *   'deprecation message',
+     *   'DEP0001',
+     * );
+     * const fn2 = deprecate(
+     *   () => 'a  different value',
+     *   'other dep message',
+     *   'DEP0001',
+     * );
+     * fn1(); // Emits a deprecation warning with code DEP0001
+     * fn2(); // Does not emit a deprecation warning because it has the same code
+     * ```
+     *
+     * If either the `--no-deprecation` or `--no-warnings` command-line flags are
+     * used, or if the `process.noDeprecation` property is set to `true` _prior_ to
+     * the first deprecation warning, the `util.deprecate()` method does nothing.
+     *
+     * If the `--trace-deprecation` or `--trace-warnings` command-line flags are set,
+     * or the `process.traceDeprecation` property is set to `true`, a warning and a
+     * stack trace are printed to `stderr` the first time the deprecated function is
+     * called.
+     *
+     * If the `--throw-deprecation` command-line flag is set, or the
+     * `process.throwDeprecation` property is set to `true`, then an exception will be
+     * thrown when the deprecated function is called.
+     *
+     * The `--throw-deprecation` command-line flag and `process.throwDeprecation`
+     * property take precedence over `--trace-deprecation` and
+     * `process.traceDeprecation`.
+     * @since v0.8.0
+     * @param fn The function that is being deprecated.
+     * @param msg A warning message to display when the deprecated function is invoked.
+     * @param code A deprecation code. See the `list of deprecated APIs` for a list of codes.
+     * @return The deprecated function wrapped to emit a warning.
+     */
+    export function deprecate<T extends Function>(fn: T, msg: string, code?: string): T;
+    /**
+     * Returns `true` if there is deep strict equality between `val1` and `val2`.
+     * Otherwise, returns `false`.
+     *
+     * See `assert.deepStrictEqual()` for more information about deep strict
+     * equality.
+     * @since v9.0.0
+     */
+    export function isDeepStrictEqual(val1: unknown, val2: unknown): boolean;
+    /**
+     * Returns `str` with any ANSI escape codes removed.
+     *
+     * ```js
+     * console.log(util.stripVTControlCharacters('\u001B[4mvalue\u001B[0m'));
+     * // Prints "value"
+     * ```
+     * @since v16.11.0
+     */
+    export function stripVTControlCharacters(str: string): string;
+    /**
+     * Takes an `async` function (or a function that returns a `Promise`) and returns a
+     * function following the error-first callback style, i.e. taking
+     * an `(err, value) => ...` callback as the last argument. In the callback, the
+     * first argument will be the rejection reason (or `null` if the `Promise`
+     * resolved), and the second argument will be the resolved value.
+     *
+     * ```js
+     * import { callbackify } from 'node:util';
+     *
+     * async function fn() {
+     *   return 'hello world';
+     * }
+     * const callbackFunction = callbackify(fn);
+     *
+     * callbackFunction((err, ret) => {
+     *   if (err) throw err;
+     *   console.log(ret);
+     * });
+     * ```
+     *
+     * Will print:
+     *
+     * ```text
+     * hello world
+     * ```
+     *
+     * The callback is executed asynchronously, and will have a limited stack trace.
+     * If the callback throws, the process will emit an `'uncaughtException'`
+     * event, and if not handled will exit.
+     *
+     * Since `null` has a special meaning as the first argument to a callback, if a
+     * wrapped function rejects a `Promise` with a falsy value as a reason, the value
+     * is wrapped in an `Error` with the original value stored in a field named
+     * `reason`.
+     *
+     * ```js
+     * function fn() {
+     *   return Promise.reject(null);
+     * }
+     * const callbackFunction = util.callbackify(fn);
+     *
+     * callbackFunction((err, ret) => {
+     *   // When the Promise was rejected with `null` it is wrapped with an Error and
+     *   // the original value is stored in `reason`.
+     *   err && Object.hasOwn(err, 'reason') && err.reason === null;  // true
+     * });
+     * ```
+     * @since v8.2.0
+     * @param fn An `async` function
+     * @return a callback style function
+     */
+    export function callbackify(fn: () => Promise<void>): (callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<TResult>(
+        fn: () => Promise<TResult>,
+    ): (callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;
+    export function callbackify<T1>(
+        fn: (arg1: T1) => Promise<void>,
+    ): (arg1: T1, callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<T1, TResult>(
+        fn: (arg1: T1) => Promise<TResult>,
+    ): (arg1: T1, callback: (err: NodeJS.ErrnoException, result: TResult) => void) => void;
+    export function callbackify<T1, T2>(
+        fn: (arg1: T1, arg2: T2) => Promise<void>,
+    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<T1, T2, TResult>(
+        fn: (arg1: T1, arg2: T2) => Promise<TResult>,
+    ): (arg1: T1, arg2: T2, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;
+    export function callbackify<T1, T2, T3>(
+        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<void>,
+    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<T1, T2, T3, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>,
+    ): (arg1: T1, arg2: T2, arg3: T3, callback: (err: NodeJS.ErrnoException | null, result: TResult) => void) => void;
+    export function callbackify<T1, T2, T3, T4>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<T1, T2, T3, T4, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>,
+    ): (
+        arg1: T1,
+        arg2: T2,
+        arg3: T3,
+        arg4: T4,
+        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
+    ) => void;
+    export function callbackify<T1, T2, T3, T4, T5>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: NodeJS.ErrnoException) => void) => void;
+    export function callbackify<T1, T2, T3, T4, T5, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>,
+    ): (
+        arg1: T1,
+        arg2: T2,
+        arg3: T3,
+        arg4: T4,
+        arg5: T5,
+        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
+    ) => void;
+    export function callbackify<T1, T2, T3, T4, T5, T6>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<void>,
+    ): (
+        arg1: T1,
+        arg2: T2,
+        arg3: T3,
+        arg4: T4,
+        arg5: T5,
+        arg6: T6,
+        callback: (err: NodeJS.ErrnoException) => void,
+    ) => void;
+    export function callbackify<T1, T2, T3, T4, T5, T6, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, arg6: T6) => Promise<TResult>,
+    ): (
+        arg1: T1,
+        arg2: T2,
+        arg3: T3,
+        arg4: T4,
+        arg5: T5,
+        arg6: T6,
+        callback: (err: NodeJS.ErrnoException | null, result: TResult) => void,
+    ) => void;
+    export interface CustomPromisifyLegacy<TCustom extends Function> extends Function {
+        __promisify__: TCustom;
+    }
+    export interface CustomPromisifySymbol<TCustom extends Function> extends Function {
+        [promisify.custom]: TCustom;
+    }
+    export type CustomPromisify<TCustom extends Function> =
+        | CustomPromisifySymbol<TCustom>
+        | CustomPromisifyLegacy<TCustom>;
+    /**
+     * Takes a function following the common error-first callback style, i.e. taking
+     * an `(err, value) => ...` callback as the last argument, and returns a version
+     * that returns promises.
+     *
+     * ```js
+     * import { promisify } from 'node:util';
+     * import { stat } from 'node:fs';
+     *
+     * const promisifiedStat = promisify(stat);
+     * promisifiedStat('.').then((stats) => {
+     *   // Do something with `stats`
+     * }).catch((error) => {
+     *   // Handle the error.
+     * });
+     * ```
+     *
+     * Or, equivalently using `async function`s:
+     *
+     * ```js
+     * import { promisify } from 'node:util';
+     * import { stat } from 'node:fs';
+     *
+     * const promisifiedStat = promisify(stat);
+     *
+     * async function callStat() {
+     *   const stats = await promisifiedStat('.');
+     *   console.log(`This directory is owned by ${stats.uid}`);
+     * }
+     *
+     * callStat();
+     * ```
+     *
+     * If there is an `original[util.promisify.custom]` property present, `promisify`
+     * will return its value, see [Custom promisified functions](https://nodejs.org/docs/latest-v24.x/api/util.html#custom-promisified-functions).
+     *
+     * `promisify()` assumes that `original` is a function taking a callback as its
+     * final argument in all cases. If `original` is not a function, `promisify()`
+     * will throw an error. If `original` is a function but its last argument is not
+     * an error-first callback, it will still be passed an error-first
+     * callback as its last argument.
+     *
+     * Using `promisify()` on class methods or other methods that use `this` may not
+     * work as expected unless handled specially:
+     *
+     * ```js
+     * import { promisify } from 'node:util';
+     *
+     * class Foo {
+     *   constructor() {
+     *     this.a = 42;
+     *   }
+     *
+     *   bar(callback) {
+     *     callback(null, this.a);
+     *   }
+     * }
+     *
+     * const foo = new Foo();
+     *
+     * const naiveBar = promisify(foo.bar);
+     * // TypeError: Cannot read properties of undefined (reading 'a')
+     * // naiveBar().then(a => console.log(a));
+     *
+     * naiveBar.call(foo).then((a) => console.log(a)); // '42'
+     *
+     * const bindBar = naiveBar.bind(foo);
+     * bindBar().then((a) => console.log(a)); // '42'
+     * ```
+     * @since v8.0.0
+     */
+    export function promisify<TCustom extends Function>(fn: CustomPromisify<TCustom>): TCustom;
+    export function promisify<TResult>(
+        fn: (callback: (err: any, result: TResult) => void) => void,
+    ): () => Promise<TResult>;
+    export function promisify(fn: (callback: (err?: any) => void) => void): () => Promise<void>;
+    export function promisify<T1, TResult>(
+        fn: (arg1: T1, callback: (err: any, result: TResult) => void) => void,
+    ): (arg1: T1) => Promise<TResult>;
+    export function promisify<T1>(fn: (arg1: T1, callback: (err?: any) => void) => void): (arg1: T1) => Promise<void>;
+    export function promisify<T1, T2, TResult>(
+        fn: (arg1: T1, arg2: T2, callback: (err: any, result: TResult) => void) => void,
+    ): (arg1: T1, arg2: T2) => Promise<TResult>;
+    export function promisify<T1, T2>(
+        fn: (arg1: T1, arg2: T2, callback: (err?: any) => void) => void,
+    ): (arg1: T1, arg2: T2) => Promise<void>;
+    export function promisify<T1, T2, T3, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err: any, result: TResult) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<TResult>;
+    export function promisify<T1, T2, T3>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, callback: (err?: any) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3) => Promise<void>;
+    export function promisify<T1, T2, T3, T4, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err: any, result: TResult) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<TResult>;
+    export function promisify<T1, T2, T3, T4>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, callback: (err?: any) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4) => Promise<void>;
+    export function promisify<T1, T2, T3, T4, T5, TResult>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err: any, result: TResult) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<TResult>;
+    export function promisify<T1, T2, T3, T4, T5>(
+        fn: (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5, callback: (err?: any) => void) => void,
+    ): (arg1: T1, arg2: T2, arg3: T3, arg4: T4, arg5: T5) => Promise<void>;
+    export function promisify(fn: Function): Function;
+    export namespace promisify {
+        /**
+         * That can be used to declare custom promisified variants of functions.
+         */
+        const custom: unique symbol;
+    }
+    /**
+     * Stability: 1.1 - Active development
+     * Given an example `.env` file:
+     *
+     * ```js
+     * import { parseEnv } from 'node:util';
+     *
+     * parseEnv('HELLO=world\nHELLO=oh my\n');
+     * // Returns: { HELLO: 'oh my' }
+     * ```
+     * @param content The raw contents of a `.env` file.
+     * @since v20.12.0
+     */
+    export function parseEnv(content: string): NodeJS.Dict<string>;
+    // https://nodejs.org/docs/latest/api/util.html#foreground-colors
+    type ForegroundColors =
+        | "black"
+        | "blackBright"
+        | "blue"
+        | "blueBright"
+        | "cyan"
+        | "cyanBright"
+        | "gray"
+        | "green"
+        | "greenBright"
+        | "grey"
+        | "magenta"
+        | "magentaBright"
+        | "red"
+        | "redBright"
+        | "white"
+        | "whiteBright"
+        | "yellow"
+        | "yellowBright";
+    // https://nodejs.org/docs/latest/api/util.html#background-colors
+    type BackgroundColors =
+        | "bgBlack"
+        | "bgBlackBright"
+        | "bgBlue"
+        | "bgBlueBright"
+        | "bgCyan"
+        | "bgCyanBright"
+        | "bgGray"
+        | "bgGreen"
+        | "bgGreenBright"
+        | "bgGrey"
+        | "bgMagenta"
+        | "bgMagentaBright"
+        | "bgRed"
+        | "bgRedBright"
+        | "bgWhite"
+        | "bgWhiteBright"
+        | "bgYellow"
+        | "bgYellowBright";
+    // https://nodejs.org/docs/latest/api/util.html#modifiers
+    type Modifiers =
+        | "blink"
+        | "bold"
+        | "dim"
+        | "doubleunderline"
+        | "framed"
+        | "hidden"
+        | "inverse"
+        | "italic"
+        | "overlined"
+        | "reset"
+        | "strikethrough"
+        | "underline";
+    export interface StyleTextOptions {
+        /**
+         * When true, `stream` is checked to see if it can handle colors.
+         * @default true
+         */
+        validateStream?: boolean | undefined;
+        /**
+         * A stream that will be validated if it can be colored.
+         * @default process.stdout
+         */
+        stream?: NodeJS.WritableStream | undefined;
+    }
+    /**
+     * This function returns a formatted text considering the `format` passed
+     * for printing in a terminal. It is aware of the terminal's capabilities
+     * and acts according to the configuration set via `NO_COLOR`,
+     * `NODE_DISABLE_COLORS` and `FORCE_COLOR` environment variables.
+     *
+     * ```js
+     * import { styleText } from 'node:util';
+     * import { stderr } from 'node:process';
+     *
+     * const successMessage = styleText('green', 'Success!');
+     * console.log(successMessage);
+     *
+     * const errorMessage = styleText(
+     *   'red',
+     *   'Error! Error!',
+     *   // Validate if process.stderr has TTY
+     *   { stream: stderr },
+     * );
+     * console.error(errorMessage);
+     * ```
+     *
+     * `util.inspect.colors` also provides text formats such as `italic`, and
+     * `underline` and you can combine both:
+     *
+     * ```js
+     * console.log(
+     *   util.styleText(['underline', 'italic'], 'My italic underlined message'),
+     * );
+     * ```
+     *
+     * When passing an array of formats, the order of the format applied
+     * is left to right so the following style might overwrite the previous one.
+     *
+     * ```js
+     * console.log(
+     *   util.styleText(['red', 'green'], 'text'), // green
+     * );
+     * ```
+     *
+     * The full list of formats can be found in [modifiers](https://nodejs.org/docs/latest-v24.x/api/util.html#modifiers).
+     * @param format A text format or an Array of text formats defined in `util.inspect.colors`.
+     * @param text The text to to be formatted.
+     * @since v20.12.0
+     */
+    export function styleText(
+        format:
+            | ForegroundColors
+            | BackgroundColors
+            | Modifiers
+            | Array<ForegroundColors | BackgroundColors | Modifiers>,
+        text: string,
+        options?: StyleTextOptions,
+    ): string;
+    /**
+     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextDecoder` API.
+     *
+     * ```js
+     * const decoder = new TextDecoder();
+     * const u8arr = new Uint8Array([72, 101, 108, 108, 111]);
+     * console.log(decoder.decode(u8arr)); // Hello
+     * ```
+     * @since v8.3.0
+     */
+    export class TextDecoder {
+        /**
+         * The encoding supported by the `TextDecoder` instance.
+         */
+        readonly encoding: string;
+        /**
+         * The value will be `true` if decoding errors result in a `TypeError` being
+         * thrown.
+         */
+        readonly fatal: boolean;
+        /**
+         * The value will be `true` if the decoding result will include the byte order
+         * mark.
+         */
+        readonly ignoreBOM: boolean;
+        constructor(
+            encoding?: string,
+            options?: {
+                fatal?: boolean | undefined;
+                ignoreBOM?: boolean | undefined;
+            },
+        );
+        /**
+         * Decodes the `input` and returns a string. If `options.stream` is `true`, any
+         * incomplete byte sequences occurring at the end of the `input` are buffered
+         * internally and emitted after the next call to `textDecoder.decode()`.
+         *
+         * If `textDecoder.fatal` is `true`, decoding errors that occur will result in a `TypeError` being thrown.
+         * @param input An `ArrayBuffer`, `DataView`, or `TypedArray` instance containing the encoded data.
+         */
+        decode(
+            input?: NodeJS.ArrayBufferView | ArrayBuffer | null,
+            options?: {
+                stream?: boolean | undefined;
+            },
+        ): string;
+    }
+    export interface EncodeIntoResult {
+        /**
+         * The read Unicode code units of input.
+         */
+        read: number;
+        /**
+         * The written UTF-8 bytes of output.
+         */
+        written: number;
+    }
+    export { types };
+
+    //// TextEncoder/Decoder
+    /**
+     * An implementation of the [WHATWG Encoding Standard](https://encoding.spec.whatwg.org/) `TextEncoder` API. All
+     * instances of `TextEncoder` only support UTF-8 encoding.
+     *
+     * ```js
+     * const encoder = new TextEncoder();
+     * const uint8array = encoder.encode('this is some data');
+     * ```
+     *
+     * The `TextEncoder` class is also available on the global object.
+     * @since v8.3.0
+     */
+    export class TextEncoder {
+        /**
+         * The encoding supported by the `TextEncoder` instance. Always set to `'utf-8'`.
+         */
+        readonly encoding: string;
+        /**
+         * UTF-8 encodes the `input` string and returns a `Uint8Array` containing the
+         * encoded bytes.
+         * @param [input='an empty string'] The text to encode.
+         */
+        encode(input?: string): Uint8Array;
+        /**
+         * UTF-8 encodes the `src` string to the `dest` Uint8Array and returns an object
+         * containing the read Unicode code units and written UTF-8 bytes.
+         *
+         * ```js
+         * const encoder = new TextEncoder();
+         * const src = 'this is some data';
+         * const dest = new Uint8Array(10);
+         * const { read, written } = encoder.encodeInto(src, dest);
+         * ```
+         * @param src The text to encode.
+         * @param dest The array to hold the encode result.
+         */
+        encodeInto(src: string, dest: Uint8Array): EncodeIntoResult;
+    }
+    import { TextDecoder as _TextDecoder, TextEncoder as _TextEncoder } from "util";
+    global {
+        /**
+         * `TextDecoder` class is a global reference for `import { TextDecoder } from 'node:util'`
+         * https://nodejs.org/api/globals.html#textdecoder
+         * @since v11.0.0
+         */
+        var TextDecoder: typeof globalThis extends {
+            onmessage: any;
+            TextDecoder: infer TextDecoder;
+        } ? TextDecoder
+            : typeof _TextDecoder;
+        /**
+         * `TextEncoder` class is a global reference for `import { TextEncoder } from 'node:util'`
+         * https://nodejs.org/api/globals.html#textencoder
+         * @since v11.0.0
+         */
+        var TextEncoder: typeof globalThis extends {
+            onmessage: any;
+            TextEncoder: infer TextEncoder;
+        } ? TextEncoder
+            : typeof _TextEncoder;
+    }
+
+    //// parseArgs
+    /**
+     * Provides a higher level API for command-line argument parsing than interacting
+     * with `process.argv` directly. Takes a specification for the expected arguments
+     * and returns a structured object with the parsed options and positionals.
+     *
+     * ```js
+     * import { parseArgs } from 'node:util';
+     * const args = ['-f', '--bar', 'b'];
+     * const options = {
+     *   foo: {
+     *     type: 'boolean',
+     *     short: 'f',
+     *   },
+     *   bar: {
+     *     type: 'string',
+     *   },
+     * };
+     * const {
+     *   values,
+     *   positionals,
+     * } = parseArgs({ args, options });
+     * console.log(values, positionals);
+     * // Prints: [Object: null prototype] { foo: true, bar: 'b' } []
+     * ```
+     * @since v18.3.0, v16.17.0
+     * @param config Used to provide arguments for parsing and to configure the parser. `config` supports the following properties:
+     * @return The parsed command line arguments:
+     */
+    export function parseArgs<T extends ParseArgsConfig>(config?: T): ParsedResults<T>;
+
+    /**
+     * Type of argument used in {@link parseArgs}.
+     */
+    export type ParseArgsOptionsType = "boolean" | "string";
+
+    export interface ParseArgsOptionDescriptor {
+        /**
+         * Type of argument.
+         */
+        type: ParseArgsOptionsType;
+        /**
+         * Whether this option can be provided multiple times.
+         * If `true`, all values will be collected in an array.
+         * If `false`, values for the option are last-wins.
+         * @default false.
+         */
+        multiple?: boolean | undefined;
+        /**
+         * A single character alias for the option.
+         */
+        short?: string | undefined;
+        /**
+         * The default value to
+         * be used if (and only if) the option does not appear in the arguments to be
+         * parsed. It must be of the same type as the `type` property. When `multiple`
+         * is `true`, it must be an array.
+         * @since v18.11.0
+         */
+        default?: string | boolean | string[] | boolean[] | undefined;
+    }
+    export interface ParseArgsOptionsConfig {
+        [longOption: string]: ParseArgsOptionDescriptor;
+    }
+    export interface ParseArgsConfig {
+        /**
+         * Array of argument strings.
+         */
+        args?: string[] | undefined;
+        /**
+         * Used to describe arguments known to the parser.
+         */
+        options?: ParseArgsOptionsConfig | undefined;
+        /**
+         * Should an error be thrown when unknown arguments are encountered,
+         * or when arguments are passed that do not match the `type` configured in `options`.
+         * @default true
+         */
+        strict?: boolean | undefined;
+        /**
+         * Whether this command accepts positional arguments.
+         */
+        allowPositionals?: boolean | undefined;
+        /**
+         * If `true`, allows explicitly setting boolean options to `false` by prefixing the option name with `--no-`.
+         * @default false
+         * @since v22.4.0
+         */
+        allowNegative?: boolean | undefined;
+        /**
+         * Return the parsed tokens. This is useful for extending the built-in behavior,
+         * from adding additional checks through to reprocessing the tokens in different ways.
+         * @default false
+         */
+        tokens?: boolean | undefined;
+    }
+    /*
+    IfDefaultsTrue and IfDefaultsFalse are helpers to handle default values for missing boolean properties.
+    TypeScript does not have exact types for objects: https://github.com/microsoft/TypeScript/issues/12936
+    This means it is impossible to distinguish between "field X is definitely not present" and "field X may or may not be present".
+    But we expect users to generally provide their config inline or `as const`, which means TS will always know whether a given field is present.
+    So this helper treats "not definitely present" (i.e., not `extends boolean`) as being "definitely not present", i.e. it should have its default value.
+    This is technically incorrect but is a much nicer UX for the common case.
+    The IfDefaultsTrue version is for things which default to true; the IfDefaultsFalse version is for things which default to false.
+    */
+    type IfDefaultsTrue<T, IfTrue, IfFalse> = T extends true ? IfTrue
+        : T extends false ? IfFalse
+        : IfTrue;
+
+    // we put the `extends false` condition first here because `undefined` compares like `any` when `strictNullChecks: false`
+    type IfDefaultsFalse<T, IfTrue, IfFalse> = T extends false ? IfFalse
+        : T extends true ? IfTrue
+        : IfFalse;
+
+    type ExtractOptionValue<T extends ParseArgsConfig, O extends ParseArgsOptionDescriptor> = IfDefaultsTrue<
+        T["strict"],
+        O["type"] extends "string" ? string : O["type"] extends "boolean" ? boolean : string | boolean,
+        string | boolean
+    >;
+
+    type ApplyOptionalModifiers<O extends ParseArgsOptionsConfig, V extends Record<keyof O, unknown>> = (
+        & { -readonly [LongOption in keyof O]?: V[LongOption] }
+        & { [LongOption in keyof O as O[LongOption]["default"] extends {} ? LongOption : never]: V[LongOption] }
+    ) extends infer P ? { [K in keyof P]: P[K] } : never; // resolve intersection to object
+
+    type ParsedValues<T extends ParseArgsConfig> =
+        & IfDefaultsTrue<T["strict"], unknown, { [longOption: string]: undefined | string | boolean }>
+        & (T["options"] extends ParseArgsOptionsConfig ? ApplyOptionalModifiers<
+                T["options"],
+                {
+                    [LongOption in keyof T["options"]]: IfDefaultsFalse<
+                        T["options"][LongOption]["multiple"],
+                        Array<ExtractOptionValue<T, T["options"][LongOption]>>,
+                        ExtractOptionValue<T, T["options"][LongOption]>
+                    >;
+                }
+            >
+            : {});
+
+    type ParsedPositionals<T extends ParseArgsConfig> = IfDefaultsTrue<
+        T["strict"],
+        IfDefaultsFalse<T["allowPositionals"], string[], []>,
+        IfDefaultsTrue<T["allowPositionals"], string[], []>
+    >;
+
+    type PreciseTokenForOptions<
+        K extends string,
+        O extends ParseArgsOptionDescriptor,
+    > = O["type"] extends "string" ? {
+            kind: "option";
+            index: number;
+            name: K;
+            rawName: string;
+            value: string;
+            inlineValue: boolean;
+        }
+        : O["type"] extends "boolean" ? {
+                kind: "option";
+                index: number;
+                name: K;
+                rawName: string;
+                value: undefined;
+                inlineValue: undefined;
+            }
+        : OptionToken & { name: K };
+
+    type TokenForOptions<
+        T extends ParseArgsConfig,
+        K extends keyof T["options"] = keyof T["options"],
+    > = K extends unknown
+        ? T["options"] extends ParseArgsOptionsConfig ? PreciseTokenForOptions<K & string, T["options"][K]>
+        : OptionToken
+        : never;
+
+    type ParsedOptionToken<T extends ParseArgsConfig> = IfDefaultsTrue<T["strict"], TokenForOptions<T>, OptionToken>;
+
+    type ParsedPositionalToken<T extends ParseArgsConfig> = IfDefaultsTrue<
+        T["strict"],
+        IfDefaultsFalse<T["allowPositionals"], { kind: "positional"; index: number; value: string }, never>,
+        IfDefaultsTrue<T["allowPositionals"], { kind: "positional"; index: number; value: string }, never>
+    >;
+
+    type ParsedTokens<T extends ParseArgsConfig> = Array<
+        ParsedOptionToken<T> | ParsedPositionalToken<T> | { kind: "option-terminator"; index: number }
+    >;
+
+    type PreciseParsedResults<T extends ParseArgsConfig> = IfDefaultsFalse<
+        T["tokens"],
+        {
+            values: ParsedValues<T>;
+            positionals: ParsedPositionals<T>;
+            tokens: ParsedTokens<T>;
+        },
+        {
+            values: ParsedValues<T>;
+            positionals: ParsedPositionals<T>;
+        }
+    >;
+
+    type OptionToken =
+        | { kind: "option"; index: number; name: string; rawName: string; value: string; inlineValue: boolean }
+        | {
+            kind: "option";
+            index: number;
+            name: string;
+            rawName: string;
+            value: undefined;
+            inlineValue: undefined;
+        };
+
+    type Token =
+        | OptionToken
+        | { kind: "positional"; index: number; value: string }
+        | { kind: "option-terminator"; index: number };
+
+    // If ParseArgsConfig extends T, then the user passed config constructed elsewhere.
+    // So we can't rely on the `"not definitely present" implies "definitely not present"` assumption mentioned above.
+    type ParsedResults<T extends ParseArgsConfig> = ParseArgsConfig extends T ? {
+            values: {
+                [longOption: string]: undefined | string | boolean | Array<string | boolean>;
+            };
+            positionals: string[];
+            tokens?: Token[];
+        }
+        : PreciseParsedResults<T>;
+
+    /**
+     * An implementation of [the MIMEType class](https://bmeck.github.io/node-proposal-mime-api/).
+     *
+     * In accordance with browser conventions, all properties of `MIMEType` objects
+     * are implemented as getters and setters on the class prototype, rather than as
+     * data properties on the object itself.
+     *
+     * A MIME string is a structured string containing multiple meaningful
+     * components. When parsed, a `MIMEType` object is returned containing
+     * properties for each of these components.
+     * @since v19.1.0, v18.13.0
+     */
+    export class MIMEType {
+        /**
+         * Creates a new MIMEType object by parsing the input.
+         *
+         * A `TypeError` will be thrown if the `input` is not a valid MIME.
+         * Note that an effort will be made to coerce the given values into strings.
+         * @param input The input MIME to parse.
+         */
+        constructor(input: string | { toString: () => string });
+
+        /**
+         * Gets and sets the type portion of the MIME.
+         *
+         * ```js
+         * import { MIMEType } from 'node:util';
+         *
+         * const myMIME = new MIMEType('text/javascript');
+         * console.log(myMIME.type);
+         * // Prints: text
+         * myMIME.type = 'application';
+         * console.log(myMIME.type);
+         * // Prints: application
+         * console.log(String(myMIME));
+         * // Prints: application/javascript
+         * ```
+         */
+        type: string;
+        /**
+         * Gets and sets the subtype portion of the MIME.
+         *
+         * ```js
+         * import { MIMEType } from 'node:util';
+         *
+         * const myMIME = new MIMEType('text/ecmascript');
+         * console.log(myMIME.subtype);
+         * // Prints: ecmascript
+         * myMIME.subtype = 'javascript';
+         * console.log(myMIME.subtype);
+         * // Prints: javascript
+         * console.log(String(myMIME));
+         * // Prints: text/javascript
+         * ```
+         */
+        subtype: string;
+        /**
+         * Gets the essence of the MIME. This property is read only.
+         * Use `mime.type` or `mime.subtype` to alter the MIME.
+         *
+         * ```js
+         * import { MIMEType } from 'node:util';
+         *
+         * const myMIME = new MIMEType('text/javascript;key=value');
+         * console.log(myMIME.essence);
+         * // Prints: text/javascript
+         * myMIME.type = 'application';
+         * console.log(myMIME.essence);
+         * // Prints: application/javascript
+         * console.log(String(myMIME));
+         * // Prints: application/javascript;key=value
+         * ```
+         */
+        readonly essence: string;
+        /**
+         * Gets the `MIMEParams` object representing the
+         * parameters of the MIME. This property is read-only. See `MIMEParams` documentation for details.
+         */
+        readonly params: MIMEParams;
+        /**
+         * The `toString()` method on the `MIMEType` object returns the serialized MIME.
+         *
+         * Because of the need for standard compliance, this method does not allow users
+         * to customize the serialization process of the MIME.
+         */
+        toString(): string;
+    }
+    /**
+     * The `MIMEParams` API provides read and write access to the parameters of a `MIMEType`.
+     * @since v19.1.0, v18.13.0
+     */
+    export class MIMEParams {
+        /**
+         * Remove all name-value pairs whose name is `name`.
+         */
+        delete(name: string): void;
+        /**
+         * Returns an iterator over each of the name-value pairs in the parameters.
+         * Each item of the iterator is a JavaScript `Array`. The first item of the array
+         * is the `name`, the second item of the array is the `value`.
+         */
+        entries(): NodeJS.Iterator<[name: string, value: string]>;
+        /**
+         * Returns the value of the first name-value pair whose name is `name`. If there
+         * are no such pairs, `null` is returned.
+         * @return or `null` if there is no name-value pair with the given `name`.
+         */
+        get(name: string): string | null;
+        /**
+         * Returns `true` if there is at least one name-value pair whose name is `name`.
+         */
+        has(name: string): boolean;
+        /**
+         * Returns an iterator over the names of each name-value pair.
+         *
+         * ```js
+         * import { MIMEType } from 'node:util';
+         *
+         * const { params } = new MIMEType('text/plain;foo=0;bar=1');
+         * for (const name of params.keys()) {
+         *   console.log(name);
+         * }
+         * // Prints:
+         * //   foo
+         * //   bar
+         * ```
+         */
+        keys(): NodeJS.Iterator<string>;
+        /**
+         * Sets the value in the `MIMEParams` object associated with `name` to `value`. If there are any pre-existing name-value pairs whose names are `name`,
+         * set the first such pair's value to `value`.
+         *
+         * ```js
+         * import { MIMEType } from 'node:util';
+         *
+         * const { params } = new MIMEType('text/plain;foo=0;bar=1');
+         * params.set('foo', 'def');
+         * params.set('baz', 'xyz');
+         * console.log(params.toString());
+         * // Prints: foo=def;bar=1;baz=xyz
+         * ```
+         */
+        set(name: string, value: string): void;
+        /**
+         * Returns an iterator over the values of each name-value pair.
+         */
+        values(): NodeJS.Iterator<string>;
+        /**
+         * Returns an iterator over each of the name-value pairs in the parameters.
+         */
+        [Symbol.iterator](): NodeJS.Iterator<[name: string, value: string]>;
+    }
+}
+declare module "util/types" {
+    import { KeyObject, webcrypto } from "node:crypto";
+    /**
+     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) or
+     * [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.
+     *
+     * See also `util.types.isArrayBuffer()` and `util.types.isSharedArrayBuffer()`.
+     *
+     * ```js
+     * util.types.isAnyArrayBuffer(new ArrayBuffer());  // Returns true
+     * util.types.isAnyArrayBuffer(new SharedArrayBuffer());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isAnyArrayBuffer(object: unknown): object is ArrayBufferLike;
+    /**
+     * Returns `true` if the value is an `arguments` object.
+     *
+     * ```js
+     * function foo() {
+     *   util.types.isArgumentsObject(arguments);  // Returns true
+     * }
+     * ```
+     * @since v10.0.0
+     */
+    function isArgumentsObject(object: unknown): object is IArguments;
+    /**
+     * Returns `true` if the value is a built-in [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instance.
+     * This does _not_ include [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instances. Usually, it is
+     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.
+     *
+     * ```js
+     * util.types.isArrayBuffer(new ArrayBuffer());  // Returns true
+     * util.types.isArrayBuffer(new SharedArrayBuffer());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isArrayBuffer(object: unknown): object is ArrayBuffer;
+    /**
+     * Returns `true` if the value is an instance of one of the [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) views, such as typed
+     * array objects or [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView). Equivalent to
+     * [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).
+     *
+     * ```js
+     * util.types.isArrayBufferView(new Int8Array());  // true
+     * util.types.isArrayBufferView(Buffer.from('hello world')); // true
+     * util.types.isArrayBufferView(new DataView(new ArrayBuffer(16)));  // true
+     * util.types.isArrayBufferView(new ArrayBuffer());  // false
+     * ```
+     * @since v10.0.0
+     */
+    function isArrayBufferView(object: unknown): object is NodeJS.ArrayBufferView;
+    /**
+     * Returns `true` if the value is an [async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
+     * This only reports back what the JavaScript engine is seeing;
+     * in particular, the return value may not match the original source code if
+     * a transpilation tool was used.
+     *
+     * ```js
+     * util.types.isAsyncFunction(function foo() {});  // Returns false
+     * util.types.isAsyncFunction(async function foo() {});  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isAsyncFunction(object: unknown): boolean;
+    /**
+     * Returns `true` if the value is a `BigInt64Array` instance.
+     *
+     * ```js
+     * util.types.isBigInt64Array(new BigInt64Array());   // Returns true
+     * util.types.isBigInt64Array(new BigUint64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isBigInt64Array(value: unknown): value is BigInt64Array;
+    /**
+     * Returns `true` if the value is a BigInt object, e.g. created
+     * by `Object(BigInt(123))`.
+     *
+     * ```js
+     * util.types.isBigIntObject(Object(BigInt(123)));   // Returns true
+     * util.types.isBigIntObject(BigInt(123));   // Returns false
+     * util.types.isBigIntObject(123);  // Returns false
+     * ```
+     * @since v10.4.0
+     */
+    function isBigIntObject(object: unknown): object is BigInt;
+    /**
+     * Returns `true` if the value is a `BigUint64Array` instance.
+     *
+     * ```js
+     * util.types.isBigUint64Array(new BigInt64Array());   // Returns false
+     * util.types.isBigUint64Array(new BigUint64Array());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isBigUint64Array(value: unknown): value is BigUint64Array;
+    /**
+     * Returns `true` if the value is a boolean object, e.g. created
+     * by `new Boolean()`.
+     *
+     * ```js
+     * util.types.isBooleanObject(false);  // Returns false
+     * util.types.isBooleanObject(true);   // Returns false
+     * util.types.isBooleanObject(new Boolean(false)); // Returns true
+     * util.types.isBooleanObject(new Boolean(true));  // Returns true
+     * util.types.isBooleanObject(Boolean(false)); // Returns false
+     * util.types.isBooleanObject(Boolean(true));  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isBooleanObject(object: unknown): object is Boolean;
+    /**
+     * Returns `true` if the value is any boxed primitive object, e.g. created
+     * by `new Boolean()`, `new String()` or `Object(Symbol())`.
+     *
+     * For example:
+     *
+     * ```js
+     * util.types.isBoxedPrimitive(false); // Returns false
+     * util.types.isBoxedPrimitive(new Boolean(false)); // Returns true
+     * util.types.isBoxedPrimitive(Symbol('foo')); // Returns false
+     * util.types.isBoxedPrimitive(Object(Symbol('foo'))); // Returns true
+     * util.types.isBoxedPrimitive(Object(BigInt(5))); // Returns true
+     * ```
+     * @since v10.11.0
+     */
+    function isBoxedPrimitive(object: unknown): object is String | Number | BigInt | Boolean | Symbol;
+    /**
+     * Returns `true` if the value is a built-in [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) instance.
+     *
+     * ```js
+     * const ab = new ArrayBuffer(20);
+     * util.types.isDataView(new DataView(ab));  // Returns true
+     * util.types.isDataView(new Float64Array());  // Returns false
+     * ```
+     *
+     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).
+     * @since v10.0.0
+     */
+    function isDataView(object: unknown): object is DataView;
+    /**
+     * Returns `true` if the value is a built-in [`Date`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
+     *
+     * ```js
+     * util.types.isDate(new Date());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isDate(object: unknown): object is Date;
+    /**
+     * Returns `true` if the value is a native `External` value.
+     *
+     * A native `External` value is a special type of object that contains a
+     * raw C++ pointer (`void*`) for access from native code, and has no other
+     * properties. Such objects are created either by Node.js internals or native
+     * addons. In JavaScript, they are
+     * [frozen](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) objects with a
+     * `null` prototype.
+     *
+     * ```c
+     * #include <js_native_api.h>
+     * #include <stdlib.h>
+     * napi_value result;
+     * static napi_value MyNapi(napi_env env, napi_callback_info info) {
+     *   int* raw = (int*) malloc(1024);
+     *   napi_status status = napi_create_external(env, (void*) raw, NULL, NULL, &result);
+     *   if (status != napi_ok) {
+     *     napi_throw_error(env, NULL, "napi_create_external failed");
+     *     return NULL;
+     *   }
+     *   return result;
+     * }
+     * ...
+     * DECLARE_NAPI_PROPERTY("myNapi", MyNapi)
+     * ...
+     * ```
+     *
+     * ```js
+     * import native from 'napi_addon.node';
+     * import { types } from 'node:util';
+     *
+     * const data = native.myNapi();
+     * types.isExternal(data); // returns true
+     * types.isExternal(0); // returns false
+     * types.isExternal(new String('foo')); // returns false
+     * ```
+     *
+     * For further information on `napi_create_external`, refer to
+     * [`napi_create_external()`](https://nodejs.org/docs/latest-v24.x/api/n-api.html#napi_create_external).
+     * @since v10.0.0
+     */
+    function isExternal(object: unknown): boolean;
+    /**
+     * Returns `true` if the value is a built-in [`Float16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float16Array) instance.
+     *
+     * ```js
+     * util.types.isFloat16Array(new ArrayBuffer());  // Returns false
+     * util.types.isFloat16Array(new Float16Array());  // Returns true
+     * util.types.isFloat16Array(new Float32Array());  // Returns false
+     * ```
+     * @since v24.0.0
+     */
+    function isFloat16Array(object: unknown): object is Float16Array;
+    /**
+     * Returns `true` if the value is a built-in [`Float32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array) instance.
+     *
+     * ```js
+     * util.types.isFloat32Array(new ArrayBuffer());  // Returns false
+     * util.types.isFloat32Array(new Float32Array());  // Returns true
+     * util.types.isFloat32Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isFloat32Array(object: unknown): object is Float32Array;
+    /**
+     * Returns `true` if the value is a built-in [`Float64Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array) instance.
+     *
+     * ```js
+     * util.types.isFloat64Array(new ArrayBuffer());  // Returns false
+     * util.types.isFloat64Array(new Uint8Array());  // Returns false
+     * util.types.isFloat64Array(new Float64Array());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isFloat64Array(object: unknown): object is Float64Array;
+    /**
+     * Returns `true` if the value is a generator function.
+     * This only reports back what the JavaScript engine is seeing;
+     * in particular, the return value may not match the original source code if
+     * a transpilation tool was used.
+     *
+     * ```js
+     * util.types.isGeneratorFunction(function foo() {});  // Returns false
+     * util.types.isGeneratorFunction(function* foo() {});  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isGeneratorFunction(object: unknown): object is GeneratorFunction;
+    /**
+     * Returns `true` if the value is a generator object as returned from a
+     * built-in generator function.
+     * This only reports back what the JavaScript engine is seeing;
+     * in particular, the return value may not match the original source code if
+     * a transpilation tool was used.
+     *
+     * ```js
+     * function* foo() {}
+     * const generator = foo();
+     * util.types.isGeneratorObject(generator);  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isGeneratorObject(object: unknown): object is Generator;
+    /**
+     * Returns `true` if the value is a built-in [`Int8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array) instance.
+     *
+     * ```js
+     * util.types.isInt8Array(new ArrayBuffer());  // Returns false
+     * util.types.isInt8Array(new Int8Array());  // Returns true
+     * util.types.isInt8Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isInt8Array(object: unknown): object is Int8Array;
+    /**
+     * Returns `true` if the value is a built-in [`Int16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array) instance.
+     *
+     * ```js
+     * util.types.isInt16Array(new ArrayBuffer());  // Returns false
+     * util.types.isInt16Array(new Int16Array());  // Returns true
+     * util.types.isInt16Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isInt16Array(object: unknown): object is Int16Array;
+    /**
+     * Returns `true` if the value is a built-in [`Int32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array) instance.
+     *
+     * ```js
+     * util.types.isInt32Array(new ArrayBuffer());  // Returns false
+     * util.types.isInt32Array(new Int32Array());  // Returns true
+     * util.types.isInt32Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isInt32Array(object: unknown): object is Int32Array;
+    /**
+     * Returns `true` if the value is a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.
+     *
+     * ```js
+     * util.types.isMap(new Map());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isMap<T>(
+        object: T | {},
+    ): object is T extends ReadonlyMap<any, any> ? (unknown extends T ? never : ReadonlyMap<any, any>)
+        : Map<unknown, unknown>;
+    /**
+     * Returns `true` if the value is an iterator returned for a built-in [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) instance.
+     *
+     * ```js
+     * const map = new Map();
+     * util.types.isMapIterator(map.keys());  // Returns true
+     * util.types.isMapIterator(map.values());  // Returns true
+     * util.types.isMapIterator(map.entries());  // Returns true
+     * util.types.isMapIterator(map[Symbol.iterator]());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isMapIterator(object: unknown): boolean;
+    /**
+     * Returns `true` if the value is an instance of a [Module Namespace Object](https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects).
+     *
+     * ```js
+     * import * as ns from './a.js';
+     *
+     * util.types.isModuleNamespaceObject(ns);  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isModuleNamespaceObject(value: unknown): boolean;
+    /**
+     * Returns `true` if the value was returned by the constructor of a
+     * [built-in `Error` type](https://tc39.es/ecma262/#sec-error-objects).
+     *
+     * ```js
+     * console.log(util.types.isNativeError(new Error()));  // true
+     * console.log(util.types.isNativeError(new TypeError()));  // true
+     * console.log(util.types.isNativeError(new RangeError()));  // true
+     * ```
+     *
+     * Subclasses of the native error types are also native errors:
+     *
+     * ```js
+     * class MyError extends Error {}
+     * console.log(util.types.isNativeError(new MyError()));  // true
+     * ```
+     *
+     * A value being `instanceof` a native error class is not equivalent to `isNativeError()`
+     * returning `true` for that value. `isNativeError()` returns `true` for errors
+     * which come from a different [realm](https://tc39.es/ecma262/#realm) while `instanceof Error` returns `false`
+     * for these errors:
+     *
+     * ```js
+     * import { createContext, runInContext } from 'node:vm';
+     * import { types } from 'node:util';
+     *
+     * const context = createContext({});
+     * const myError = runInContext('new Error()', context);
+     * console.log(types.isNativeError(myError)); // true
+     * console.log(myError instanceof Error); // false
+     * ```
+     *
+     * Conversely, `isNativeError()` returns `false` for all objects which were not
+     * returned by the constructor of a native error. That includes values
+     * which are `instanceof` native errors:
+     *
+     * ```js
+     * const myError = { __proto__: Error.prototype };
+     * console.log(util.types.isNativeError(myError)); // false
+     * console.log(myError instanceof Error); // true
+     * ```
+     * @since v10.0.0
+     */
+    function isNativeError(object: unknown): object is Error;
+    /**
+     * Returns `true` if the value is a number object, e.g. created
+     * by `new Number()`.
+     *
+     * ```js
+     * util.types.isNumberObject(0);  // Returns false
+     * util.types.isNumberObject(new Number(0));   // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isNumberObject(object: unknown): object is Number;
+    /**
+     * Returns `true` if the value is a built-in [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
+     *
+     * ```js
+     * util.types.isPromise(Promise.resolve(42));  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isPromise(object: unknown): object is Promise<unknown>;
+    /**
+     * Returns `true` if the value is a [`Proxy`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) instance.
+     *
+     * ```js
+     * const target = {};
+     * const proxy = new Proxy(target, {});
+     * util.types.isProxy(target);  // Returns false
+     * util.types.isProxy(proxy);  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isProxy(object: unknown): boolean;
+    /**
+     * Returns `true` if the value is a regular expression object.
+     *
+     * ```js
+     * util.types.isRegExp(/abc/);  // Returns true
+     * util.types.isRegExp(new RegExp('abc'));  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isRegExp(object: unknown): object is RegExp;
+    /**
+     * Returns `true` if the value is a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.
+     *
+     * ```js
+     * util.types.isSet(new Set());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isSet<T>(
+        object: T | {},
+    ): object is T extends ReadonlySet<any> ? (unknown extends T ? never : ReadonlySet<any>) : Set<unknown>;
+    /**
+     * Returns `true` if the value is an iterator returned for a built-in [`Set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) instance.
+     *
+     * ```js
+     * const set = new Set();
+     * util.types.isSetIterator(set.keys());  // Returns true
+     * util.types.isSetIterator(set.values());  // Returns true
+     * util.types.isSetIterator(set.entries());  // Returns true
+     * util.types.isSetIterator(set[Symbol.iterator]());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isSetIterator(object: unknown): boolean;
+    /**
+     * Returns `true` if the value is a built-in [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instance.
+     * This does _not_ include [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) instances. Usually, it is
+     * desirable to test for both; See `util.types.isAnyArrayBuffer()` for that.
+     *
+     * ```js
+     * util.types.isSharedArrayBuffer(new ArrayBuffer());  // Returns false
+     * util.types.isSharedArrayBuffer(new SharedArrayBuffer());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isSharedArrayBuffer(object: unknown): object is SharedArrayBuffer;
+    /**
+     * Returns `true` if the value is a string object, e.g. created
+     * by `new String()`.
+     *
+     * ```js
+     * util.types.isStringObject('foo');  // Returns false
+     * util.types.isStringObject(new String('foo'));   // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isStringObject(object: unknown): object is String;
+    /**
+     * Returns `true` if the value is a symbol object, created
+     * by calling `Object()` on a `Symbol` primitive.
+     *
+     * ```js
+     * const symbol = Symbol('foo');
+     * util.types.isSymbolObject(symbol);  // Returns false
+     * util.types.isSymbolObject(Object(symbol));   // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isSymbolObject(object: unknown): object is Symbol;
+    /**
+     * Returns `true` if the value is a built-in [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) instance.
+     *
+     * ```js
+     * util.types.isTypedArray(new ArrayBuffer());  // Returns false
+     * util.types.isTypedArray(new Uint8Array());  // Returns true
+     * util.types.isTypedArray(new Float64Array());  // Returns true
+     * ```
+     *
+     * See also [`ArrayBuffer.isView()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer/isView).
+     * @since v10.0.0
+     */
+    function isTypedArray(object: unknown): object is NodeJS.TypedArray;
+    /**
+     * Returns `true` if the value is a built-in [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) instance.
+     *
+     * ```js
+     * util.types.isUint8Array(new ArrayBuffer());  // Returns false
+     * util.types.isUint8Array(new Uint8Array());  // Returns true
+     * util.types.isUint8Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isUint8Array(object: unknown): object is Uint8Array;
+    /**
+     * Returns `true` if the value is a built-in [`Uint8ClampedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray) instance.
+     *
+     * ```js
+     * util.types.isUint8ClampedArray(new ArrayBuffer());  // Returns false
+     * util.types.isUint8ClampedArray(new Uint8ClampedArray());  // Returns true
+     * util.types.isUint8ClampedArray(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isUint8ClampedArray(object: unknown): object is Uint8ClampedArray;
+    /**
+     * Returns `true` if the value is a built-in [`Uint16Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array) instance.
+     *
+     * ```js
+     * util.types.isUint16Array(new ArrayBuffer());  // Returns false
+     * util.types.isUint16Array(new Uint16Array());  // Returns true
+     * util.types.isUint16Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isUint16Array(object: unknown): object is Uint16Array;
+    /**
+     * Returns `true` if the value is a built-in [`Uint32Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array) instance.
+     *
+     * ```js
+     * util.types.isUint32Array(new ArrayBuffer());  // Returns false
+     * util.types.isUint32Array(new Uint32Array());  // Returns true
+     * util.types.isUint32Array(new Float64Array());  // Returns false
+     * ```
+     * @since v10.0.0
+     */
+    function isUint32Array(object: unknown): object is Uint32Array;
+    /**
+     * Returns `true` if the value is a built-in [`WeakMap`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap) instance.
+     *
+     * ```js
+     * util.types.isWeakMap(new WeakMap());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isWeakMap(object: unknown): object is WeakMap<object, unknown>;
+    /**
+     * Returns `true` if the value is a built-in [`WeakSet`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet) instance.
+     *
+     * ```js
+     * util.types.isWeakSet(new WeakSet());  // Returns true
+     * ```
+     * @since v10.0.0
+     */
+    function isWeakSet(object: unknown): object is WeakSet<object>;
+    /**
+     * Returns `true` if `value` is a `KeyObject`, `false` otherwise.
+     * @since v16.2.0
+     */
+    function isKeyObject(object: unknown): object is KeyObject;
+    /**
+     * Returns `true` if `value` is a `CryptoKey`, `false` otherwise.
+     * @since v16.2.0
+     */
+    function isCryptoKey(object: unknown): object is webcrypto.CryptoKey;
+}
+declare module "node:util" {
+    export * from "util";
+}
+declare module "node:util/types" {
+    export * from "util/types";
+}
