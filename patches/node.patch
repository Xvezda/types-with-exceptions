diff -ruN .cache/node/fs.d.ts types/node/fs.d.ts
--- .cache/node/fs.d.ts	2025-08-08 18:07:24.917681432 +0000
+++ types/node/fs.d.ts	2025-08-08 18:07:15.879589539 +0000
@@ -562,6 +562,7 @@
      *
      * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., source not found, permission denied, cross-device link)
      */
     export function renameSync(oldPath: PathLike, newPath: PathLike): void;
     /**
@@ -607,6 +608,7 @@
      * in the future.
      * @since v0.8.6
      * @param [len=0]
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function truncateSync(path: PathLike, len?: number): void;
     /**
@@ -673,6 +675,7 @@
      * this API: {@link ftruncate}.
      * @since v0.8.6
      * @param [len=0]
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function ftruncateSync(fd: number, len?: number): void;
     /**
@@ -696,6 +699,7 @@
      *
      * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
      * @since v0.1.97
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid user/group)
      */
     export function chownSync(path: PathLike, uid: number, gid: number): void;
     /**
@@ -720,6 +724,7 @@
      * @since v0.4.7
      * @param uid The file's new owner's user id.
      * @param gid The file's new group's group id.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, permission denied, invalid user/group)
      */
     export function fchownSync(fd: number, uid: number, gid: number): void;
     /**
@@ -742,6 +747,7 @@
      * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
      * @param uid The file's new owner's user id.
      * @param gid The file's new group's group id.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid user/group)
      */
     export function lchownSync(path: PathLike, uid: number, gid: number): void;
     /**
@@ -770,6 +776,7 @@
      * Returns `undefined`, or throws an exception when parameters are incorrect or
      * the operation fails. This is the synchronous version of {@link lutimes}.
      * @since v14.5.0, v12.19.0
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid timestamps)
      */
     export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -803,6 +810,7 @@
      *
      * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
      * @since v0.6.7
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid mode)
      */
     export function chmodSync(path: PathLike, mode: Mode): void;
     /**
@@ -826,6 +834,7 @@
      *
      * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
      * @since v0.4.7
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, permission denied, invalid mode)
      */
     export function fchmodSync(fd: number, mode: Mode): void;
     /**
@@ -854,6 +863,7 @@
      *
      * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
      * @deprecated Since v0.4.7
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid mode)
      */
     export function lchmodSync(path: PathLike, mode: Mode): void;
     /**
@@ -1022,6 +1032,7 @@
     /**
      * Synchronous stat(2) - Get file status.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export const statSync: StatSyncFn;
     /**
@@ -1076,6 +1087,7 @@
      *
      * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
      * @since v0.1.95
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fstatSync(
         fd: number,
@@ -1195,6 +1207,7 @@
      * In case of an error, the `err.code` will be one of `Common System Errors`.
      * @since v19.6.0, v18.15.0
      * @param path A path to an existing file or directory on the file system to be queried.
+     * @throws {NodeJS.ErrnoException} When file system operations fail (e.g., path not found, permission denied, invalid file system)
      */
     export function statfsSync(
         path: PathLike,
@@ -1212,6 +1225,7 @@
     /**
      * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export const lstatSync: StatSyncFn;
     /**
@@ -1232,6 +1246,7 @@
     /**
      * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When link operations fail (e.g., source not found, permission denied, cross-device link)
      */
     export function linkSync(existingPath: PathLike, newPath: PathLike): void;
     /**
@@ -1297,6 +1312,7 @@
      * this API: {@link symlink}.
      * @since v0.1.31
      * @param [type='null']
+     * @throws {NodeJS.ErrnoException} When symlink operations fail (e.g., permission denied, target not found, path already exists)
      */
     export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
     /**
@@ -1374,18 +1390,21 @@
      * the link path returned. If the `encoding` is set to `'buffer'`,
      * the link path returned will be passed as a `Buffer` object.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options?: EncodingOption): string;
     /**
      * Synchronous readlink(2) - read value of a symbolic link.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
     /**
      * Synchronous readlink(2) - read value of a symbolic link.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, not a symbolic link)
      */
     export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
     /**
@@ -1509,18 +1528,21 @@
      * For detailed information, see the documentation of the asynchronous version of
      * this API: {@link realpath}.
      * @since v0.1.31
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options?: EncodingOption): string;
     /**
      * Synchronous realpath(3) - return the canonicalized absolute pathname.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
     /**
      * Synchronous realpath(3) - return the canonicalized absolute pathname.
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
     export namespace realpathSync {
@@ -1558,6 +1580,7 @@
     /**
      * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, file in use)
      */
     export function unlinkSync(path: PathLike): void;
     export interface RmDirOptions {
@@ -1614,6 +1637,7 @@
      *
      * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, directory not empty)
      */
     export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
     export interface RmOptions {
@@ -1660,6 +1684,7 @@
     /**
      * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
      * @since v14.14.0
+     * @throws {NodeJS.ErrnoException} When file/directory operations fail (e.g., path not found, permission denied, path in use)
      */
     export function rmSync(path: PathLike, options?: RmOptions): void;
     export interface MakeDirectoryOptions {
@@ -1796,6 +1821,7 @@
      *
      * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(
         path: PathLike,
@@ -1808,6 +1834,7 @@
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(
         path: PathLike,
@@ -1823,6 +1850,7 @@
      * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
      * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
      * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., permission denied, path already exists, invalid path)
      */
     export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
     /**
@@ -1950,18 +1978,21 @@
      * The optional `options` argument can be a string specifying an encoding, or an
      * object with an `encoding` property specifying the character encoding to use.
      * @since v5.10.0
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options?: EncodingOption): string;
     /**
      * Synchronously creates a unique temporary directory.
      * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
     /**
      * Synchronously creates a unique temporary directory.
      * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
      * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     * @throws {NodeJS.ErrnoException} When directory creation fails (e.g., permission denied, invalid prefix, insufficient disk space)
      */
     export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
     /**
@@ -2143,6 +2174,7 @@
      *
      * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, not a directory)
      */
     export function readdirSync(
         path: PathLike,
@@ -2236,6 +2268,7 @@
      *
      * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
      * @since v0.1.21
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function closeSync(fd: number): void;
     /**
@@ -2292,6 +2325,7 @@
      * @since v0.1.21
      * @param [flags='r']
      * @param [mode=0o666]
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid flags)
      */
     export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
     /**
@@ -2319,6 +2353,7 @@
      * For detailed information, see the documentation of the asynchronous version of
      * this API: {@link utimes}.
      * @since v0.4.2
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid timestamps)
      */
     export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -2339,6 +2374,7 @@
     /**
      * Synchronous version of {@link futimes}. Returns `undefined`.
      * @since v0.4.2
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, invalid timestamps)
      */
     export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
     /**
@@ -2361,6 +2397,7 @@
      * device. The specific implementation is operating system and device specific.
      * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
      * @since v0.1.96
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fsyncSync(fd: number): void;
     export interface WriteOptions {
@@ -2554,6 +2591,7 @@
      * @param [length=buffer.byteLength - offset]
      * @param [position='null']
      * @return The number of bytes written.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writeSync(
         fd: number,
@@ -2568,6 +2606,7 @@
      * @param string A string to write.
      * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
      * @param encoding The expected string encoding.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writeSync(
         fd: number,
@@ -2684,6 +2723,7 @@
      * this API: {@link read}.
      * @since v0.1.21
      * @param [position='null']
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readSync(
         fd: number,
@@ -2695,6 +2735,7 @@
     /**
      * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
      * If no `options` object is specified, it will default with the above values.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
     /**
@@ -2891,6 +2932,7 @@
      * ```
      * @since v0.1.8
      * @param path filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -2905,6 +2947,7 @@
      * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      * If a flag is not provided, it defaults to `'r'`.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -2921,6 +2964,7 @@
      * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
      * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
      * If a flag is not provided, it defaults to `'r'`.
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., file not found, permission denied, invalid path)
      */
     export function readFileSync(
         path: PathOrFileDescriptor,
@@ -3049,6 +3093,7 @@
      * this API: {@link writeFile}.
      * @since v0.1.29
      * @param file filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., permission denied, disk full, invalid path)
      */
     export function writeFileSync(
         file: PathOrFileDescriptor,
@@ -3186,6 +3231,7 @@
      * ```
      * @since v0.6.7
      * @param path filename or file descriptor
+     * @throws {NodeJS.ErrnoException} When file operations fail (e.g., permission denied, disk full, invalid path)
      */
     export function appendFileSync(
         path: PathOrFileDescriptor,
@@ -3861,6 +3907,7 @@
      * ```
      * @since v0.11.15
      * @param [mode=fs.constants.F_OK]
+     * @throws {NodeJS.ErrnoException} When access checks fail (e.g., file not found, permission denied)
      */
     export function accessSync(path: PathLike, mode?: number): void;
     interface StreamOptions {
@@ -4002,6 +4049,7 @@
      * Forces all currently queued I/O operations associated with the file to the
      * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
      * @since v0.1.96
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function fdatasyncSync(fd: number): void;
     /**
@@ -4081,6 +4129,7 @@
      * @param src source filename to copy
      * @param dest destination filename of the copy operation
      * @param [mode=0] modifiers for copy operation.
+     * @throws {NodeJS.ErrnoException} When copy operations fail (e.g., source not found, permission denied, disk full)
      */
     export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
     /**
@@ -4131,6 +4180,7 @@
      * @since v12.9.0
      * @param [position='null']
      * @return The number of bytes written.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error, disk full)
      */
     export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
     /**
@@ -4176,6 +4226,7 @@
      * @since v13.13.0, v12.17.0
      * @param [position='null']
      * @return The number of bytes read.
+     * @throws {NodeJS.ErrnoException} When file descriptor operations fail (e.g., invalid file descriptor, I/O error)
      */
     export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
 
@@ -4233,6 +4284,7 @@
      * The `encoding` option sets the encoding for the `path` while opening the
      * directory and subsequent read operations.
      * @since v12.12.0
+     * @throws {NodeJS.ErrnoException} When directory operations fail (e.g., directory not found, permission denied, not a directory)
      */
     export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
     /**
@@ -4356,6 +4408,7 @@
      * @experimental
      * @param src source path to copy.
      * @param dest destination path to copy to.
+     * @throws {NodeJS.ErrnoException} When copy operations fail (e.g., source not found, permission denied, disk full)
      */
     export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;
 
@@ -4434,6 +4487,7 @@
      *
      * console.log(globSync('*.js'));
      * ```
+     * @throws {NodeJS.ErrnoException} When file system operations fail (e.g., permission denied, invalid pattern, path not found)
      * @since v22.0.0
      * @returns paths of files that match the pattern.
      */
diff -ruN .cache/node/fs.d.ts.orig types/node/fs.d.ts.orig
--- .cache/node/fs.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/fs.d.ts.orig	2025-08-08 18:07:15.881589559 +0000
@@ -0,0 +1,4456 @@
+/**
+ * The `node:fs` module enables interacting with the file system in a
+ * way modeled on standard POSIX functions.
+ *
+ * To use the promise-based APIs:
+ *
+ * ```js
+ * import * as fs from 'node:fs/promises';
+ * ```
+ *
+ * To use the callback and sync APIs:
+ *
+ * ```js
+ * import * as fs from 'node:fs';
+ * ```
+ *
+ * All file system operations have synchronous, callback, and promise-based
+ * forms, and are accessible using both CommonJS syntax and ES6 Modules (ESM).
+ * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/fs.js)
+ */
+declare module "fs" {
+    import * as stream from "node:stream";
+    import { Abortable, EventEmitter } from "node:events";
+    import { URL } from "node:url";
+    import * as promises from "node:fs/promises";
+    export { promises };
+    /**
+     * Valid types for path values in "fs".
+     */
+    export type PathLike = string | Buffer | URL;
+    export type PathOrFileDescriptor = PathLike | number;
+    export type TimeLike = string | number | Date;
+    export type NoParamCallback = (err: NodeJS.ErrnoException | null) => void;
+    export type BufferEncodingOption =
+        | "buffer"
+        | {
+            encoding: "buffer";
+        };
+    export interface ObjectEncodingOptions {
+        encoding?: BufferEncoding | null | undefined;
+    }
+    export type EncodingOption = ObjectEncodingOptions | BufferEncoding | undefined | null;
+    export type OpenMode = number | string;
+    export type Mode = number | string;
+    export interface StatsBase<T> {
+        isFile(): boolean;
+        isDirectory(): boolean;
+        isBlockDevice(): boolean;
+        isCharacterDevice(): boolean;
+        isSymbolicLink(): boolean;
+        isFIFO(): boolean;
+        isSocket(): boolean;
+        dev: T;
+        ino: T;
+        mode: T;
+        nlink: T;
+        uid: T;
+        gid: T;
+        rdev: T;
+        size: T;
+        blksize: T;
+        blocks: T;
+        atimeMs: T;
+        mtimeMs: T;
+        ctimeMs: T;
+        birthtimeMs: T;
+        atime: Date;
+        mtime: Date;
+        ctime: Date;
+        birthtime: Date;
+    }
+    export interface Stats extends StatsBase<number> {}
+    /**
+     * A `fs.Stats` object provides information about a file.
+     *
+     * Objects returned from {@link stat}, {@link lstat}, {@link fstat}, and
+     * their synchronous counterparts are of this type.
+     * If `bigint` in the `options` passed to those methods is true, the numeric values
+     * will be `bigint` instead of `number`, and the object will contain additional
+     * nanosecond-precision properties suffixed with `Ns`. `Stat` objects are not to be created directly using the `new` keyword.
+     *
+     * ```console
+     * Stats {
+     *   dev: 2114,
+     *   ino: 48064969,
+     *   mode: 33188,
+     *   nlink: 1,
+     *   uid: 85,
+     *   gid: 100,
+     *   rdev: 0,
+     *   size: 527,
+     *   blksize: 4096,
+     *   blocks: 8,
+     *   atimeMs: 1318289051000.1,
+     *   mtimeMs: 1318289051000.1,
+     *   ctimeMs: 1318289051000.1,
+     *   birthtimeMs: 1318289051000.1,
+     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
+     * ```
+     *
+     * `bigint` version:
+     *
+     * ```console
+     * BigIntStats {
+     *   dev: 2114n,
+     *   ino: 48064969n,
+     *   mode: 33188n,
+     *   nlink: 1n,
+     *   uid: 85n,
+     *   gid: 100n,
+     *   rdev: 0n,
+     *   size: 527n,
+     *   blksize: 4096n,
+     *   blocks: 8n,
+     *   atimeMs: 1318289051000n,
+     *   mtimeMs: 1318289051000n,
+     *   ctimeMs: 1318289051000n,
+     *   birthtimeMs: 1318289051000n,
+     *   atimeNs: 1318289051000000000n,
+     *   mtimeNs: 1318289051000000000n,
+     *   ctimeNs: 1318289051000000000n,
+     *   birthtimeNs: 1318289051000000000n,
+     *   atime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   mtime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   ctime: Mon, 10 Oct 2011 23:24:11 GMT,
+     *   birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
+     * ```
+     * @since v0.1.21
+     */
+    export class Stats {
+        private constructor();
+    }
+    export interface StatsFsBase<T> {
+        /** Type of file system. */
+        type: T;
+        /**  Optimal transfer block size. */
+        bsize: T;
+        /**  Total data blocks in file system. */
+        blocks: T;
+        /** Free blocks in file system. */
+        bfree: T;
+        /** Available blocks for unprivileged users */
+        bavail: T;
+        /** Total file nodes in file system. */
+        files: T;
+        /** Free file nodes in file system. */
+        ffree: T;
+    }
+    export interface StatsFs extends StatsFsBase<number> {}
+    /**
+     * Provides information about a mounted file system.
+     *
+     * Objects returned from {@link statfs} and its synchronous counterpart are of
+     * this type. If `bigint` in the `options` passed to those methods is `true`, the
+     * numeric values will be `bigint` instead of `number`.
+     *
+     * ```console
+     * StatFs {
+     *   type: 1397114950,
+     *   bsize: 4096,
+     *   blocks: 121938943,
+     *   bfree: 61058895,
+     *   bavail: 61058895,
+     *   files: 999,
+     *   ffree: 1000000
+     * }
+     * ```
+     *
+     * `bigint` version:
+     *
+     * ```console
+     * StatFs {
+     *   type: 1397114950n,
+     *   bsize: 4096n,
+     *   blocks: 121938943n,
+     *   bfree: 61058895n,
+     *   bavail: 61058895n,
+     *   files: 999n,
+     *   ffree: 1000000n
+     * }
+     * ```
+     * @since v19.6.0, v18.15.0
+     */
+    export class StatsFs {}
+    export interface BigIntStatsFs extends StatsFsBase<bigint> {}
+    export interface StatFsOptions {
+        bigint?: boolean | undefined;
+    }
+    /**
+     * A representation of a directory entry, which can be a file or a subdirectory
+     * within the directory, as returned by reading from an `fs.Dir`. The
+     * directory entry is a combination of the file name and file type pairs.
+     *
+     * Additionally, when {@link readdir} or {@link readdirSync} is called with
+     * the `withFileTypes` option set to `true`, the resulting array is filled with `fs.Dirent` objects, rather than strings or `Buffer` s.
+     * @since v10.10.0
+     */
+    export class Dirent<Name extends string | Buffer = string> {
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a regular file.
+         * @since v10.10.0
+         */
+        isFile(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a file system
+         * directory.
+         * @since v10.10.0
+         */
+        isDirectory(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a block device.
+         * @since v10.10.0
+         */
+        isBlockDevice(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a character device.
+         * @since v10.10.0
+         */
+        isCharacterDevice(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a symbolic link.
+         * @since v10.10.0
+         */
+        isSymbolicLink(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a first-in-first-out
+         * (FIFO) pipe.
+         * @since v10.10.0
+         */
+        isFIFO(): boolean;
+        /**
+         * Returns `true` if the `fs.Dirent` object describes a socket.
+         * @since v10.10.0
+         */
+        isSocket(): boolean;
+        /**
+         * The file name that this `fs.Dirent` object refers to. The type of this
+         * value is determined by the `options.encoding` passed to {@link readdir} or {@link readdirSync}.
+         * @since v10.10.0
+         */
+        name: Name;
+        /**
+         * The path to the parent directory of the file this `fs.Dirent` object refers to.
+         * @since v20.12.0, v18.20.0
+         */
+        parentPath: string;
+    }
+    /**
+     * A class representing a directory stream.
+     *
+     * Created by {@link opendir}, {@link opendirSync}, or `fsPromises.opendir()`.
+     *
+     * ```js
+     * import { opendir } from 'node:fs/promises';
+     *
+     * try {
+     *   const dir = await opendir('./');
+     *   for await (const dirent of dir)
+     *     console.log(dirent.name);
+     * } catch (err) {
+     *   console.error(err);
+     * }
+     * ```
+     *
+     * When using the async iterator, the `fs.Dir` object will be automatically
+     * closed after the iterator exits.
+     * @since v12.12.0
+     */
+    export class Dir implements AsyncIterable<Dirent> {
+        /**
+         * The read-only path of this directory as was provided to {@link opendir},{@link opendirSync}, or `fsPromises.opendir()`.
+         * @since v12.12.0
+         */
+        readonly path: string;
+        /**
+         * Asynchronously iterates over the directory via `readdir(3)` until all entries have been read.
+         */
+        [Symbol.asyncIterator](): NodeJS.AsyncIterator<Dirent>;
+        /**
+         * Asynchronously close the directory's underlying resource handle.
+         * Subsequent reads will result in errors.
+         *
+         * A promise is returned that will be fulfilled after the resource has been
+         * closed.
+         * @since v12.12.0
+         */
+        close(): Promise<void>;
+        close(cb: NoParamCallback): void;
+        /**
+         * Synchronously close the directory's underlying resource handle.
+         * Subsequent reads will result in errors.
+         * @since v12.12.0
+         */
+        closeSync(): void;
+        /**
+         * Asynchronously read the next directory entry via [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) as an `fs.Dirent`.
+         *
+         * A promise is returned that will be fulfilled with an `fs.Dirent`, or `null` if there are no more directory entries to read.
+         *
+         * Directory entries returned by this function are in no particular order as
+         * provided by the operating system's underlying directory mechanisms.
+         * Entries added or removed while iterating over the directory might not be
+         * included in the iteration results.
+         * @since v12.12.0
+         * @return containing {fs.Dirent|null}
+         */
+        read(): Promise<Dirent | null>;
+        read(cb: (err: NodeJS.ErrnoException | null, dirEnt: Dirent | null) => void): void;
+        /**
+         * Synchronously read the next directory entry as an `fs.Dirent`. See the
+         * POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more detail.
+         *
+         * If there are no more directory entries to read, `null` will be returned.
+         *
+         * Directory entries returned by this function are in no particular order as
+         * provided by the operating system's underlying directory mechanisms.
+         * Entries added or removed while iterating over the directory might not be
+         * included in the iteration results.
+         * @since v12.12.0
+         */
+        readSync(): Dirent | null;
+        /**
+         * An alias for `dir.close()`.
+         * @since v24.1.0
+         */
+        [Symbol.dispose](): void;
+        /**
+         * An alias for `dir.closeSync()`.
+         * @since v24.1.0
+         */
+        [Symbol.asyncDispose](): void;
+    }
+    /**
+     * Class: fs.StatWatcher
+     * @since v14.3.0, v12.20.0
+     * Extends `EventEmitter`
+     * A successful call to {@link watchFile} method will return a new fs.StatWatcher object.
+     */
+    export interface StatWatcher extends EventEmitter {
+        /**
+         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.StatWatcher` is active. Calling `watcher.ref()` multiple times will have
+         * no effect.
+         *
+         * By default, all `fs.StatWatcher` objects are "ref'ed", making it normally
+         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
+         * called previously.
+         * @since v14.3.0, v12.20.0
+         */
+        ref(): this;
+        /**
+         * When called, the active `fs.StatWatcher` object will not require the Node.js
+         * event loop to remain active. If there is no other activity keeping the
+         * event loop running, the process may exit before the `fs.StatWatcher` object's
+         * callback is invoked. Calling `watcher.unref()` multiple times will have
+         * no effect.
+         * @since v14.3.0, v12.20.0
+         */
+        unref(): this;
+    }
+    export interface FSWatcher extends EventEmitter {
+        /**
+         * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
+         * @since v0.5.8
+         */
+        close(): void;
+        /**
+         * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
+         * no effect.
+         *
+         * By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
+         * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
+         * called previously.
+         * @since v14.3.0, v12.20.0
+         */
+        ref(): this;
+        /**
+         * When called, the active `fs.FSWatcher` object will not require the Node.js
+         * event loop to remain active. If there is no other activity keeping the
+         * event loop running, the process may exit before the `fs.FSWatcher` object's
+         * callback is invoked. Calling `watcher.unref()` multiple times will have
+         * no effect.
+         * @since v14.3.0, v12.20.0
+         */
+        unref(): this;
+        /**
+         * events.EventEmitter
+         *   1. change
+         *   2. close
+         *   3. error
+         */
+        addListener(event: string, listener: (...args: any[]) => void): this;
+        addListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "error", listener: (error: Error) => void): this;
+        on(event: string, listener: (...args: any[]) => void): this;
+        on(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "error", listener: (error: Error) => void): this;
+        once(event: string, listener: (...args: any[]) => void): this;
+        once(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "error", listener: (error: Error) => void): this;
+        prependListener(event: string, listener: (...args: any[]) => void): this;
+        prependListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "error", listener: (error: Error) => void): this;
+        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "change", listener: (eventType: string, filename: string | Buffer) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (error: Error) => void): this;
+    }
+    /**
+     * Instances of `fs.ReadStream` are created and returned using the {@link createReadStream} function.
+     * @since v0.1.93
+     */
+    export class ReadStream extends stream.Readable {
+        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
+        /**
+         * The number of bytes that have been read so far.
+         * @since v6.4.0
+         */
+        bytesRead: number;
+        /**
+         * The path to the file the stream is reading from as specified in the first
+         * argument to `fs.createReadStream()`. If `path` is passed as a string, then`readStream.path` will be a string. If `path` is passed as a `Buffer`, then`readStream.path` will be a
+         * `Buffer`. If `fd` is specified, then`readStream.path` will be `undefined`.
+         * @since v0.1.93
+         */
+        path: string | Buffer;
+        /**
+         * This property is `true` if the underlying file has not been opened yet,
+         * i.e. before the `'ready'` event is emitted.
+         * @since v11.2.0, v10.16.0
+         */
+        pending: boolean;
+        /**
+         * events.EventEmitter
+         *   1. open
+         *   2. close
+         *   3. ready
+         */
+        addListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        on<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        once<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        prependListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+        prependOnceListener<K extends keyof ReadStreamEvents>(event: K, listener: ReadStreamEvents[K]): this;
+    }
+
+    /**
+     * The Keys are events of the ReadStream and the values are the functions that are called when the event is emitted.
+     */
+    type ReadStreamEvents = {
+        close: () => void;
+        data: (chunk: Buffer | string) => void;
+        end: () => void;
+        error: (err: Error) => void;
+        open: (fd: number) => void;
+        pause: () => void;
+        readable: () => void;
+        ready: () => void;
+        resume: () => void;
+    } & CustomEvents;
+
+    /**
+     * string & {} allows to allow any kind of strings for the event
+     * but still allows to have auto completion for the normal events.
+     */
+    type CustomEvents = { [Key in string & {} | symbol]: (...args: any[]) => void };
+
+    /**
+     * The Keys are events of the WriteStream and the values are the functions that are called when the event is emitted.
+     */
+    type WriteStreamEvents = {
+        close: () => void;
+        drain: () => void;
+        error: (err: Error) => void;
+        finish: () => void;
+        open: (fd: number) => void;
+        pipe: (src: stream.Readable) => void;
+        ready: () => void;
+        unpipe: (src: stream.Readable) => void;
+    } & CustomEvents;
+    /**
+     * * Extends `stream.Writable`
+     *
+     * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
+     * @since v0.1.93
+     */
+    export class WriteStream extends stream.Writable {
+        /**
+         * Closes `writeStream`. Optionally accepts a
+         * callback that will be executed once the `writeStream`is closed.
+         * @since v0.9.4
+         */
+        close(callback?: (err?: NodeJS.ErrnoException | null) => void): void;
+        /**
+         * The number of bytes written so far. Does not include data that is still queued
+         * for writing.
+         * @since v0.4.7
+         */
+        bytesWritten: number;
+        /**
+         * The path to the file the stream is writing to as specified in the first
+         * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
+         * `Buffer`.
+         * @since v0.1.93
+         */
+        path: string | Buffer;
+        /**
+         * This property is `true` if the underlying file has not been opened yet,
+         * i.e. before the `'ready'` event is emitted.
+         * @since v11.2.0
+         */
+        pending: boolean;
+        /**
+         * events.EventEmitter
+         *   1. open
+         *   2. close
+         *   3. ready
+         */
+        addListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        on<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        once<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        prependListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+        prependOnceListener<K extends keyof WriteStreamEvents>(event: K, listener: WriteStreamEvents[K]): this;
+    }
+    /**
+     * Asynchronously rename file at `oldPath` to the pathname provided
+     * as `newPath`. In the case that `newPath` already exists, it will
+     * be overwritten. If there is a directory at `newPath`, an error will
+     * be raised instead. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See also: [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html).
+     *
+     * ```js
+     * import { rename } from 'node:fs';
+     *
+     * rename('oldFile.txt', 'newFile.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('Rename complete!');
+     * });
+     * ```
+     * @since v0.0.2
+     */
+    export function rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
+    export namespace rename {
+        /**
+         * Asynchronous rename(2) - Change the name or location of a file or directory.
+         * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(oldPath: PathLike, newPath: PathLike): Promise<void>;
+    }
+    /**
+     * Renames the file from `oldPath` to `newPath`. Returns `undefined`.
+     *
+     * See the POSIX [`rename(2)`](http://man7.org/linux/man-pages/man2/rename.2.html) documentation for more details.
+     * @since v0.1.21
+     */
+    export function renameSync(oldPath: PathLike, newPath: PathLike): void;
+    /**
+     * Truncates the file. No arguments other than a possible exception are
+     * given to the completion callback. A file descriptor can also be passed as the
+     * first argument. In this case, `fs.ftruncate()` is called.
+     *
+     * ```js
+     * import { truncate } from 'node:fs';
+     * // Assuming that 'path/file.txt' is a regular file.
+     * truncate('path/file.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('path/file.txt was truncated');
+     * });
+     * ```
+     *
+     * Passing a file descriptor is deprecated and may result in an error being thrown
+     * in the future.
+     *
+     * See the POSIX [`truncate(2)`](http://man7.org/linux/man-pages/man2/truncate.2.html) documentation for more details.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function truncate(path: PathLike, len: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronous truncate(2) - Truncate a file to a specified length.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function truncate(path: PathLike, callback: NoParamCallback): void;
+    export namespace truncate {
+        /**
+         * Asynchronous truncate(2) - Truncate a file to a specified length.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param len If not specified, defaults to `0`.
+         */
+        function __promisify__(path: PathLike, len?: number): Promise<void>;
+    }
+    /**
+     * Truncates the file. Returns `undefined`. A file descriptor can also be
+     * passed as the first argument. In this case, `fs.ftruncateSync()` is called.
+     *
+     * Passing a file descriptor is deprecated and may result in an error being thrown
+     * in the future.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function truncateSync(path: PathLike, len?: number): void;
+    /**
+     * Truncates the file descriptor. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See the POSIX [`ftruncate(2)`](http://man7.org/linux/man-pages/man2/ftruncate.2.html) documentation for more detail.
+     *
+     * If the file referred to by the file descriptor was larger than `len` bytes, only
+     * the first `len` bytes will be retained in the file.
+     *
+     * For example, the following program retains only the first four bytes of the
+     * file:
+     *
+     * ```js
+     * import { open, close, ftruncate } from 'node:fs';
+     *
+     * function closeFd(fd) {
+     *   close(fd, (err) => {
+     *     if (err) throw err;
+     *   });
+     * }
+     *
+     * open('temp.txt', 'r+', (err, fd) => {
+     *   if (err) throw err;
+     *
+     *   try {
+     *     ftruncate(fd, 4, (err) => {
+     *       closeFd(fd);
+     *       if (err) throw err;
+     *     });
+     *   } catch (err) {
+     *     closeFd(fd);
+     *     if (err) throw err;
+     *   }
+     * });
+     * ```
+     *
+     * If the file previously was shorter than `len` bytes, it is extended, and the
+     * extended part is filled with null bytes (`'\0'`):
+     *
+     * If `len` is negative then `0` will be used.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function ftruncate(fd: number, len: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronous ftruncate(2) - Truncate a file to a specified length.
+     * @param fd A file descriptor.
+     */
+    export function ftruncate(fd: number, callback: NoParamCallback): void;
+    export namespace ftruncate {
+        /**
+         * Asynchronous ftruncate(2) - Truncate a file to a specified length.
+         * @param fd A file descriptor.
+         * @param len If not specified, defaults to `0`.
+         */
+        function __promisify__(fd: number, len?: number): Promise<void>;
+    }
+    /**
+     * Truncates the file descriptor. Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link ftruncate}.
+     * @since v0.8.6
+     * @param [len=0]
+     */
+    export function ftruncateSync(fd: number, len?: number): void;
+    /**
+     * Asynchronously changes owner and group of a file. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
+     * @since v0.1.97
+     */
+    export function chown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace chown {
+        /**
+         * Asynchronous chown(2) - Change ownership of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Synchronously changes owner and group of a file. Returns `undefined`.
+     * This is the synchronous version of {@link chown}.
+     *
+     * See the POSIX [`chown(2)`](http://man7.org/linux/man-pages/man2/chown.2.html) documentation for more detail.
+     * @since v0.1.97
+     */
+    export function chownSync(path: PathLike, uid: number, gid: number): void;
+    /**
+     * Sets the owner of the file. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchown(fd: number, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace fchown {
+        /**
+         * Asynchronous fchown(2) - Change ownership of a file.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Sets the owner of the file. Returns `undefined`.
+     *
+     * See the POSIX [`fchown(2)`](http://man7.org/linux/man-pages/man2/fchown.2.html) documentation for more detail.
+     * @since v0.4.7
+     * @param uid The file's new owner's user id.
+     * @param gid The file's new group's group id.
+     */
+    export function fchownSync(fd: number, uid: number, gid: number): void;
+    /**
+     * Set the owner of the symbolic link. No arguments other than a possible
+     * exception are given to the completion callback.
+     *
+     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more detail.
+     */
+    export function lchown(path: PathLike, uid: number, gid: number, callback: NoParamCallback): void;
+    export namespace lchown {
+        /**
+         * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, uid: number, gid: number): Promise<void>;
+    }
+    /**
+     * Set the owner for the path. Returns `undefined`.
+     *
+     * See the POSIX [`lchown(2)`](http://man7.org/linux/man-pages/man2/lchown.2.html) documentation for more details.
+     * @param uid The file's new owner's user id.
+     * @param gid The file's new group's group id.
+     */
+    export function lchownSync(path: PathLike, uid: number, gid: number): void;
+    /**
+     * Changes the access and modification times of a file in the same way as {@link utimes}, with the difference that if the path refers to a symbolic
+     * link, then the link is not dereferenced: instead, the timestamps of the
+     * symbolic link itself are changed.
+     *
+     * No arguments other than a possible exception are given to the completion
+     * callback.
+     * @since v14.5.0, v12.19.0
+     */
+    export function lutimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace lutimes {
+        /**
+         * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
+         * with the difference that if the path refers to a symbolic link, then the link is not
+         * dereferenced: instead, the timestamps of the symbolic link itself are changed.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Change the file system timestamps of the symbolic link referenced by `path`.
+     * Returns `undefined`, or throws an exception when parameters are incorrect or
+     * the operation fails. This is the synchronous version of {@link lutimes}.
+     * @since v14.5.0, v12.19.0
+     */
+    export function lutimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Asynchronously changes the permissions of a file. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
+     *
+     * ```js
+     * import { chmod } from 'node:fs';
+     *
+     * chmod('my_file.txt', 0o775, (err) => {
+     *   if (err) throw err;
+     *   console.log('The permissions for file "my_file.txt" have been changed!');
+     * });
+     * ```
+     * @since v0.1.30
+     */
+    export function chmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
+    export namespace chmod {
+        /**
+         * Asynchronous chmod(2) - Change permissions of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link chmod}.
+     *
+     * See the POSIX [`chmod(2)`](http://man7.org/linux/man-pages/man2/chmod.2.html) documentation for more detail.
+     * @since v0.6.7
+     */
+    export function chmodSync(path: PathLike, mode: Mode): void;
+    /**
+     * Sets the permissions on the file. No arguments other than a possible exception
+     * are given to the completion callback.
+     *
+     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchmod(fd: number, mode: Mode, callback: NoParamCallback): void;
+    export namespace fchmod {
+        /**
+         * Asynchronous fchmod(2) - Change permissions of a file.
+         * @param fd A file descriptor.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(fd: number, mode: Mode): Promise<void>;
+    }
+    /**
+     * Sets the permissions on the file. Returns `undefined`.
+     *
+     * See the POSIX [`fchmod(2)`](http://man7.org/linux/man-pages/man2/fchmod.2.html) documentation for more detail.
+     * @since v0.4.7
+     */
+    export function fchmodSync(fd: number, mode: Mode): void;
+    /**
+     * Changes the permissions on a symbolic link. No arguments other than a possible
+     * exception are given to the completion callback.
+     *
+     * This method is only implemented on macOS.
+     *
+     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
+     * @deprecated Since v0.4.7
+     */
+    export function lchmod(path: PathLike, mode: Mode, callback: NoParamCallback): void;
+    /** @deprecated */
+    export namespace lchmod {
+        /**
+         * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
+         */
+        function __promisify__(path: PathLike, mode: Mode): Promise<void>;
+    }
+    /**
+     * Changes the permissions on a symbolic link. Returns `undefined`.
+     *
+     * This method is only implemented on macOS.
+     *
+     * See the POSIX [`lchmod(2)`](https://www.freebsd.org/cgi/man.cgi?query=lchmod&sektion=2) documentation for more detail.
+     * @deprecated Since v0.4.7
+     */
+    export function lchmodSync(path: PathLike, mode: Mode): void;
+    /**
+     * Asynchronous [`stat(2)`](http://man7.org/linux/man-pages/man2/stat.2.html). The callback gets two arguments `(err, stats)` where`stats` is an `fs.Stats` object.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     *
+     * {@link stat} follows symbolic links. Use {@link lstat} to look at the
+     * links themselves.
+     *
+     * Using `fs.stat()` to check for the existence of a file before calling`fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended.
+     * Instead, user code should open/read/write the file directly and handle the
+     * error raised if the file is not available.
+     *
+     * To check if a file exists without manipulating it afterwards, {@link access} is recommended.
+     *
+     * For example, given the following directory structure:
+     *
+     * ```text
+     * - txtDir
+     * -- file.txt
+     * - app.js
+     * ```
+     *
+     * The next program will check for the stats of the given paths:
+     *
+     * ```js
+     * import { stat } from 'node:fs';
+     *
+     * const pathsToCheck = ['./txtDir', './txtDir/file.txt'];
+     *
+     * for (let i = 0; i < pathsToCheck.length; i++) {
+     *   stat(pathsToCheck[i], (err, stats) => {
+     *     console.log(stats.isDirectory());
+     *     console.log(stats);
+     *   });
+     * }
+     * ```
+     *
+     * The resulting output will resemble:
+     *
+     * ```console
+     * true
+     * Stats {
+     *   dev: 16777220,
+     *   mode: 16877,
+     *   nlink: 3,
+     *   uid: 501,
+     *   gid: 20,
+     *   rdev: 0,
+     *   blksize: 4096,
+     *   ino: 14214262,
+     *   size: 96,
+     *   blocks: 0,
+     *   atimeMs: 1561174653071.963,
+     *   mtimeMs: 1561174614583.3518,
+     *   ctimeMs: 1561174626623.5366,
+     *   birthtimeMs: 1561174126937.2893,
+     *   atime: 2019-06-22T03:37:33.072Z,
+     *   mtime: 2019-06-22T03:36:54.583Z,
+     *   ctime: 2019-06-22T03:37:06.624Z,
+     *   birthtime: 2019-06-22T03:28:46.937Z
+     * }
+     * false
+     * Stats {
+     *   dev: 16777220,
+     *   mode: 33188,
+     *   nlink: 1,
+     *   uid: 501,
+     *   gid: 20,
+     *   rdev: 0,
+     *   blksize: 4096,
+     *   ino: 14214074,
+     *   size: 8,
+     *   blocks: 8,
+     *   atimeMs: 1561174616618.8555,
+     *   mtimeMs: 1561174614584,
+     *   ctimeMs: 1561174614583.8145,
+     *   birthtimeMs: 1561174007710.7478,
+     *   atime: 2019-06-22T03:36:56.619Z,
+     *   mtime: 2019-06-22T03:36:54.584Z,
+     *   ctime: 2019-06-22T03:36:54.584Z,
+     *   birthtime: 2019-06-22T03:26:47.711Z
+     * }
+     * ```
+     * @since v0.0.2
+     */
+    export function stat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function stat(
+        path: PathLike,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function stat(
+        path: PathLike,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function stat(
+        path: PathLike,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace stat {
+        /**
+         * Asynchronous stat(2) - Get file status.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            path: PathLike,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    export interface StatSyncFn extends Function {
+        (path: PathLike, options?: undefined): Stats;
+        (
+            path: PathLike,
+            options?: StatSyncOptions & {
+                bigint?: false | undefined;
+                throwIfNoEntry: false;
+            },
+        ): Stats | undefined;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: true;
+                throwIfNoEntry: false;
+            },
+        ): BigIntStats | undefined;
+        (
+            path: PathLike,
+            options?: StatSyncOptions & {
+                bigint?: false | undefined;
+            },
+        ): Stats;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: true;
+            },
+        ): BigIntStats;
+        (
+            path: PathLike,
+            options: StatSyncOptions & {
+                bigint: boolean;
+                throwIfNoEntry?: false | undefined;
+            },
+        ): Stats | BigIntStats;
+        (path: PathLike, options?: StatSyncOptions): Stats | BigIntStats | undefined;
+    }
+    /**
+     * Synchronous stat(2) - Get file status.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export const statSync: StatSyncFn;
+    /**
+     * Invokes the callback with the `fs.Stats` for the file descriptor.
+     *
+     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
+     * @since v0.1.95
+     */
+    export function fstat(fd: number, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function fstat(
+        fd: number,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function fstat(
+        fd: number,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function fstat(
+        fd: number,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace fstat {
+        /**
+         * Asynchronous fstat(2) - Get file status.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(
+            fd: number,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            fd: number,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(fd: number, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    /**
+     * Retrieves the `fs.Stats` for the file descriptor.
+     *
+     * See the POSIX [`fstat(2)`](http://man7.org/linux/man-pages/man2/fstat.2.html) documentation for more detail.
+     * @since v0.1.95
+     */
+    export function fstatSync(
+        fd: number,
+        options?: StatOptions & {
+            bigint?: false | undefined;
+        },
+    ): Stats;
+    export function fstatSync(
+        fd: number,
+        options: StatOptions & {
+            bigint: true;
+        },
+    ): BigIntStats;
+    export function fstatSync(fd: number, options?: StatOptions): Stats | BigIntStats;
+    /**
+     * Retrieves the `fs.Stats` for the symbolic link referred to by the path.
+     * The callback gets two arguments `(err, stats)` where `stats` is a `fs.Stats` object. `lstat()` is identical to `stat()`, except that if `path` is a symbolic
+     * link, then the link itself is stat-ed, not the file that it refers to.
+     *
+     * See the POSIX [`lstat(2)`](http://man7.org/linux/man-pages/man2/lstat.2.html) documentation for more details.
+     * @since v0.1.30
+     */
+    export function lstat(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void): void;
+    export function lstat(
+        path: PathLike,
+        options:
+            | (StatOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats) => void,
+    ): void;
+    export function lstat(
+        path: PathLike,
+        options: StatOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStats) => void,
+    ): void;
+    export function lstat(
+        path: PathLike,
+        options: StatOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: Stats | BigIntStats) => void,
+    ): void;
+    export namespace lstat {
+        /**
+         * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<Stats>;
+        function __promisify__(
+            path: PathLike,
+            options: StatOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStats>;
+        function __promisify__(path: PathLike, options?: StatOptions): Promise<Stats | BigIntStats>;
+    }
+    /**
+     * Asynchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
+     * contains `path`. The callback gets two arguments `(err, stats)` where `stats`is an `fs.StatFs` object.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     * @since v19.6.0, v18.15.0
+     * @param path A path to an existing file or directory on the file system to be queried.
+     */
+    export function statfs(path: PathLike, callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void): void;
+    export function statfs(
+        path: PathLike,
+        options:
+            | (StatFsOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs) => void,
+    ): void;
+    export function statfs(
+        path: PathLike,
+        options: StatFsOptions & {
+            bigint: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, stats: BigIntStatsFs) => void,
+    ): void;
+    export function statfs(
+        path: PathLike,
+        options: StatFsOptions | undefined,
+        callback: (err: NodeJS.ErrnoException | null, stats: StatsFs | BigIntStatsFs) => void,
+    ): void;
+    export namespace statfs {
+        /**
+         * Asynchronous statfs(2) - Returns information about the mounted file system which contains path. The callback gets two arguments (err, stats) where stats is an <fs.StatFs> object.
+         * @param path A path to an existing file or directory on the file system to be queried.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: StatFsOptions & {
+                bigint?: false | undefined;
+            },
+        ): Promise<StatsFs>;
+        function __promisify__(
+            path: PathLike,
+            options: StatFsOptions & {
+                bigint: true;
+            },
+        ): Promise<BigIntStatsFs>;
+        function __promisify__(path: PathLike, options?: StatFsOptions): Promise<StatsFs | BigIntStatsFs>;
+    }
+    /**
+     * Synchronous [`statfs(2)`](http://man7.org/linux/man-pages/man2/statfs.2.html). Returns information about the mounted file system which
+     * contains `path`.
+     *
+     * In case of an error, the `err.code` will be one of `Common System Errors`.
+     * @since v19.6.0, v18.15.0
+     * @param path A path to an existing file or directory on the file system to be queried.
+     */
+    export function statfsSync(
+        path: PathLike,
+        options?: StatFsOptions & {
+            bigint?: false | undefined;
+        },
+    ): StatsFs;
+    export function statfsSync(
+        path: PathLike,
+        options: StatFsOptions & {
+            bigint: true;
+        },
+    ): BigIntStatsFs;
+    export function statfsSync(path: PathLike, options?: StatFsOptions): StatsFs | BigIntStatsFs;
+    /**
+     * Synchronous lstat(2) - Get file status. Does not dereference symbolic links.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export const lstatSync: StatSyncFn;
+    /**
+     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. No arguments other than
+     * a possible
+     * exception are given to the completion callback.
+     * @since v0.1.31
+     */
+    export function link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): void;
+    export namespace link {
+        /**
+         * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
+         * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(existingPath: PathLike, newPath: PathLike): Promise<void>;
+    }
+    /**
+     * Creates a new link from the `existingPath` to the `newPath`. See the POSIX [`link(2)`](http://man7.org/linux/man-pages/man2/link.2.html) documentation for more detail. Returns `undefined`.
+     * @since v0.1.31
+     */
+    export function linkSync(existingPath: PathLike, newPath: PathLike): void;
+    /**
+     * Creates the link called `path` pointing to `target`. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * See the POSIX [`symlink(2)`](http://man7.org/linux/man-pages/man2/symlink.2.html) documentation for more details.
+     *
+     * The `type` argument is only available on Windows and ignored on other platforms.
+     * It can be set to `'dir'`, `'file'`, or `'junction'`. If the `type` argument is
+     * not a string, Node.js will autodetect `target` type and use `'file'` or `'dir'`.
+     * If the `target` does not exist, `'file'` will be used. Windows junction points
+     * require the destination path to be absolute. When using `'junction'`, the`target` argument will automatically be normalized to absolute path. Junction
+     * points on NTFS volumes can only point to directories.
+     *
+     * Relative targets are relative to the link's parent directory.
+     *
+     * ```js
+     * import { symlink } from 'node:fs';
+     *
+     * symlink('./mew', './mewtwo', callback);
+     * ```
+     *
+     * The above example creates a symbolic link `mewtwo` which points to `mew` in the
+     * same directory:
+     *
+     * ```bash
+     * $ tree .
+     * .
+     *  mew
+     *  mewtwo -> ./mew
+     * ```
+     * @since v0.1.31
+     * @param [type='null']
+     */
+    export function symlink(
+        target: PathLike,
+        path: PathLike,
+        type: symlink.Type | undefined | null,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
+     * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
+     * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function symlink(target: PathLike, path: PathLike, callback: NoParamCallback): void;
+    export namespace symlink {
+        /**
+         * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
+         * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
+         * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
+         * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
+         * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
+         */
+        function __promisify__(target: PathLike, path: PathLike, type?: string | null): Promise<void>;
+        type Type = "dir" | "file" | "junction";
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link symlink}.
+     * @since v0.1.31
+     * @param [type='null']
+     */
+    export function symlinkSync(target: PathLike, path: PathLike, type?: symlink.Type | null): void;
+    /**
+     * Reads the contents of the symbolic link referred to by `path`. The callback gets
+     * two arguments `(err, linkString)`.
+     *
+     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the link path passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the link path returned will be passed as a `Buffer` object.
+     * @since v0.1.31
+     */
+    export function readlink(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlink(
+        path: PathLike,
+        options: BufferEncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlink(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function readlink(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, linkString: string) => void,
+    ): void;
+    export namespace readlink {
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronous readlink(2) - read value of a symbolic link.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
+    }
+    /**
+     * Returns the symbolic link's string value.
+     *
+     * See the POSIX [`readlink(2)`](http://man7.org/linux/man-pages/man2/readlink.2.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the link path returned. If the `encoding` is set to `'buffer'`,
+     * the link path returned will be passed as a `Buffer` object.
+     * @since v0.1.31
+     */
+    export function readlinkSync(path: PathLike, options?: EncodingOption): string;
+    /**
+     * Synchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronous readlink(2) - read value of a symbolic link.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readlinkSync(path: PathLike, options?: EncodingOption): string | Buffer;
+    /**
+     * Asynchronously computes the canonical pathname by resolving `.`, `..`, and
+     * symbolic links.
+     *
+     * A canonical pathname is not necessarily unique. Hard links and bind mounts can
+     * expose a file system entity through many pathnames.
+     *
+     * This function behaves like [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html), with some exceptions:
+     *
+     * 1. No case conversion is performed on case-insensitive file systems.
+     * 2. The maximum number of symbolic links is platform-independent and generally
+     * (much) higher than what the native [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html) implementation supports.
+     *
+     * The `callback` gets two arguments `(err, resolvedPath)`. May use `process.cwd` to resolve relative paths.
+     *
+     * Only paths that can be converted to UTF8 strings are supported.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the path passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the path returned will be passed as a `Buffer` object.
+     *
+     * If `path` resolves to a socket or a pipe, the function will return a system
+     * dependent name for that object.
+     * @since v0.1.31
+     */
+    export function realpath(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpath(
+        path: PathLike,
+        options: BufferEncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpath(
+        path: PathLike,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function realpath(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+    ): void;
+    export namespace realpath {
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronous realpath(3) - return the canonicalized absolute pathname.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(path: PathLike, options?: EncodingOption): Promise<string | Buffer>;
+        /**
+         * Asynchronous [`realpath(3)`](http://man7.org/linux/man-pages/man3/realpath.3.html).
+         *
+         * The `callback` gets two arguments `(err, resolvedPath)`.
+         *
+         * Only paths that can be converted to UTF8 strings are supported.
+         *
+         * The optional `options` argument can be a string specifying an encoding, or an
+         * object with an `encoding` property specifying the character encoding to use for
+         * the path passed to the callback. If the `encoding` is set to `'buffer'`,
+         * the path returned will be passed as a `Buffer` object.
+         *
+         * On Linux, when Node.js is linked against musl libc, the procfs file system must
+         * be mounted on `/proc` in order for this function to work. Glibc does not have
+         * this restriction.
+         * @since v9.2.0
+         */
+        function native(
+            path: PathLike,
+            options: EncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            options: BufferEncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: Buffer) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            options: EncodingOption,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string | Buffer) => void,
+        ): void;
+        function native(
+            path: PathLike,
+            callback: (err: NodeJS.ErrnoException | null, resolvedPath: string) => void,
+        ): void;
+    }
+    /**
+     * Returns the resolved pathname.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link realpath}.
+     * @since v0.1.31
+     */
+    export function realpathSync(path: PathLike, options?: EncodingOption): string;
+    /**
+     * Synchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpathSync(path: PathLike, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronous realpath(3) - return the canonicalized absolute pathname.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function realpathSync(path: PathLike, options?: EncodingOption): string | Buffer;
+    export namespace realpathSync {
+        function native(path: PathLike, options?: EncodingOption): string;
+        function native(path: PathLike, options: BufferEncodingOption): Buffer;
+        function native(path: PathLike, options?: EncodingOption): string | Buffer;
+    }
+    /**
+     * Asynchronously removes a file or symbolic link. No arguments other than a
+     * possible exception are given to the completion callback.
+     *
+     * ```js
+     * import { unlink } from 'node:fs';
+     * // Assuming that 'path/file.txt' is a regular file.
+     * unlink('path/file.txt', (err) => {
+     *   if (err) throw err;
+     *   console.log('path/file.txt was deleted');
+     * });
+     * ```
+     *
+     * `fs.unlink()` will not work on a directory, empty or otherwise. To remove a
+     * directory, use {@link rmdir}.
+     *
+     * See the POSIX [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html) documentation for more details.
+     * @since v0.0.2
+     */
+    export function unlink(path: PathLike, callback: NoParamCallback): void;
+    export namespace unlink {
+        /**
+         * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike): Promise<void>;
+    }
+    /**
+     * Synchronous [`unlink(2)`](http://man7.org/linux/man-pages/man2/unlink.2.html). Returns `undefined`.
+     * @since v0.1.21
+     */
+    export function unlinkSync(path: PathLike): void;
+    export interface RmDirOptions {
+        /**
+         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
+         * `EPERM` error is encountered, Node.js will retry the operation with a linear
+         * backoff wait of `retryDelay` ms longer on each try. This option represents the
+         * number of retries. This option is ignored if the `recursive` option is not
+         * `true`.
+         * @default 0
+         */
+        maxRetries?: number | undefined;
+        /**
+         * @deprecated since v14.14.0 In future versions of Node.js and will trigger a warning
+         * `fs.rmdir(path, { recursive: true })` will throw if `path` does not exist or is a file.
+         * Use `fs.rm(path, { recursive: true, force: true })` instead.
+         *
+         * If `true`, perform a recursive directory removal. In
+         * recursive mode, operations are retried on failure.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * The amount of time in milliseconds to wait between retries.
+         * This option is ignored if the `recursive` option is not `true`.
+         * @default 100
+         */
+        retryDelay?: number | undefined;
+    }
+    /**
+     * Asynchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). No arguments other than a possible exception are given
+     * to the completion callback.
+     *
+     * Using `fs.rmdir()` on a file (not a directory) results in an `ENOENT` error on
+     * Windows and an `ENOTDIR` error on POSIX.
+     *
+     * To get a behavior similar to the `rm -rf` Unix command, use {@link rm} with options `{ recursive: true, force: true }`.
+     * @since v0.0.2
+     */
+    export function rmdir(path: PathLike, callback: NoParamCallback): void;
+    export function rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): void;
+    export namespace rmdir {
+        /**
+         * Asynchronous rmdir(2) - delete a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         */
+        function __promisify__(path: PathLike, options?: RmDirOptions): Promise<void>;
+    }
+    /**
+     * Synchronous [`rmdir(2)`](http://man7.org/linux/man-pages/man2/rmdir.2.html). Returns `undefined`.
+     *
+     * Using `fs.rmdirSync()` on a file (not a directory) results in an `ENOENT` error
+     * on Windows and an `ENOTDIR` error on POSIX.
+     *
+     * To get a behavior similar to the `rm -rf` Unix command, use {@link rmSync} with options `{ recursive: true, force: true }`.
+     * @since v0.1.21
+     */
+    export function rmdirSync(path: PathLike, options?: RmDirOptions): void;
+    export interface RmOptions {
+        /**
+         * When `true`, exceptions will be ignored if `path` does not exist.
+         * @default false
+         */
+        force?: boolean | undefined;
+        /**
+         * If an `EBUSY`, `EMFILE`, `ENFILE`, `ENOTEMPTY`, or
+         * `EPERM` error is encountered, Node.js will retry the operation with a linear
+         * backoff wait of `retryDelay` ms longer on each try. This option represents the
+         * number of retries. This option is ignored if the `recursive` option is not
+         * `true`.
+         * @default 0
+         */
+        maxRetries?: number | undefined;
+        /**
+         * If `true`, perform a recursive directory removal. In
+         * recursive mode, operations are retried on failure.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * The amount of time in milliseconds to wait between retries.
+         * This option is ignored if the `recursive` option is not `true`.
+         * @default 100
+         */
+        retryDelay?: number | undefined;
+    }
+    /**
+     * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility). No arguments other than a possible exception are given to the
+     * completion callback.
+     * @since v14.14.0
+     */
+    export function rm(path: PathLike, callback: NoParamCallback): void;
+    export function rm(path: PathLike, options: RmOptions, callback: NoParamCallback): void;
+    export namespace rm {
+        /**
+         * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
+         */
+        function __promisify__(path: PathLike, options?: RmOptions): Promise<void>;
+    }
+    /**
+     * Synchronously removes files and directories (modeled on the standard POSIX `rm` utility). Returns `undefined`.
+     * @since v14.14.0
+     */
+    export function rmSync(path: PathLike, options?: RmOptions): void;
+    export interface MakeDirectoryOptions {
+        /**
+         * Indicates whether parent folders should be created.
+         * If a folder was created, the path to the first created folder will be returned.
+         * @default false
+         */
+        recursive?: boolean | undefined;
+        /**
+         * A file mode. If a string is passed, it is parsed as an octal integer. If not specified
+         * @default 0o777
+         */
+        mode?: Mode | undefined;
+    }
+    /**
+     * Asynchronously creates a directory.
+     *
+     * The callback is given a possible exception and, if `recursive` is `true`, the
+     * first directory path created, `(err[, path])`.`path` can still be `undefined` when `recursive` is `true`, if no directory was
+     * created (for instance, if it was previously created).
+     *
+     * The optional `options` argument can be an integer specifying `mode` (permission
+     * and sticky bits), or an object with a `mode` property and a `recursive` property indicating whether parent directories should be created. Calling `fs.mkdir()` when `path` is a directory that
+     * exists results in an error only
+     * when `recursive` is false. If `recursive` is false and the directory exists,
+     * an `EEXIST` error occurs.
+     *
+     * ```js
+     * import { mkdir } from 'node:fs';
+     *
+     * // Create ./tmp/a/apple, regardless of whether ./tmp and ./tmp/a exist.
+     * mkdir('./tmp/a/apple', { recursive: true }, (err) => {
+     *   if (err) throw err;
+     * });
+     * ```
+     *
+     * On Windows, using `fs.mkdir()` on the root directory even with recursion will
+     * result in an error:
+     *
+     * ```js
+     * import { mkdir } from 'node:fs';
+     *
+     * mkdir('/', { recursive: true }, (err) => {
+     *   // => [Error: EPERM: operation not permitted, mkdir 'C:\']
+     * });
+     * ```
+     *
+     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
+     * @since v0.1.8
+     */
+    export function mkdir(
+        path: PathLike,
+        options: MakeDirectoryOptions & {
+            recursive: true;
+        },
+        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdir(
+        path: PathLike,
+        options:
+            | Mode
+            | (MakeDirectoryOptions & {
+                recursive?: false | undefined;
+            })
+            | null
+            | undefined,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdir(
+        path: PathLike,
+        options: Mode | MakeDirectoryOptions | null | undefined,
+        callback: (err: NodeJS.ErrnoException | null, path?: string) => void,
+    ): void;
+    /**
+     * Asynchronous mkdir(2) - create a directory with a mode of `0o777`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function mkdir(path: PathLike, callback: NoParamCallback): void;
+    export namespace mkdir {
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options: MakeDirectoryOptions & {
+                recursive: true;
+            },
+        ): Promise<string | undefined>;
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | Mode
+                | (MakeDirectoryOptions & {
+                    recursive?: false | undefined;
+                })
+                | null,
+        ): Promise<void>;
+        /**
+         * Asynchronous mkdir(2) - create a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+         * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?: Mode | MakeDirectoryOptions | null,
+        ): Promise<string | undefined>;
+    }
+    /**
+     * Synchronously creates a directory. Returns `undefined`, or if `recursive` is `true`, the first directory path created.
+     * This is the synchronous version of {@link mkdir}.
+     *
+     * See the POSIX [`mkdir(2)`](http://man7.org/linux/man-pages/man2/mkdir.2.html) documentation for more details.
+     * @since v0.1.21
+     */
+    export function mkdirSync(
+        path: PathLike,
+        options: MakeDirectoryOptions & {
+            recursive: true;
+        },
+    ): string | undefined;
+    /**
+     * Synchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdirSync(
+        path: PathLike,
+        options?:
+            | Mode
+            | (MakeDirectoryOptions & {
+                recursive?: false | undefined;
+            })
+            | null,
+    ): void;
+    /**
+     * Synchronous mkdir(2) - create a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
+     * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
+     */
+    export function mkdirSync(path: PathLike, options?: Mode | MakeDirectoryOptions | null): string | undefined;
+    /**
+     * Creates a unique temporary directory.
+     *
+     * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory. Due to platform
+     * inconsistencies, avoid trailing `X` characters in `prefix`. Some platforms,
+     * notably the BSDs, can return more than six random characters, and replace
+     * trailing `X` characters in `prefix` with random characters.
+     *
+     * The created directory path is passed as a string to the callback's second
+     * parameter.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use.
+     *
+     * ```js
+     * import { mkdtemp } from 'node:fs';
+     * import { join } from 'node:path';
+     * import { tmpdir } from 'node:os';
+     *
+     * mkdtemp(join(tmpdir(), 'foo-'), (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Prints: /tmp/foo-itXde2 or C:\Users\...\AppData\Local\Temp\foo-itXde2
+     * });
+     * ```
+     *
+     * The `fs.mkdtemp()` method will append the six randomly selected characters
+     * directly to the `prefix` string. For instance, given a directory `/tmp`, if the
+     * intention is to create a temporary directory _within_`/tmp`, the `prefix`must end with a trailing platform-specific path separator
+     * (`import { sep } from 'node:path'`).
+     *
+     * ```js
+     * import { tmpdir } from 'node:os';
+     * import { mkdtemp } from 'node:fs';
+     *
+     * // The parent directory for the new temporary directory
+     * const tmpDir = tmpdir();
+     *
+     * // This method is *INCORRECT*:
+     * mkdtemp(tmpDir, (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Will print something similar to `/tmpabc123`.
+     *   // A new temporary directory is created at the file system root
+     *   // rather than *within* the /tmp directory.
+     * });
+     *
+     * // This method is *CORRECT*:
+     * import { sep } from 'node:path';
+     * mkdtemp(`${tmpDir}${sep}`, (err, directory) => {
+     *   if (err) throw err;
+     *   console.log(directory);
+     *   // Will print something similar to `/tmp/abc123`.
+     *   // A new temporary directory is created within
+     *   // the /tmp directory.
+     * });
+     * ```
+     * @since v5.10.0
+     */
+    export function mkdtemp(
+        prefix: string,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtemp(
+        prefix: string,
+        options:
+            | "buffer"
+            | {
+                encoding: "buffer";
+            },
+        callback: (err: NodeJS.ErrnoException | null, folder: Buffer) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtemp(
+        prefix: string,
+        options: EncodingOption,
+        callback: (err: NodeJS.ErrnoException | null, folder: string | Buffer) => void,
+    ): void;
+    /**
+     * Asynchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     */
+    export function mkdtemp(
+        prefix: string,
+        callback: (err: NodeJS.ErrnoException | null, folder: string) => void,
+    ): void;
+    export namespace mkdtemp {
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options?: EncodingOption): Promise<string>;
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options: BufferEncodingOption): Promise<Buffer>;
+        /**
+         * Asynchronously creates a unique temporary directory.
+         * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(prefix: string, options?: EncodingOption): Promise<string | Buffer>;
+    }
+    /**
+     * Returns the created directory path.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link mkdtemp}.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use.
+     * @since v5.10.0
+     */
+    export function mkdtempSync(prefix: string, options?: EncodingOption): string;
+    /**
+     * Synchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtempSync(prefix: string, options: BufferEncodingOption): Buffer;
+    /**
+     * Synchronously creates a unique temporary directory.
+     * Generates six random characters to be appended behind a required prefix to create a unique temporary directory.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function mkdtempSync(prefix: string, options?: EncodingOption): string | Buffer;
+    /**
+     * Reads the contents of a directory. The callback gets two arguments `(err, files)` where `files` is an array of the names of the files in the directory excluding `'.'` and `'..'`.
+     *
+     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the filenames passed to the callback. If the `encoding` is set to `'buffer'`,
+     * the filenames returned will be passed as `Buffer` objects.
+     *
+     * If `options.withFileTypes` is set to `true`, the `files` array will contain `fs.Dirent` objects.
+     * @since v0.1.8
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | {
+                encoding: BufferEncoding | null;
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | {
+                encoding: "buffer";
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | "buffer",
+        callback: (err: NodeJS.ErrnoException | null, files: Buffer[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdir(
+        path: PathLike,
+        options:
+            | (ObjectEncodingOptions & {
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            })
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, files: string[] | Buffer[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function readdir(
+        path: PathLike,
+        callback: (err: NodeJS.ErrnoException | null, files: string[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
+     */
+    export function readdir(
+        path: PathLike,
+        options: ObjectEncodingOptions & {
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+        callback: (err: NodeJS.ErrnoException | null, files: Dirent[]) => void,
+    ): void;
+    /**
+     * Asynchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+     */
+    export function readdir(
+        path: PathLike,
+        options: {
+            encoding: "buffer";
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+        callback: (err: NodeJS.ErrnoException | null, files: Dirent<Buffer>[]) => void,
+    ): void;
+    export namespace readdir {
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | {
+                    encoding: BufferEncoding | null;
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                }
+                | BufferEncoding
+                | null,
+        ): Promise<string[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options:
+                | "buffer"
+                | {
+                    encoding: "buffer";
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                },
+        ): Promise<Buffer[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+         */
+        function __promisify__(
+            path: PathLike,
+            options?:
+                | (ObjectEncodingOptions & {
+                    withFileTypes?: false | undefined;
+                    recursive?: boolean | undefined;
+                })
+                | BufferEncoding
+                | null,
+        ): Promise<string[] | Buffer[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options If called with `withFileTypes: true` the result data will be an array of Dirent
+         */
+        function __promisify__(
+            path: PathLike,
+            options: ObjectEncodingOptions & {
+                withFileTypes: true;
+                recursive?: boolean | undefined;
+            },
+        ): Promise<Dirent[]>;
+        /**
+         * Asynchronous readdir(3) - read a directory.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+         */
+        function __promisify__(
+            path: PathLike,
+            options: {
+                encoding: "buffer";
+                withFileTypes: true;
+                recursive?: boolean | undefined;
+            },
+        ): Promise<Dirent<Buffer>[]>;
+    }
+    /**
+     * Reads the contents of the directory.
+     *
+     * See the POSIX [`readdir(3)`](http://man7.org/linux/man-pages/man3/readdir.3.html) documentation for more details.
+     *
+     * The optional `options` argument can be a string specifying an encoding, or an
+     * object with an `encoding` property specifying the character encoding to use for
+     * the filenames returned. If the `encoding` is set to `'buffer'`,
+     * the filenames returned will be passed as `Buffer` objects.
+     *
+     * If `options.withFileTypes` is set to `true`, the result will contain `fs.Dirent` objects.
+     * @since v0.1.21
+     */
+    export function readdirSync(
+        path: PathLike,
+        options?:
+            | {
+                encoding: BufferEncoding | null;
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | BufferEncoding
+            | null,
+    ): string[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options:
+            | {
+                encoding: "buffer";
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            }
+            | "buffer",
+    ): Buffer[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options?:
+            | (ObjectEncodingOptions & {
+                withFileTypes?: false | undefined;
+                recursive?: boolean | undefined;
+            })
+            | BufferEncoding
+            | null,
+    ): string[] | Buffer[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options: ObjectEncodingOptions & {
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+    ): Dirent[];
+    /**
+     * Synchronous readdir(3) - read a directory.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param options Must include `withFileTypes: true` and `encoding: 'buffer'`.
+     */
+    export function readdirSync(
+        path: PathLike,
+        options: {
+            encoding: "buffer";
+            withFileTypes: true;
+            recursive?: boolean | undefined;
+        },
+    ): Dirent<Buffer>[];
+    /**
+     * Closes the file descriptor. No arguments other than a possible exception are
+     * given to the completion callback.
+     *
+     * Calling `fs.close()` on any file descriptor (`fd`) that is currently in use
+     * through any other `fs` operation may lead to undefined behavior.
+     *
+     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
+     * @since v0.0.2
+     */
+    export function close(fd: number, callback?: NoParamCallback): void;
+    export namespace close {
+        /**
+         * Asynchronous close(2) - close a file descriptor.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Closes the file descriptor. Returns `undefined`.
+     *
+     * Calling `fs.closeSync()` on any file descriptor (`fd`) that is currently in use
+     * through any other `fs` operation may lead to undefined behavior.
+     *
+     * See the POSIX [`close(2)`](http://man7.org/linux/man-pages/man2/close.2.html) documentation for more detail.
+     * @since v0.1.21
+     */
+    export function closeSync(fd: number): void;
+    /**
+     * Asynchronous file open. See the POSIX [`open(2)`](http://man7.org/linux/man-pages/man2/open.2.html) documentation for more details.
+     *
+     * `mode` sets the file mode (permission and sticky bits), but only if the file was
+     * created. On Windows, only the write permission can be manipulated; see {@link chmod}.
+     *
+     * The callback gets two arguments `(err, fd)`.
+     *
+     * Some characters (`< > : " / \ | ? *`) are reserved under Windows as documented
+     * by [Naming Files, Paths, and Namespaces](https://docs.microsoft.com/en-us/windows/desktop/FileIO/naming-a-file). Under NTFS, if the filename contains
+     * a colon, Node.js will open a file system stream, as described by [this MSDN page](https://docs.microsoft.com/en-us/windows/desktop/FileIO/using-streams).
+     *
+     * Functions based on `fs.open()` exhibit this behavior as well:`fs.writeFile()`, `fs.readFile()`, etc.
+     * @since v0.0.2
+     * @param [flags='r'] See `support of file system `flags``.
+     * @param [mode=0o666]
+     */
+    export function open(
+        path: PathLike,
+        flags: OpenMode | undefined,
+        mode: Mode | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
+    ): void;
+    /**
+     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * @param [flags='r'] See `support of file system `flags``.
+     */
+    export function open(
+        path: PathLike,
+        flags: OpenMode | undefined,
+        callback: (err: NodeJS.ErrnoException | null, fd: number) => void,
+    ): void;
+    /**
+     * Asynchronous open(2) - open and possibly create a file. If the file is created, its mode will be `0o666`.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function open(path: PathLike, callback: (err: NodeJS.ErrnoException | null, fd: number) => void): void;
+    export namespace open {
+        /**
+         * Asynchronous open(2) - open and possibly create a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not supplied, defaults to `0o666`.
+         */
+        function __promisify__(path: PathLike, flags: OpenMode, mode?: Mode | null): Promise<number>;
+    }
+    /**
+     * Returns an integer representing the file descriptor.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link open}.
+     * @since v0.1.21
+     * @param [flags='r']
+     * @param [mode=0o666]
+     */
+    export function openSync(path: PathLike, flags: OpenMode, mode?: Mode | null): number;
+    /**
+     * Change the file system timestamps of the object referenced by `path`.
+     *
+     * The `atime` and `mtime` arguments follow these rules:
+     *
+     * * Values can be either numbers representing Unix epoch time in seconds, `Date`s, or a numeric string like `'123456789.0'`.
+     * * If the value can not be converted to a number, or is `NaN`, `Infinity`, or `-Infinity`, an `Error` will be thrown.
+     * @since v0.4.2
+     */
+    export function utimes(path: PathLike, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace utimes {
+        /**
+         * Asynchronously change file timestamps of the file referenced by the supplied path.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(path: PathLike, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link utimes}.
+     * @since v0.4.2
+     */
+    export function utimesSync(path: PathLike, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Change the file system timestamps of the object referenced by the supplied file
+     * descriptor. See {@link utimes}.
+     * @since v0.4.2
+     */
+    export function futimes(fd: number, atime: TimeLike, mtime: TimeLike, callback: NoParamCallback): void;
+    export namespace futimes {
+        /**
+         * Asynchronously change file timestamps of the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param atime The last access time. If a string is provided, it will be coerced to number.
+         * @param mtime The last modified time. If a string is provided, it will be coerced to number.
+         */
+        function __promisify__(fd: number, atime: TimeLike, mtime: TimeLike): Promise<void>;
+    }
+    /**
+     * Synchronous version of {@link futimes}. Returns `undefined`.
+     * @since v0.4.2
+     */
+    export function futimesSync(fd: number, atime: TimeLike, mtime: TimeLike): void;
+    /**
+     * Request that all data for the open file descriptor is flushed to the storage
+     * device. The specific implementation is operating system and device specific.
+     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. No arguments other
+     * than a possible exception are given to the completion callback.
+     * @since v0.1.96
+     */
+    export function fsync(fd: number, callback: NoParamCallback): void;
+    export namespace fsync {
+        /**
+         * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Request that all data for the open file descriptor is flushed to the storage
+     * device. The specific implementation is operating system and device specific.
+     * Refer to the POSIX [`fsync(2)`](http://man7.org/linux/man-pages/man2/fsync.2.html) documentation for more detail. Returns `undefined`.
+     * @since v0.1.96
+     */
+    export function fsyncSync(fd: number): void;
+    export interface WriteOptions {
+        /**
+         * @default 0
+         */
+        offset?: number | undefined;
+        /**
+         * @default `buffer.byteLength - offset`
+         */
+        length?: number | undefined;
+        /**
+         * @default null
+         */
+        position?: number | undefined | null;
+    }
+    /**
+     * Write `buffer` to the file specified by `fd`.
+     *
+     * `offset` determines the part of the buffer to be written, and `length` is
+     * an integer specifying the number of bytes to write.
+     *
+     * `position` refers to the offset from the beginning of the file where this data
+     * should be written. If `typeof position !== 'number'`, the data will be written
+     * at the current position. See [`pwrite(2)`](http://man7.org/linux/man-pages/man2/pwrite.2.html).
+     *
+     * The callback will be given three arguments `(err, bytesWritten, buffer)` where `bytesWritten` specifies how many _bytes_ were written from `buffer`.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesWritten` and `buffer` properties.
+     *
+     * It is unsafe to use `fs.write()` multiple times on the same file without waiting
+     * for the callback. For this scenario, {@link createWriteStream} is
+     * recommended.
+     *
+     * On Linux, positional writes don't work when the file is opened in append mode.
+     * The kernel ignores the position argument and always appends the data to
+     * the end of the file.
+     * @since v0.0.2
+     * @param [offset=0]
+     * @param [length=buffer.byteLength - offset]
+     * @param [position='null']
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        length: number | undefined | null,
+        position: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+     * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        length: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param options An object with the following properties:
+     * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
+     * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+     * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     */
+    export function write<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        options: WriteOptions,
+        callback: (err: NodeJS.ErrnoException | null, written: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     * @param encoding The expected string encoding.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        position: number | undefined | null,
+        encoding: BufferEncoding | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        position: number | undefined | null,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    /**
+     * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     */
+    export function write(
+        fd: number,
+        string: string,
+        callback: (err: NodeJS.ErrnoException | null, written: number, str: string) => void,
+    ): void;
+    export namespace write {
+        /**
+         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
+         * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer?: TBuffer,
+            offset?: number,
+            length?: number,
+            position?: number | null,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: TBuffer;
+        }>;
+        /**
+         * Asynchronously writes `buffer` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param options An object with the following properties:
+         * * `offset` The part of the buffer to be written. If not supplied, defaults to `0`.
+         * * `length` The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
+         * * `position` The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer?: TBuffer,
+            options?: WriteOptions,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: TBuffer;
+        }>;
+        /**
+         * Asynchronously writes `string` to the file referenced by the supplied file descriptor.
+         * @param fd A file descriptor.
+         * @param string A string to write.
+         * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+         * @param encoding The expected string encoding.
+         */
+        function __promisify__(
+            fd: number,
+            string: string,
+            position?: number | null,
+            encoding?: BufferEncoding | null,
+        ): Promise<{
+            bytesWritten: number;
+            buffer: string;
+        }>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link write}.
+     * @since v0.1.21
+     * @param [offset=0]
+     * @param [length=buffer.byteLength - offset]
+     * @param [position='null']
+     * @return The number of bytes written.
+     */
+    export function writeSync(
+        fd: number,
+        buffer: NodeJS.ArrayBufferView,
+        offset?: number | null,
+        length?: number | null,
+        position?: number | null,
+    ): number;
+    /**
+     * Synchronously writes `string` to the file referenced by the supplied file descriptor, returning the number of bytes written.
+     * @param fd A file descriptor.
+     * @param string A string to write.
+     * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
+     * @param encoding The expected string encoding.
+     */
+    export function writeSync(
+        fd: number,
+        string: string,
+        position?: number | null,
+        encoding?: BufferEncoding | null,
+    ): number;
+    export type ReadPosition = number | bigint;
+    export interface ReadSyncOptions {
+        /**
+         * @default 0
+         */
+        offset?: number | undefined;
+        /**
+         * @default `length of buffer`
+         */
+        length?: number | undefined;
+        /**
+         * @default null
+         */
+        position?: ReadPosition | null | undefined;
+    }
+    export interface ReadAsyncOptions<TBuffer extends NodeJS.ArrayBufferView> extends ReadSyncOptions {
+        buffer?: TBuffer;
+    }
+    /**
+     * Read data from the file specified by `fd`.
+     *
+     * The callback is given the three arguments, `(err, bytesRead, buffer)`.
+     *
+     * If the file is not modified concurrently, the end-of-file is reached when the
+     * number of bytes read is zero.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesRead` and `buffer` properties.
+     * @since v0.0.2
+     * @param buffer The buffer that the data will be written to.
+     * @param offset The position in `buffer` to write the data to.
+     * @param length The number of bytes to read.
+     * @param position Specifies where to begin reading from in the file. If `position` is `null` or `-1 `, data will be read from the current file position, and the file position will be updated. If
+     * `position` is an integer, the file position will be unchanged.
+     */
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        offset: number,
+        length: number,
+        position: ReadPosition | null,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    /**
+     * Similar to the above `fs.read` function, this version takes an optional `options` object.
+     * If not otherwise specified in an `options` object,
+     * `buffer` defaults to `Buffer.alloc(16384)`,
+     * `offset` defaults to `0`,
+     * `length` defaults to `buffer.byteLength`, `- offset` as of Node 17.6.0
+     * `position` defaults to `null`
+     * @since v12.17.0, 13.11.0
+     */
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        options: ReadAsyncOptions<TBuffer>,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        options: ReadSyncOptions,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read<TBuffer extends NodeJS.ArrayBufferView>(
+        fd: number,
+        buffer: TBuffer,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: TBuffer) => void,
+    ): void;
+    export function read(
+        fd: number,
+        callback: (err: NodeJS.ErrnoException | null, bytesRead: number, buffer: NodeJS.ArrayBufferView) => void,
+    ): void;
+    export namespace read {
+        /**
+         * @param fd A file descriptor.
+         * @param buffer The buffer that the data will be written to.
+         * @param offset The offset in the buffer at which to start writing.
+         * @param length The number of bytes to read.
+         * @param position The offset from the beginning of the file from which data should be read. If `null`, data will be read from the current position.
+         */
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            buffer: TBuffer,
+            offset: number,
+            length: number,
+            position: ReadPosition | null,
+        ): Promise<{
+            bytesRead: number;
+            buffer: TBuffer;
+        }>;
+        function __promisify__<TBuffer extends NodeJS.ArrayBufferView>(
+            fd: number,
+            options: ReadAsyncOptions<TBuffer>,
+        ): Promise<{
+            bytesRead: number;
+            buffer: TBuffer;
+        }>;
+        function __promisify__(fd: number): Promise<{
+            bytesRead: number;
+            buffer: NodeJS.ArrayBufferView;
+        }>;
+    }
+    /**
+     * Returns the number of `bytesRead`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link read}.
+     * @since v0.1.21
+     * @param [position='null']
+     */
+    export function readSync(
+        fd: number,
+        buffer: NodeJS.ArrayBufferView,
+        offset: number,
+        length: number,
+        position: ReadPosition | null,
+    ): number;
+    /**
+     * Similar to the above `fs.readSync` function, this version takes an optional `options` object.
+     * If no `options` object is specified, it will default with the above values.
+     */
+    export function readSync(fd: number, buffer: NodeJS.ArrayBufferView, opts?: ReadSyncOptions): number;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * readFile('/etc/passwd', (err, data) => {
+     *   if (err) throw err;
+     *   console.log(data);
+     * });
+     * ```
+     *
+     * The callback is passed two arguments `(err, data)`, where `data` is the
+     * contents of the file.
+     *
+     * If no encoding is specified, then the raw buffer is returned.
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * readFile('/etc/passwd', 'utf8', callback);
+     * ```
+     *
+     * When the path is a directory, the behavior of `fs.readFile()` and {@link readFileSync} is platform-specific. On macOS, Linux, and Windows, an
+     * error will be returned. On FreeBSD, a representation of the directory's contents
+     * will be returned.
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * // macOS, Linux, and Windows
+     * readFile('<directory>', (err, data) => {
+     *   // => [Error: EISDIR: illegal operation on a directory, read <directory>]
+     * });
+     *
+     * //  FreeBSD
+     * readFile('<directory>', (err, data) => {
+     *   // => null, <data>
+     * });
+     * ```
+     *
+     * It is possible to abort an ongoing request using an `AbortSignal`. If a
+     * request is aborted the callback is called with an `AbortError`:
+     *
+     * ```js
+     * import { readFile } from 'node:fs';
+     *
+     * const controller = new AbortController();
+     * const signal = controller.signal;
+     * readFile(fileInfo[0].name, { signal }, (err, buf) => {
+     *   // ...
+     * });
+     * // When you want to abort the request
+     * controller.abort();
+     * ```
+     *
+     * The `fs.readFile()` function buffers the entire file. To minimize memory costs,
+     * when possible prefer streaming via `fs.createReadStream()`.
+     *
+     * Aborting an ongoing request does not abort individual operating
+     * system requests but rather the internal buffering `fs.readFile` performs.
+     * @since v0.1.29
+     * @param path filename or file descriptor
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | ({
+                encoding?: null | undefined;
+                flag?: string | undefined;
+            } & Abortable)
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | ({
+                encoding: BufferEncoding;
+                flag?: string | undefined;
+            } & Abortable)
+            | BufferEncoding,
+        callback: (err: NodeJS.ErrnoException | null, data: string) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        options:
+            | (ObjectEncodingOptions & {
+                flag?: string | undefined;
+            } & Abortable)
+            | BufferEncoding
+            | undefined
+            | null,
+        callback: (err: NodeJS.ErrnoException | null, data: string | NonSharedBuffer) => void,
+    ): void;
+    /**
+     * Asynchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     */
+    export function readFile(
+        path: PathOrFileDescriptor,
+        callback: (err: NodeJS.ErrnoException | null, data: NonSharedBuffer) => void,
+    ): void;
+    export namespace readFile {
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options An object that may contain an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options?: {
+                encoding?: null | undefined;
+                flag?: string | undefined;
+            } | null,
+        ): Promise<NonSharedBuffer>;
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options:
+                | {
+                    encoding: BufferEncoding;
+                    flag?: string | undefined;
+                }
+                | BufferEncoding,
+        ): Promise<string>;
+        /**
+         * Asynchronously reads the entire contents of a file.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+         * If a flag is not provided, it defaults to `'r'`.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            options?:
+                | (ObjectEncodingOptions & {
+                    flag?: string | undefined;
+                })
+                | BufferEncoding
+                | null,
+        ): Promise<string | NonSharedBuffer>;
+    }
+    /**
+     * Returns the contents of the `path`.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link readFile}.
+     *
+     * If the `encoding` option is specified then this function returns a
+     * string. Otherwise it returns a buffer.
+     *
+     * Similar to {@link readFile}, when the path is a directory, the behavior of `fs.readFileSync()` is platform-specific.
+     *
+     * ```js
+     * import { readFileSync } from 'node:fs';
+     *
+     * // macOS, Linux, and Windows
+     * readFileSync('<directory>');
+     * // => [Error: EISDIR: illegal operation on a directory, read <directory>]
+     *
+     * //  FreeBSD
+     * readFileSync('<directory>'); // => <data>
+     * ```
+     * @since v0.1.8
+     * @param path filename or file descriptor
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options?: {
+            encoding?: null | undefined;
+            flag?: string | undefined;
+        } | null,
+    ): NonSharedBuffer;
+    /**
+     * Synchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options:
+            | {
+                encoding: BufferEncoding;
+                flag?: string | undefined;
+            }
+            | BufferEncoding,
+    ): string;
+    /**
+     * Synchronously reads the entire contents of a file.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param options Either the encoding for the result, or an object that contains the encoding and an optional flag.
+     * If a flag is not provided, it defaults to `'r'`.
+     */
+    export function readFileSync(
+        path: PathOrFileDescriptor,
+        options?:
+            | (ObjectEncodingOptions & {
+                flag?: string | undefined;
+            })
+            | BufferEncoding
+            | null,
+    ): string | NonSharedBuffer;
+    export type WriteFileOptions =
+        | (
+            & ObjectEncodingOptions
+            & Abortable
+            & {
+                mode?: Mode | undefined;
+                flag?: string | undefined;
+                flush?: boolean | undefined;
+            }
+        )
+        | BufferEncoding
+        | null;
+    /**
+     * When `file` is a filename, asynchronously writes data to the file, replacing the
+     * file if it already exists. `data` can be a string or a buffer.
+     *
+     * When `file` is a file descriptor, the behavior is similar to calling `fs.write()` directly (which is recommended). See the notes below on using
+     * a file descriptor.
+     *
+     * The `encoding` option is ignored if `data` is a buffer.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     * import { Buffer } from 'node:buffer';
+     *
+     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
+     * writeFile('message.txt', data, (err) => {
+     *   if (err) throw err;
+     *   console.log('The file has been saved!');
+     * });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     *
+     * writeFile('message.txt', 'Hello Node.js', 'utf8', callback);
+     * ```
+     *
+     * It is unsafe to use `fs.writeFile()` multiple times on the same file without
+     * waiting for the callback. For this scenario, {@link createWriteStream} is
+     * recommended.
+     *
+     * Similarly to `fs.readFile` \- `fs.writeFile` is a convenience method that
+     * performs multiple `write` calls internally to write the buffer passed to it.
+     * For performance sensitive code consider using {@link createWriteStream}.
+     *
+     * It is possible to use an `AbortSignal` to cancel an `fs.writeFile()`.
+     * Cancelation is "best effort", and some amount of data is likely still
+     * to be written.
+     *
+     * ```js
+     * import { writeFile } from 'node:fs';
+     * import { Buffer } from 'node:buffer';
+     *
+     * const controller = new AbortController();
+     * const { signal } = controller;
+     * const data = new Uint8Array(Buffer.from('Hello Node.js'));
+     * writeFile('message.txt', data, { signal }, (err) => {
+     *   // When a request is aborted - the callback is called with an AbortError
+     * });
+     * // When the request should be aborted
+     * controller.abort();
+     * ```
+     *
+     * Aborting an ongoing request does not abort individual operating
+     * system requests but rather the internal buffering `fs.writeFile` performs.
+     * @since v0.1.29
+     * @param file filename or file descriptor
+     */
+    export function writeFile(
+        file: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        options: WriteFileOptions,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronously writes data to a file, replacing the file if it already exists.
+     * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+     */
+    export function writeFile(
+        path: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        callback: NoParamCallback,
+    ): void;
+    export namespace writeFile {
+        /**
+         * Asynchronously writes data to a file, replacing the file if it already exists.
+         * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
+         * If `encoding` is not supplied, the default of `'utf8'` is used.
+         * If `mode` is not supplied, the default of `0o666` is used.
+         * If `mode` is a string, it is parsed as an octal integer.
+         * If `flag` is not supplied, the default of `'w'` is used.
+         */
+        function __promisify__(
+            path: PathOrFileDescriptor,
+            data: string | NodeJS.ArrayBufferView,
+            options?: WriteFileOptions,
+        ): Promise<void>;
+    }
+    /**
+     * Returns `undefined`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link writeFile}.
+     * @since v0.1.29
+     * @param file filename or file descriptor
+     */
+    export function writeFileSync(
+        file: PathOrFileDescriptor,
+        data: string | NodeJS.ArrayBufferView,
+        options?: WriteFileOptions,
+    ): void;
+    /**
+     * Asynchronously append data to a file, creating the file if it does not yet
+     * exist. `data` can be a string or a `Buffer`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { appendFile } from 'node:fs';
+     *
+     * appendFile('message.txt', 'data to append', (err) => {
+     *   if (err) throw err;
+     *   console.log('The "data to append" was appended to file!');
+     * });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { appendFile } from 'node:fs';
+     *
+     * appendFile('message.txt', 'data to append', 'utf8', callback);
+     * ```
+     *
+     * The `path` may be specified as a numeric file descriptor that has been opened
+     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
+     * not be closed automatically.
+     *
+     * ```js
+     * import { open, close, appendFile } from 'node:fs';
+     *
+     * function closeFd(fd) {
+     *   close(fd, (err) => {
+     *     if (err) throw err;
+     *   });
+     * }
+     *
+     * open('message.txt', 'a', (err, fd) => {
+     *   if (err) throw err;
+     *
+     *   try {
+     *     appendFile(fd, 'data to append', 'utf8', (err) => {
+     *       closeFd(fd);
+     *       if (err) throw err;
+     *     });
+     *   } catch (err) {
+     *     closeFd(fd);
+     *     throw err;
+     *   }
+     * });
+     * ```
+     * @since v0.6.7
+     * @param path filename or file descriptor
+     */
+    export function appendFile(
+        path: PathOrFileDescriptor,
+        data: string | Uint8Array,
+        options: WriteFileOptions,
+        callback: NoParamCallback,
+    ): void;
+    /**
+     * Asynchronously append data to a file, creating the file if it does not exist.
+     * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
+     * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+     * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+     */
+    export function appendFile(file: PathOrFileDescriptor, data: string | Uint8Array, callback: NoParamCallback): void;
+    export namespace appendFile {
+        /**
+         * Asynchronously append data to a file, creating the file if it does not exist.
+         * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         * If a file descriptor is provided, the underlying file will _not_ be closed automatically.
+         * @param data The data to write. If something other than a Buffer or Uint8Array is provided, the value is coerced to a string.
+         * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
+         * If `encoding` is not supplied, the default of `'utf8'` is used.
+         * If `mode` is not supplied, the default of `0o666` is used.
+         * If `mode` is a string, it is parsed as an octal integer.
+         * If `flag` is not supplied, the default of `'a'` is used.
+         */
+        function __promisify__(
+            file: PathOrFileDescriptor,
+            data: string | Uint8Array,
+            options?: WriteFileOptions,
+        ): Promise<void>;
+    }
+    /**
+     * Synchronously append data to a file, creating the file if it does not yet
+     * exist. `data` can be a string or a `Buffer`.
+     *
+     * The `mode` option only affects the newly created file. See {@link open} for more details.
+     *
+     * ```js
+     * import { appendFileSync } from 'node:fs';
+     *
+     * try {
+     *   appendFileSync('message.txt', 'data to append');
+     *   console.log('The "data to append" was appended to file!');
+     * } catch (err) {
+     *   // Handle the error
+     * }
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding:
+     *
+     * ```js
+     * import { appendFileSync } from 'node:fs';
+     *
+     * appendFileSync('message.txt', 'data to append', 'utf8');
+     * ```
+     *
+     * The `path` may be specified as a numeric file descriptor that has been opened
+     * for appending (using `fs.open()` or `fs.openSync()`). The file descriptor will
+     * not be closed automatically.
+     *
+     * ```js
+     * import { openSync, closeSync, appendFileSync } from 'node:fs';
+     *
+     * let fd;
+     *
+     * try {
+     *   fd = openSync('message.txt', 'a');
+     *   appendFileSync(fd, 'data to append', 'utf8');
+     * } catch (err) {
+     *   // Handle the error
+     * } finally {
+     *   if (fd !== undefined)
+     *     closeSync(fd);
+     * }
+     * ```
+     * @since v0.6.7
+     * @param path filename or file descriptor
+     */
+    export function appendFileSync(
+        path: PathOrFileDescriptor,
+        data: string | Uint8Array,
+        options?: WriteFileOptions,
+    ): void;
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each
+     * time the file is accessed.
+     *
+     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
+     * whether the process should continue to run as long as files are being watched.
+     * The `options` object may specify an `interval` property indicating how often the
+     * target should be polled in milliseconds.
+     *
+     * The `listener` gets two arguments the current stat object and the previous
+     * stat object:
+     *
+     * ```js
+     * import { watchFile } from 'node:fs';
+     *
+     * watchFile('message.text', (curr, prev) => {
+     *   console.log(`the current mtime is: ${curr.mtime}`);
+     *   console.log(`the previous mtime was: ${prev.mtime}`);
+     * });
+     * ```
+     *
+     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
+     * the numeric values in these objects are specified as `BigInt`s.
+     *
+     * To be notified when the file was modified, not just accessed, it is necessary
+     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
+     *
+     * When an `fs.watchFile` operation results in an `ENOENT` error, it
+     * will invoke the listener once, with all the fields zeroed (or, for dates, the
+     * Unix Epoch). If the file is created later on, the listener will be called
+     * again, with the latest stat objects. This is a change in functionality since
+     * v0.10.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
+     *
+     * When a file being watched by `fs.watchFile()` disappears and reappears,
+     * then the contents of `previous` in the second callback event (the file's
+     * reappearance) will be the same as the contents of `previous` in the first
+     * callback event (its disappearance).
+     *
+     * This happens when:
+     *
+     * * the file is deleted, followed by a restore
+     * * the file is renamed and then renamed a second time back to its original name
+     * @since v0.1.31
+     */
+    export interface WatchFileOptions {
+        bigint?: boolean | undefined;
+        persistent?: boolean | undefined;
+        interval?: number | undefined;
+    }
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each
+     * time the file is accessed.
+     *
+     * The `options` argument may be omitted. If provided, it should be an object. The `options` object may contain a boolean named `persistent` that indicates
+     * whether the process should continue to run as long as files are being watched.
+     * The `options` object may specify an `interval` property indicating how often the
+     * target should be polled in milliseconds.
+     *
+     * The `listener` gets two arguments the current stat object and the previous
+     * stat object:
+     *
+     * ```js
+     * import { watchFile } from 'node:fs';
+     *
+     * watchFile('message.text', (curr, prev) => {
+     *   console.log(`the current mtime is: ${curr.mtime}`);
+     *   console.log(`the previous mtime was: ${prev.mtime}`);
+     * });
+     * ```
+     *
+     * These stat objects are instances of `fs.Stat`. If the `bigint` option is `true`,
+     * the numeric values in these objects are specified as `BigInt`s.
+     *
+     * To be notified when the file was modified, not just accessed, it is necessary
+     * to compare `curr.mtimeMs` and `prev.mtimeMs`.
+     *
+     * When an `fs.watchFile` operation results in an `ENOENT` error, it
+     * will invoke the listener once, with all the fields zeroed (or, for dates, the
+     * Unix Epoch). If the file is created later on, the listener will be called
+     * again, with the latest stat objects. This is a change in functionality since
+     * v0.10.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile` and `fs.unwatchFile`. `fs.watch` should be used instead of `fs.watchFile` and `fs.unwatchFile` when possible.
+     *
+     * When a file being watched by `fs.watchFile()` disappears and reappears,
+     * then the contents of `previous` in the second callback event (the file's
+     * reappearance) will be the same as the contents of `previous` in the first
+     * callback event (its disappearance).
+     *
+     * This happens when:
+     *
+     * * the file is deleted, followed by a restore
+     * * the file is renamed and then renamed a second time back to its original name
+     * @since v0.1.31
+     */
+    export function watchFile(
+        filename: PathLike,
+        options:
+            | (WatchFileOptions & {
+                bigint?: false | undefined;
+            })
+            | undefined,
+        listener: StatsListener,
+    ): StatWatcher;
+    export function watchFile(
+        filename: PathLike,
+        options:
+            | (WatchFileOptions & {
+                bigint: true;
+            })
+            | undefined,
+        listener: BigIntStatsListener,
+    ): StatWatcher;
+    /**
+     * Watch for changes on `filename`. The callback `listener` will be called each time the file is accessed.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function watchFile(filename: PathLike, listener: StatsListener): StatWatcher;
+    /**
+     * Stop watching for changes on `filename`. If `listener` is specified, only that
+     * particular listener is removed. Otherwise, _all_ listeners are removed,
+     * effectively stopping watching of `filename`.
+     *
+     * Calling `fs.unwatchFile()` with a filename that is not being watched is a
+     * no-op, not an error.
+     *
+     * Using {@link watch} is more efficient than `fs.watchFile()` and `fs.unwatchFile()`. `fs.watch()` should be used instead of `fs.watchFile()` and `fs.unwatchFile()` when possible.
+     * @since v0.1.31
+     * @param listener Optional, a listener previously attached using `fs.watchFile()`
+     */
+    export function unwatchFile(filename: PathLike, listener?: StatsListener): void;
+    export function unwatchFile(filename: PathLike, listener?: BigIntStatsListener): void;
+    export interface WatchOptions extends Abortable {
+        encoding?: BufferEncoding | "buffer" | undefined;
+        persistent?: boolean | undefined;
+        recursive?: boolean | undefined;
+    }
+    export type WatchEventType = "rename" | "change";
+    export type WatchListener<T> = (event: WatchEventType, filename: T | null) => void;
+    export type StatsListener = (curr: Stats, prev: Stats) => void;
+    export type BigIntStatsListener = (curr: BigIntStats, prev: BigIntStats) => void;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a
+     * directory.
+     *
+     * The second argument is optional. If `options` is provided as a string, it
+     * specifies the `encoding`. Otherwise `options` should be passed as an object.
+     *
+     * The listener callback gets two arguments `(eventType, filename)`. `eventType`is either `'rename'` or `'change'`, and `filename` is the name of the file
+     * which triggered the event.
+     *
+     * On most platforms, `'rename'` is emitted whenever a filename appears or
+     * disappears in the directory.
+     *
+     * The listener callback is attached to the `'change'` event fired by `fs.FSWatcher`, but it is not the same thing as the `'change'` value of `eventType`.
+     *
+     * If a `signal` is passed, aborting the corresponding AbortController will close
+     * the returned `fs.FSWatcher`.
+     * @since v0.5.10
+     * @param listener
+     */
+    export function watch(
+        filename: PathLike,
+        options:
+            | (WatchOptions & {
+                encoding: "buffer";
+            })
+            | "buffer",
+        listener?: WatchListener<Buffer>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
+     * If `encoding` is not supplied, the default of `'utf8'` is used.
+     * If `persistent` is not supplied, the default of `true` is used.
+     * If `recursive` is not supplied, the default of `false` is used.
+     */
+    export function watch(
+        filename: PathLike,
+        options?: WatchOptions | BufferEncoding | null,
+        listener?: WatchListener<string>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     * @param options Either the encoding for the filename provided to the listener, or an object optionally specifying encoding, persistent, and recursive options.
+     * If `encoding` is not supplied, the default of `'utf8'` is used.
+     * If `persistent` is not supplied, the default of `true` is used.
+     * If `recursive` is not supplied, the default of `false` is used.
+     */
+    export function watch(
+        filename: PathLike,
+        options: WatchOptions | string,
+        listener?: WatchListener<string | Buffer>,
+    ): FSWatcher;
+    /**
+     * Watch for changes on `filename`, where `filename` is either a file or a directory, returning an `FSWatcher`.
+     * @param filename A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function watch(filename: PathLike, listener?: WatchListener<string>): FSWatcher;
+    /**
+     * Test whether or not the given path exists by checking with the file system.
+     * Then call the `callback` argument with either true or false:
+     *
+     * ```js
+     * import { exists } from 'node:fs';
+     *
+     * exists('/etc/passwd', (e) => {
+     *   console.log(e ? 'it exists' : 'no passwd!');
+     * });
+     * ```
+     *
+     * **The parameters for this callback are not consistent with other Node.js**
+     * **callbacks.** Normally, the first parameter to a Node.js callback is an `err` parameter, optionally followed by other parameters. The `fs.exists()` callback
+     * has only one boolean parameter. This is one reason `fs.access()` is recommended
+     * instead of `fs.exists()`.
+     *
+     * Using `fs.exists()` to check for the existence of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()` is not recommended. Doing
+     * so introduces a race condition, since other processes may change the file's
+     * state between the two calls. Instead, user code should open/read/write the
+     * file directly and handle the error raised if the file does not exist.
+     *
+     * **write (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { exists, open, close } from 'node:fs';
+     *
+     * exists('myfile', (e) => {
+     *   if (e) {
+     *     console.error('myfile already exists');
+     *   } else {
+     *     open('myfile', 'wx', (err, fd) => {
+     *       if (err) throw err;
+     *
+     *       try {
+     *         writeMyData(fd);
+     *       } finally {
+     *         close(fd, (err) => {
+     *           if (err) throw err;
+     *         });
+     *       }
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **write (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     * open('myfile', 'wx', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'EEXIST') {
+     *       console.error('myfile already exists');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     writeMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **read (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close, exists } from 'node:fs';
+     *
+     * exists('myfile', (e) => {
+     *   if (e) {
+     *     open('myfile', 'r', (err, fd) => {
+     *       if (err) throw err;
+     *
+     *       try {
+     *         readMyData(fd);
+     *       } finally {
+     *         close(fd, (err) => {
+     *           if (err) throw err;
+     *         });
+     *       }
+     *     });
+     *   } else {
+     *     console.error('myfile does not exist');
+     *   }
+     * });
+     * ```
+     *
+     * **read (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'r', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     readMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * The "not recommended" examples above check for existence and then use the
+     * file; the "recommended" examples are better because they use the file directly
+     * and handle the error, if any.
+     *
+     * In general, check for the existence of a file only if the file won't be
+     * used directly, for example when its existence is a signal from another
+     * process.
+     * @since v0.0.2
+     * @deprecated Since v1.0.0 - Use {@link stat} or {@link access} instead.
+     */
+    export function exists(path: PathLike, callback: (exists: boolean) => void): void;
+    /** @deprecated */
+    export namespace exists {
+        /**
+         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(path: PathLike): Promise<boolean>;
+    }
+    /**
+     * Returns `true` if the path exists, `false` otherwise.
+     *
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link exists}.
+     *
+     * `fs.exists()` is deprecated, but `fs.existsSync()` is not. The `callback` parameter to `fs.exists()` accepts parameters that are inconsistent with other
+     * Node.js callbacks. `fs.existsSync()` does not use a callback.
+     *
+     * ```js
+     * import { existsSync } from 'node:fs';
+     *
+     * if (existsSync('/etc/passwd'))
+     *   console.log('The path exists.');
+     * ```
+     * @since v0.1.21
+     */
+    export function existsSync(path: PathLike): boolean;
+    export namespace constants {
+        // File Access Constants
+        /** Constant for fs.access(). File is visible to the calling process. */
+        const F_OK: number;
+        /** Constant for fs.access(). File can be read by the calling process. */
+        const R_OK: number;
+        /** Constant for fs.access(). File can be written by the calling process. */
+        const W_OK: number;
+        /** Constant for fs.access(). File can be executed by the calling process. */
+        const X_OK: number;
+        // File Copy Constants
+        /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
+        const COPYFILE_EXCL: number;
+        /**
+         * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
+         * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
+         */
+        const COPYFILE_FICLONE: number;
+        /**
+         * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
+         * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
+         */
+        const COPYFILE_FICLONE_FORCE: number;
+        // File Open Constants
+        /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
+        const O_RDONLY: number;
+        /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
+        const O_WRONLY: number;
+        /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
+        const O_RDWR: number;
+        /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
+        const O_CREAT: number;
+        /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
+        const O_EXCL: number;
+        /**
+         * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
+         * opening the path shall not cause that terminal to become the controlling terminal for the process
+         * (if the process does not already have one).
+         */
+        const O_NOCTTY: number;
+        /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
+        const O_TRUNC: number;
+        /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
+        const O_APPEND: number;
+        /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
+        const O_DIRECTORY: number;
+        /**
+         * constant for fs.open().
+         * Flag indicating reading accesses to the file system will no longer result in
+         * an update to the atime information associated with the file.
+         * This flag is available on Linux operating systems only.
+         */
+        const O_NOATIME: number;
+        /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
+        const O_NOFOLLOW: number;
+        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
+        const O_SYNC: number;
+        /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
+        const O_DSYNC: number;
+        /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
+        const O_SYMLINK: number;
+        /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
+        const O_DIRECT: number;
+        /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
+        const O_NONBLOCK: number;
+        // File Type Constants
+        /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
+        const S_IFMT: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
+        const S_IFREG: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
+        const S_IFDIR: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
+        const S_IFCHR: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
+        const S_IFBLK: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
+        const S_IFIFO: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
+        const S_IFLNK: number;
+        /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
+        const S_IFSOCK: number;
+        // File Mode Constants
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
+        const S_IRWXU: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
+        const S_IRUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
+        const S_IWUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
+        const S_IXUSR: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
+        const S_IRWXG: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
+        const S_IRGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
+        const S_IWGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
+        const S_IXGRP: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
+        const S_IRWXO: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
+        const S_IROTH: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
+        const S_IWOTH: number;
+        /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
+        const S_IXOTH: number;
+        /**
+         * When set, a memory file mapping is used to access the file. This flag
+         * is available on Windows operating systems only. On other operating systems,
+         * this flag is ignored.
+         */
+        const UV_FS_O_FILEMAP: number;
+    }
+    /**
+     * Tests a user's permissions for the file or directory specified by `path`.
+     * The `mode` argument is an optional integer that specifies the accessibility
+     * checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and `fs.constants.X_OK`
+     * (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
+     * possible values of `mode`.
+     *
+     * The final argument, `callback`, is a callback function that is invoked with
+     * a possible error argument. If any of the accessibility checks fail, the error
+     * argument will be an `Error` object. The following examples check if `package.json` exists, and if it is readable or writable.
+     *
+     * ```js
+     * import { access, constants } from 'node:fs';
+     *
+     * const file = 'package.json';
+     *
+     * // Check if the file exists in the current directory.
+     * access(file, constants.F_OK, (err) => {
+     *   console.log(`${file} ${err ? 'does not exist' : 'exists'}`);
+     * });
+     *
+     * // Check if the file is readable.
+     * access(file, constants.R_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not readable' : 'is readable'}`);
+     * });
+     *
+     * // Check if the file is writable.
+     * access(file, constants.W_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not writable' : 'is writable'}`);
+     * });
+     *
+     * // Check if the file is readable and writable.
+     * access(file, constants.R_OK | constants.W_OK, (err) => {
+     *   console.log(`${file} ${err ? 'is not' : 'is'} readable and writable`);
+     * });
+     * ```
+     *
+     * Do not use `fs.access()` to check for the accessibility of a file before calling `fs.open()`, `fs.readFile()`, or `fs.writeFile()`. Doing
+     * so introduces a race condition, since other processes may change the file's
+     * state between the two calls. Instead, user code should open/read/write the
+     * file directly and handle the error raised if the file is not accessible.
+     *
+     * **write (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { access, open, close } from 'node:fs';
+     *
+     * access('myfile', (err) => {
+     *   if (!err) {
+     *     console.error('myfile already exists');
+     *     return;
+     *   }
+     *
+     *   open('myfile', 'wx', (err, fd) => {
+     *     if (err) throw err;
+     *
+     *     try {
+     *       writeMyData(fd);
+     *     } finally {
+     *       close(fd, (err) => {
+     *         if (err) throw err;
+     *       });
+     *     }
+     *   });
+     * });
+     * ```
+     *
+     * **write (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'wx', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'EEXIST') {
+     *       console.error('myfile already exists');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     writeMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * **read (NOT RECOMMENDED)**
+     *
+     * ```js
+     * import { access, open, close } from 'node:fs';
+     * access('myfile', (err) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   open('myfile', 'r', (err, fd) => {
+     *     if (err) throw err;
+     *
+     *     try {
+     *       readMyData(fd);
+     *     } finally {
+     *       close(fd, (err) => {
+     *         if (err) throw err;
+     *       });
+     *     }
+     *   });
+     * });
+     * ```
+     *
+     * **read (RECOMMENDED)**
+     *
+     * ```js
+     * import { open, close } from 'node:fs';
+     *
+     * open('myfile', 'r', (err, fd) => {
+     *   if (err) {
+     *     if (err.code === 'ENOENT') {
+     *       console.error('myfile does not exist');
+     *       return;
+     *     }
+     *
+     *     throw err;
+     *   }
+     *
+     *   try {
+     *     readMyData(fd);
+     *   } finally {
+     *     close(fd, (err) => {
+     *       if (err) throw err;
+     *     });
+     *   }
+     * });
+     * ```
+     *
+     * The "not recommended" examples above check for accessibility and then use the
+     * file; the "recommended" examples are better because they use the file directly
+     * and handle the error, if any.
+     *
+     * In general, check for the accessibility of a file only if the file will not be
+     * used directly, for example when its accessibility is a signal from another
+     * process.
+     *
+     * On Windows, access-control policies (ACLs) on a directory may limit access to
+     * a file or directory. The `fs.access()` function, however, does not check the
+     * ACL and therefore may report that a path is accessible even if the ACL restricts
+     * the user from reading or writing to it.
+     * @since v0.11.15
+     * @param [mode=fs.constants.F_OK]
+     */
+    export function access(path: PathLike, mode: number | undefined, callback: NoParamCallback): void;
+    /**
+     * Asynchronously tests a user's permissions for the file specified by path.
+     * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+     */
+    export function access(path: PathLike, callback: NoParamCallback): void;
+    export namespace access {
+        /**
+         * Asynchronously tests a user's permissions for the file specified by path.
+         * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
+         * URL support is _experimental_.
+         */
+        function __promisify__(path: PathLike, mode?: number): Promise<void>;
+    }
+    /**
+     * Synchronously tests a user's permissions for the file or directory specified
+     * by `path`. The `mode` argument is an optional integer that specifies the
+     * accessibility checks to be performed. `mode` should be either the value `fs.constants.F_OK` or a mask consisting of the bitwise OR of any of `fs.constants.R_OK`, `fs.constants.W_OK`, and
+     * `fs.constants.X_OK` (e.g.`fs.constants.W_OK | fs.constants.R_OK`). Check `File access constants` for
+     * possible values of `mode`.
+     *
+     * If any of the accessibility checks fail, an `Error` will be thrown. Otherwise,
+     * the method will return `undefined`.
+     *
+     * ```js
+     * import { accessSync, constants } from 'node:fs';
+     *
+     * try {
+     *   accessSync('etc/passwd', constants.R_OK | constants.W_OK);
+     *   console.log('can read/write');
+     * } catch (err) {
+     *   console.error('no access!');
+     * }
+     * ```
+     * @since v0.11.15
+     * @param [mode=fs.constants.F_OK]
+     */
+    export function accessSync(path: PathLike, mode?: number): void;
+    interface StreamOptions {
+        flags?: string | undefined;
+        encoding?: BufferEncoding | undefined;
+        fd?: number | promises.FileHandle | undefined;
+        mode?: number | undefined;
+        autoClose?: boolean | undefined;
+        emitClose?: boolean | undefined;
+        start?: number | undefined;
+        signal?: AbortSignal | null | undefined;
+        highWaterMark?: number | undefined;
+    }
+    interface FSImplementation {
+        open?: (...args: any[]) => any;
+        close?: (...args: any[]) => any;
+    }
+    interface CreateReadStreamFSImplementation extends FSImplementation {
+        read: (...args: any[]) => any;
+    }
+    interface CreateWriteStreamFSImplementation extends FSImplementation {
+        write: (...args: any[]) => any;
+        writev?: (...args: any[]) => any;
+    }
+    interface ReadStreamOptions extends StreamOptions {
+        fs?: CreateReadStreamFSImplementation | null | undefined;
+        end?: number | undefined;
+    }
+    interface WriteStreamOptions extends StreamOptions {
+        fs?: CreateWriteStreamFSImplementation | null | undefined;
+        flush?: boolean | undefined;
+    }
+    /**
+     * `options` can include `start` and `end` values to read a range of bytes from
+     * the file instead of the entire file. Both `start` and `end` are inclusive and
+     * start counting at 0, allowed values are in the
+     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. If `fd` is specified and `start` is
+     * omitted or `undefined`, `fs.createReadStream()` reads sequentially from the
+     * current file position. The `encoding` can be any one of those accepted by `Buffer`.
+     *
+     * If `fd` is specified, `ReadStream` will ignore the `path` argument and will use
+     * the specified file descriptor. This means that no `'open'` event will be
+     * emitted. `fd` should be blocking; non-blocking `fd`s should be passed to `net.Socket`.
+     *
+     * If `fd` points to a character device that only supports blocking reads
+     * (such as keyboard or sound card), read operations do not finish until data is
+     * available. This can prevent the process from exiting and the stream from
+     * closing naturally.
+     *
+     * By default, the stream will emit a `'close'` event after it has been
+     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
+     *
+     * By providing the `fs` option, it is possible to override the corresponding `fs` implementations for `open`, `read`, and `close`. When providing the `fs` option,
+     * an override for `read` is required. If no `fd` is provided, an override for `open` is also required. If `autoClose` is `true`, an override for `close` is
+     * also required.
+     *
+     * ```js
+     * import { createReadStream } from 'node:fs';
+     *
+     * // Create a stream from some character device.
+     * const stream = createReadStream('/dev/input/event0');
+     * setTimeout(() => {
+     *   stream.close(); // This may not close the stream.
+     *   // Artificially marking end-of-stream, as if the underlying resource had
+     *   // indicated end-of-file by itself, allows the stream to close.
+     *   // This does not cancel pending read operations, and if there is such an
+     *   // operation, the process may still not be able to exit successfully
+     *   // until it finishes.
+     *   stream.push(null);
+     *   stream.read(0);
+     * }, 100);
+     * ```
+     *
+     * If `autoClose` is false, then the file descriptor won't be closed, even if
+     * there's an error. It is the application's responsibility to close it and make
+     * sure there's no file descriptor leak. If `autoClose` is set to true (default
+     * behavior), on `'error'` or `'end'` the file descriptor will be closed
+     * automatically.
+     *
+     * `mode` sets the file mode (permission and sticky bits), but only if the
+     * file was created.
+     *
+     * An example to read the last 10 bytes of a file which is 100 bytes long:
+     *
+     * ```js
+     * import { createReadStream } from 'node:fs';
+     *
+     * createReadStream('sample.txt', { start: 90, end: 99 });
+     * ```
+     *
+     * If `options` is a string, then it specifies the encoding.
+     * @since v0.1.31
+     */
+    export function createReadStream(path: PathLike, options?: BufferEncoding | ReadStreamOptions): ReadStream;
+    /**
+     * `options` may also include a `start` option to allow writing data at some
+     * position past the beginning of the file, allowed values are in the
+     * \[0, [`Number.MAX_SAFE_INTEGER`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER)\] range. Modifying a file rather than
+     * replacing it may require the `flags` option to be set to `r+` rather than the
+     * default `w`. The `encoding` can be any one of those accepted by `Buffer`.
+     *
+     * If `autoClose` is set to true (default behavior) on `'error'` or `'finish'` the file descriptor will be closed automatically. If `autoClose` is false,
+     * then the file descriptor won't be closed, even if there's an error.
+     * It is the application's responsibility to close it and make sure there's no
+     * file descriptor leak.
+     *
+     * By default, the stream will emit a `'close'` event after it has been
+     * destroyed.  Set the `emitClose` option to `false` to change this behavior.
+     *
+     * By providing the `fs` option it is possible to override the corresponding `fs` implementations for `open`, `write`, `writev`, and `close`. Overriding `write()` without `writev()` can reduce
+     * performance as some optimizations (`_writev()`)
+     * will be disabled. When providing the `fs` option, overrides for at least one of `write` and `writev` are required. If no `fd` option is supplied, an override
+     * for `open` is also required. If `autoClose` is `true`, an override for `close` is also required.
+     *
+     * Like `fs.ReadStream`, if `fd` is specified, `fs.WriteStream` will ignore the `path` argument and will use the specified file descriptor. This means that no `'open'` event will be
+     * emitted. `fd` should be blocking; non-blocking `fd`s
+     * should be passed to `net.Socket`.
+     *
+     * If `options` is a string, then it specifies the encoding.
+     * @since v0.1.31
+     */
+    export function createWriteStream(path: PathLike, options?: BufferEncoding | WriteStreamOptions): WriteStream;
+    /**
+     * Forces all currently queued I/O operations associated with the file to the
+     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. No arguments other
+     * than a possible
+     * exception are given to the completion callback.
+     * @since v0.1.96
+     */
+    export function fdatasync(fd: number, callback: NoParamCallback): void;
+    export namespace fdatasync {
+        /**
+         * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
+         * @param fd A file descriptor.
+         */
+        function __promisify__(fd: number): Promise<void>;
+    }
+    /**
+     * Forces all currently queued I/O operations associated with the file to the
+     * operating system's synchronized I/O completion state. Refer to the POSIX [`fdatasync(2)`](http://man7.org/linux/man-pages/man2/fdatasync.2.html) documentation for details. Returns `undefined`.
+     * @since v0.1.96
+     */
+    export function fdatasyncSync(fd: number): void;
+    /**
+     * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it
+     * already exists. No arguments other than a possible exception are given to the
+     * callback function. Node.js makes no guarantees about the atomicity of the copy
+     * operation. If an error occurs after the destination file has been opened for
+     * writing, Node.js will attempt to remove the destination.
+     *
+     * `mode` is an optional integer that specifies the behavior
+     * of the copy operation. It is possible to create a mask consisting of the bitwise
+     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
+     *
+     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
+     * exists.
+     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
+     * copy-on-write reflink. If the platform does not support copy-on-write, then a
+     * fallback copy mechanism is used.
+     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
+     * create a copy-on-write reflink. If the platform does not support
+     * copy-on-write, then the operation will fail.
+     *
+     * ```js
+     * import { copyFile, constants } from 'node:fs';
+     *
+     * function callback(err) {
+     *   if (err) throw err;
+     *   console.log('source.txt was copied to destination.txt');
+     * }
+     *
+     * // destination.txt will be created or overwritten by default.
+     * copyFile('source.txt', 'destination.txt', callback);
+     *
+     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
+     * copyFile('source.txt', 'destination.txt', constants.COPYFILE_EXCL, callback);
+     * ```
+     * @since v8.5.0
+     * @param src source filename to copy
+     * @param dest destination filename of the copy operation
+     * @param [mode=0] modifiers for copy operation.
+     */
+    export function copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): void;
+    export function copyFile(src: PathLike, dest: PathLike, mode: number, callback: NoParamCallback): void;
+    export namespace copyFile {
+        function __promisify__(src: PathLike, dst: PathLike, mode?: number): Promise<void>;
+    }
+    /**
+     * Synchronously copies `src` to `dest`. By default, `dest` is overwritten if it
+     * already exists. Returns `undefined`. Node.js makes no guarantees about the
+     * atomicity of the copy operation. If an error occurs after the destination file
+     * has been opened for writing, Node.js will attempt to remove the destination.
+     *
+     * `mode` is an optional integer that specifies the behavior
+     * of the copy operation. It is possible to create a mask consisting of the bitwise
+     * OR of two or more values (e.g.`fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE`).
+     *
+     * * `fs.constants.COPYFILE_EXCL`: The copy operation will fail if `dest` already
+     * exists.
+     * * `fs.constants.COPYFILE_FICLONE`: The copy operation will attempt to create a
+     * copy-on-write reflink. If the platform does not support copy-on-write, then a
+     * fallback copy mechanism is used.
+     * * `fs.constants.COPYFILE_FICLONE_FORCE`: The copy operation will attempt to
+     * create a copy-on-write reflink. If the platform does not support
+     * copy-on-write, then the operation will fail.
+     *
+     * ```js
+     * import { copyFileSync, constants } from 'node:fs';
+     *
+     * // destination.txt will be created or overwritten by default.
+     * copyFileSync('source.txt', 'destination.txt');
+     * console.log('source.txt was copied to destination.txt');
+     *
+     * // By using COPYFILE_EXCL, the operation will fail if destination.txt exists.
+     * copyFileSync('source.txt', 'destination.txt', constants.COPYFILE_EXCL);
+     * ```
+     * @since v8.5.0
+     * @param src source filename to copy
+     * @param dest destination filename of the copy operation
+     * @param [mode=0] modifiers for copy operation.
+     */
+    export function copyFileSync(src: PathLike, dest: PathLike, mode?: number): void;
+    /**
+     * Write an array of `ArrayBufferView`s to the file specified by `fd` using `writev()`.
+     *
+     * `position` is the offset from the beginning of the file where this data
+     * should be written. If `typeof position !== 'number'`, the data will be written
+     * at the current position.
+     *
+     * The callback will be given three arguments: `err`, `bytesWritten`, and `buffers`. `bytesWritten` is how many bytes were written from `buffers`.
+     *
+     * If this method is `util.promisify()` ed, it returns a promise for an `Object` with `bytesWritten` and `buffers` properties.
+     *
+     * It is unsafe to use `fs.writev()` multiple times on the same file without
+     * waiting for the callback. For this scenario, use {@link createWriteStream}.
+     *
+     * On Linux, positional writes don't work when the file is opened in append mode.
+     * The kernel ignores the position argument and always appends the data to
+     * the end of the file.
+     * @since v12.9.0
+     * @param [position='null']
+     */
+    export function writev(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export function writev(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        position: number | null,
+        cb: (err: NodeJS.ErrnoException | null, bytesWritten: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export interface WriteVResult {
+        bytesWritten: number;
+        buffers: NodeJS.ArrayBufferView[];
+    }
+    export namespace writev {
+        function __promisify__(
+            fd: number,
+            buffers: readonly NodeJS.ArrayBufferView[],
+            position?: number,
+        ): Promise<WriteVResult>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link writev}.
+     * @since v12.9.0
+     * @param [position='null']
+     * @return The number of bytes written.
+     */
+    export function writevSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
+    /**
+     * Read from a file specified by `fd` and write to an array of `ArrayBufferView`s
+     * using `readv()`.
+     *
+     * `position` is the offset from the beginning of the file from where data
+     * should be read. If `typeof position !== 'number'`, the data will be read
+     * from the current position.
+     *
+     * The callback will be given three arguments: `err`, `bytesRead`, and `buffers`. `bytesRead` is how many bytes were read from the file.
+     *
+     * If this method is invoked as its `util.promisify()` ed version, it returns
+     * a promise for an `Object` with `bytesRead` and `buffers` properties.
+     * @since v13.13.0, v12.17.0
+     * @param [position='null']
+     */
+    export function readv(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export function readv(
+        fd: number,
+        buffers: readonly NodeJS.ArrayBufferView[],
+        position: number | null,
+        cb: (err: NodeJS.ErrnoException | null, bytesRead: number, buffers: NodeJS.ArrayBufferView[]) => void,
+    ): void;
+    export interface ReadVResult {
+        bytesRead: number;
+        buffers: NodeJS.ArrayBufferView[];
+    }
+    export namespace readv {
+        function __promisify__(
+            fd: number,
+            buffers: readonly NodeJS.ArrayBufferView[],
+            position?: number,
+        ): Promise<ReadVResult>;
+    }
+    /**
+     * For detailed information, see the documentation of the asynchronous version of
+     * this API: {@link readv}.
+     * @since v13.13.0, v12.17.0
+     * @param [position='null']
+     * @return The number of bytes read.
+     */
+    export function readvSync(fd: number, buffers: readonly NodeJS.ArrayBufferView[], position?: number): number;
+
+    export interface OpenAsBlobOptions {
+        /**
+         * An optional mime type for the blob.
+         *
+         * @default 'undefined'
+         */
+        type?: string | undefined;
+    }
+
+    /**
+     * Returns a `Blob` whose data is backed by the given file.
+     *
+     * The file must not be modified after the `Blob` is created. Any modifications
+     * will cause reading the `Blob` data to fail with a `DOMException` error.
+     * Synchronous stat operations on the file when the `Blob` is created, and before
+     * each read in order to detect whether the file data has been modified on disk.
+     *
+     * ```js
+     * import { openAsBlob } from 'node:fs';
+     *
+     * const blob = await openAsBlob('the.file.txt');
+     * const ab = await blob.arrayBuffer();
+     * blob.stream();
+     * ```
+     * @since v19.8.0
+     */
+    export function openAsBlob(path: PathLike, options?: OpenAsBlobOptions): Promise<Blob>;
+
+    export interface OpenDirOptions {
+        /**
+         * @default 'utf8'
+         */
+        encoding?: BufferEncoding | undefined;
+        /**
+         * Number of directory entries that are buffered
+         * internally when reading from the directory. Higher values lead to better
+         * performance but higher memory usage.
+         * @default 32
+         */
+        bufferSize?: number | undefined;
+        /**
+         * @default false
+         */
+        recursive?: boolean;
+    }
+    /**
+     * Synchronously open a directory. See [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html).
+     *
+     * Creates an `fs.Dir`, which contains all further functions for reading from
+     * and cleaning up the directory.
+     *
+     * The `encoding` option sets the encoding for the `path` while opening the
+     * directory and subsequent read operations.
+     * @since v12.12.0
+     */
+    export function opendirSync(path: PathLike, options?: OpenDirOptions): Dir;
+    /**
+     * Asynchronously open a directory. See the POSIX [`opendir(3)`](http://man7.org/linux/man-pages/man3/opendir.3.html) documentation for
+     * more details.
+     *
+     * Creates an `fs.Dir`, which contains all further functions for reading from
+     * and cleaning up the directory.
+     *
+     * The `encoding` option sets the encoding for the `path` while opening the
+     * directory and subsequent read operations.
+     * @since v12.12.0
+     */
+    export function opendir(path: PathLike, cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void): void;
+    export function opendir(
+        path: PathLike,
+        options: OpenDirOptions,
+        cb: (err: NodeJS.ErrnoException | null, dir: Dir) => void,
+    ): void;
+    export namespace opendir {
+        function __promisify__(path: PathLike, options?: OpenDirOptions): Promise<Dir>;
+    }
+    export interface BigIntStats extends StatsBase<bigint> {
+        atimeNs: bigint;
+        mtimeNs: bigint;
+        ctimeNs: bigint;
+        birthtimeNs: bigint;
+    }
+    export interface BigIntOptions {
+        bigint: true;
+    }
+    export interface StatOptions {
+        bigint?: boolean | undefined;
+    }
+    export interface StatSyncOptions extends StatOptions {
+        throwIfNoEntry?: boolean | undefined;
+    }
+    interface CopyOptionsBase {
+        /**
+         * Dereference symlinks
+         * @default false
+         */
+        dereference?: boolean;
+        /**
+         * When `force` is `false`, and the destination
+         * exists, throw an error.
+         * @default false
+         */
+        errorOnExist?: boolean;
+        /**
+         * Overwrite existing file or directory. _The copy
+         * operation will ignore errors if you set this to false and the destination
+         * exists. Use the `errorOnExist` option to change this behavior.
+         * @default true
+         */
+        force?: boolean;
+        /**
+         * Modifiers for copy operation. See `mode` flag of {@link copyFileSync()}
+         */
+        mode?: number;
+        /**
+         * When `true` timestamps from `src` will
+         * be preserved.
+         * @default false
+         */
+        preserveTimestamps?: boolean;
+        /**
+         * Copy directories recursively.
+         * @default false
+         */
+        recursive?: boolean;
+        /**
+         * When true, path resolution for symlinks will be skipped
+         * @default false
+         */
+        verbatimSymlinks?: boolean;
+    }
+    export interface CopyOptions extends CopyOptionsBase {
+        /**
+         * Function to filter copied files/directories. Return
+         * `true` to copy the item, `false` to ignore it.
+         */
+        filter?(source: string, destination: string): boolean | Promise<boolean>;
+    }
+    export interface CopySyncOptions extends CopyOptionsBase {
+        /**
+         * Function to filter copied files/directories. Return
+         * `true` to copy the item, `false` to ignore it.
+         */
+        filter?(source: string, destination: string): boolean;
+    }
+    /**
+     * Asynchronously copies the entire directory structure from `src` to `dest`,
+     * including subdirectories and files.
+     *
+     * When copying a directory to another directory, globs are not supported and
+     * behavior is similar to `cp dir1/ dir2/`.
+     * @since v16.7.0
+     * @experimental
+     * @param src source path to copy.
+     * @param dest destination path to copy to.
+     */
+    export function cp(
+        source: string | URL,
+        destination: string | URL,
+        callback: (err: NodeJS.ErrnoException | null) => void,
+    ): void;
+    export function cp(
+        source: string | URL,
+        destination: string | URL,
+        opts: CopyOptions,
+        callback: (err: NodeJS.ErrnoException | null) => void,
+    ): void;
+    /**
+     * Synchronously copies the entire directory structure from `src` to `dest`,
+     * including subdirectories and files.
+     *
+     * When copying a directory to another directory, globs are not supported and
+     * behavior is similar to `cp dir1/ dir2/`.
+     * @since v16.7.0
+     * @experimental
+     * @param src source path to copy.
+     * @param dest destination path to copy to.
+     */
+    export function cpSync(source: string | URL, destination: string | URL, opts?: CopySyncOptions): void;
+
+    interface _GlobOptions<T extends Dirent | string> {
+        /**
+         * Current working directory.
+         * @default process.cwd()
+         */
+        cwd?: string | URL | undefined;
+        /**
+         * `true` if the glob should return paths as `Dirent`s, `false` otherwise.
+         * @default false
+         * @since v22.2.0
+         */
+        withFileTypes?: boolean | undefined;
+        /**
+         * Function to filter out files/directories or a
+         * list of glob patterns to be excluded. If a function is provided, return
+         * `true` to exclude the item, `false` to include it.
+         * @default undefined
+         */
+        exclude?: ((fileName: T) => boolean) | readonly string[] | undefined;
+    }
+    export interface GlobOptions extends _GlobOptions<Dirent | string> {}
+    export interface GlobOptionsWithFileTypes extends _GlobOptions<Dirent> {
+        withFileTypes: true;
+    }
+    export interface GlobOptionsWithoutFileTypes extends _GlobOptions<string> {
+        withFileTypes?: false | undefined;
+    }
+
+    /**
+     * Retrieves the files matching the specified pattern.
+     *
+     * ```js
+     * import { glob } from 'node:fs';
+     *
+     * glob('*.js', (err, matches) => {
+     *   if (err) throw err;
+     *   console.log(matches);
+     * });
+     * ```
+     * @since v22.0.0
+     */
+    export function glob(
+        pattern: string | readonly string[],
+        callback: (err: NodeJS.ErrnoException | null, matches: string[]) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithFileTypes,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: Dirent[],
+        ) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithoutFileTypes,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: string[],
+        ) => void,
+    ): void;
+    export function glob(
+        pattern: string | readonly string[],
+        options: GlobOptions,
+        callback: (
+            err: NodeJS.ErrnoException | null,
+            matches: Dirent[] | string[],
+        ) => void,
+    ): void;
+    /**
+     * ```js
+     * import { globSync } from 'node:fs';
+     *
+     * console.log(globSync('*.js'));
+     * ```
+     * @since v22.0.0
+     * @returns paths of files that match the pattern.
+     */
+    export function globSync(pattern: string | readonly string[]): string[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithFileTypes,
+    ): Dirent[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptionsWithoutFileTypes,
+    ): string[];
+    export function globSync(
+        pattern: string | readonly string[],
+        options: GlobOptions,
+    ): Dirent[] | string[];
+}
+declare module "node:fs" {
+    export * from "fs";
+}
diff -ruN .cache/node/globals.d.ts types/node/globals.d.ts
--- .cache/node/globals.d.ts	2025-08-08 18:07:24.919681453 +0000
+++ types/node/globals.d.ts	2025-08-08 18:07:15.881589559 +0000
@@ -310,6 +310,16 @@
     // #region fetch
     interface RequestInit extends _RequestInit {}
 
+    /**
+     * @throws {Promise<DOMException>} AbortError if the request is aborted.
+     */
+    function fetch(
+        input: string | URL | globalThis.Request,
+        init: { signal: AbortSignal } & RequestInit,
+    ): Promise<Response>;
+    /**
+     * https://nodejs.org/docs/latest/api/globals.html#fetch
+     */
     function fetch(
         input: string | URL | globalThis.Request,
         init?: RequestInit,
diff -ruN .cache/node/http2.d.ts types/node/http2.d.ts
--- .cache/node/http2.d.ts	2025-08-08 18:07:24.935681615 +0000
+++ types/node/http2.d.ts	2025-08-08 18:07:15.881589559 +0000
@@ -1220,66 +1220,14 @@
     }
     // Http2Server
     export interface SessionOptions {
-        /**
-         * Sets the maximum dynamic table size for deflating header fields.
-         * @default 4Kib
-         */
         maxDeflateDynamicTableSize?: number | undefined;
-        /**
-         * Sets the maximum number of settings entries per `SETTINGS` frame.
-         * The minimum value allowed is `1`.
-         * @default 32
-         */
-        maxSettings?: number | undefined;
-        /**
-         * Sets the maximum memory that the `Http2Session` is permitted to use.
-         * The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
-         * The minimum value allowed is `1`.
-         * This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
-         * but new `Http2Stream` instances will be rejected while this limit is exceeded.
-         * The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
-         * current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
-         * @default 10
-         */
         maxSessionMemory?: number | undefined;
-        /**
-         * Sets the maximum number of header entries.
-         * This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
-         * The minimum value is `1`.
-         * @default 128
-         */
         maxHeaderListPairs?: number | undefined;
-        /**
-         * Sets the maximum number of outstanding, unacknowledged pings.
-         * @default 10
-         */
         maxOutstandingPings?: number | undefined;
-        /**
-         * Sets the maximum allowed size for a serialized, compressed block of headers.
-         * Attempts to send headers that exceed this limit will result in
-         * a `'frameError'` event being emitted and the stream being closed and destroyed.
-         */
         maxSendHeaderBlockLength?: number | undefined;
-        /**
-         * Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
-         * @default http2.constants.PADDING_STRATEGY_NONE
-         */
         paddingStrategy?: number | undefined;
-        /**
-         * Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
-         * Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
-         * @default 100
-         */
         peerMaxConcurrentStreams?: number | undefined;
-        /**
-         * The initial settings to send to the remote peer upon connection.
-         */
         settings?: Settings | undefined;
-        /**
-         * The array of integer values determines the settings types,
-         * which are included in the `CustomSettings`-property of the received remoteSettings.
-         * Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
-         */
         remoteCustomSettings?: number[] | undefined;
         /**
          * Specifies a timeout in milliseconds that
diff -ruN .cache/node/http2.d.ts.orig types/node/http2.d.ts.orig
--- .cache/node/http2.d.ts.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/http2.d.ts.orig	2025-08-08 18:07:15.882589569 +0000
@@ -0,0 +1,2630 @@
+/**
+ * The `node:http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol.
+ * It can be accessed using:
+ *
+ * ```js
+ * import http2 from 'node:http2';
+ * ```
+ * @since v8.4.0
+ * @see [source](https://github.com/nodejs/node/blob/v24.x/lib/http2.js)
+ */
+declare module "http2" {
+    import EventEmitter = require("node:events");
+    import * as fs from "node:fs";
+    import * as net from "node:net";
+    import * as stream from "node:stream";
+    import * as tls from "node:tls";
+    import * as url from "node:url";
+    import {
+        IncomingHttpHeaders as Http1IncomingHttpHeaders,
+        IncomingMessage,
+        OutgoingHttpHeaders,
+        ServerResponse,
+    } from "node:http";
+    export { OutgoingHttpHeaders } from "node:http";
+    export interface IncomingHttpStatusHeader {
+        ":status"?: number | undefined;
+    }
+    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
+        ":path"?: string | undefined;
+        ":method"?: string | undefined;
+        ":authority"?: string | undefined;
+        ":scheme"?: string | undefined;
+    }
+    // Http2Stream
+    export interface StreamState {
+        localWindowSize?: number | undefined;
+        state?: number | undefined;
+        localClose?: number | undefined;
+        remoteClose?: number | undefined;
+        /** @deprecated */
+        sumDependencyWeight?: number | undefined;
+        /** @deprecated */
+        weight?: number | undefined;
+    }
+    export interface ServerStreamResponseOptions {
+        endStream?: boolean | undefined;
+        waitForTrailers?: boolean | undefined;
+    }
+    export interface StatOptions {
+        offset: number;
+        length: number;
+    }
+    export interface ServerStreamFileResponseOptions {
+        // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
+        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
+        waitForTrailers?: boolean | undefined;
+        offset?: number | undefined;
+        length?: number | undefined;
+    }
+    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
+        onError?(err: NodeJS.ErrnoException): void;
+    }
+    export interface Http2Stream extends stream.Duplex {
+        /**
+         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
+         * the `'aborted'` event will have been emitted.
+         * @since v8.4.0
+         */
+        readonly aborted: boolean;
+        /**
+         * This property shows the number of characters currently buffered to be written.
+         * See `net.Socket.bufferSize` for details.
+         * @since v11.2.0, v10.16.0
+         */
+        readonly bufferSize: number;
+        /**
+         * Set to `true` if the `Http2Stream` instance has been closed.
+         * @since v9.4.0
+         */
+        readonly closed: boolean;
+        /**
+         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
+         * usable.
+         * @since v8.4.0
+         */
+        readonly destroyed: boolean;
+        /**
+         * Set to `true` if the `END_STREAM` flag was set in the request or response
+         * HEADERS frame received, indicating that no additional data should be received
+         * and the readable side of the `Http2Stream` will be closed.
+         * @since v10.11.0
+         */
+        readonly endAfterHeaders: boolean;
+        /**
+         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined` if the stream identifier has not yet been assigned.
+         * @since v8.4.0
+         */
+        readonly id?: number | undefined;
+        /**
+         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
+         * numeric stream identifier.
+         * @since v9.4.0
+         */
+        readonly pending: boolean;
+        /**
+         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
+         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
+         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be `undefined` if the `Http2Stream` has not been closed.
+         * @since v8.4.0
+         */
+        readonly rstCode: number;
+        /**
+         * An object containing the outbound headers sent for this `Http2Stream`.
+         * @since v9.5.0
+         */
+        readonly sentHeaders: OutgoingHttpHeaders;
+        /**
+         * An array of objects containing the outbound informational (additional) headers
+         * sent for this `Http2Stream`.
+         * @since v9.5.0
+         */
+        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
+        /**
+         * An object containing the outbound trailers sent for this `HttpStream`.
+         * @since v9.5.0
+         */
+        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
+        /**
+         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
+         * value will be `undefined` after the `Http2Stream` instance is destroyed.
+         * @since v8.4.0
+         */
+        readonly session: Http2Session | undefined;
+        /**
+         * Provides miscellaneous information about the current state of the `Http2Stream`.
+         *
+         * A current state of this `Http2Stream`.
+         * @since v8.4.0
+         */
+        readonly state: StreamState;
+        /**
+         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
+         * connected HTTP/2 peer.
+         * @since v8.4.0
+         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
+         * @param callback An optional function registered to listen for the `'close'` event.
+         */
+        close(code?: number, callback?: () => void): void;
+        /**
+         * @deprecated Priority signaling is no longer supported in Node.js.
+         */
+        priority(options: unknown): void;
+        /**
+         * ```js
+         * import http2 from 'node:http2';
+         * const client = http2.connect('http://example.org:8000');
+         * const { NGHTTP2_CANCEL } = http2.constants;
+         * const req = client.request({ ':path': '/' });
+         *
+         * // Cancel the stream if there's no activity after 5 seconds
+         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
+         * ```
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
+         * will cause the `Http2Stream` to be immediately closed and must only be
+         * called after the `'wantTrailers'` event has been emitted. When sending a
+         * request or sending a response, the `options.waitForTrailers` option must be set
+         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
+         * trailers can be sent.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond(undefined, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ xyz: 'abc' });
+         *   });
+         *   stream.end('Hello World');
+         * });
+         * ```
+         *
+         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
+         * fields (e.g. `':method'`, `':path'`, etc).
+         * @since v10.0.0
+         */
+        sendTrailers(headers: OutgoingHttpHeaders): void;
+        addListener(event: "aborted", listener: () => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        addListener(event: "drain", listener: () => void): this;
+        addListener(event: "end", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(event: "finish", listener: () => void): this;
+        addListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "streamClosed", listener: (code: number) => void): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        addListener(event: "wantTrailers", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "aborted"): boolean;
+        emit(event: "close"): boolean;
+        emit(event: "data", chunk: Buffer | string): boolean;
+        emit(event: "drain"): boolean;
+        emit(event: "end"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: "finish"): boolean;
+        emit(event: "frameError", frameType: number, errorCode: number): boolean;
+        emit(event: "pipe", src: stream.Readable): boolean;
+        emit(event: "unpipe", src: stream.Readable): boolean;
+        emit(event: "streamClosed", code: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: "trailers", trailers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "wantTrailers"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "aborted", listener: () => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "data", listener: (chunk: Buffer | string) => void): this;
+        on(event: "drain", listener: () => void): this;
+        on(event: "end", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: "finish", listener: () => void): this;
+        on(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        on(event: "pipe", listener: (src: stream.Readable) => void): this;
+        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        on(event: "streamClosed", listener: (code: number) => void): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        on(event: "wantTrailers", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "aborted", listener: () => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "data", listener: (chunk: Buffer | string) => void): this;
+        once(event: "drain", listener: () => void): this;
+        once(event: "end", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: "finish", listener: () => void): this;
+        once(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        once(event: "pipe", listener: (src: stream.Readable) => void): this;
+        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        once(event: "streamClosed", listener: (code: number) => void): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        once(event: "wantTrailers", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "aborted", listener: () => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependListener(event: "drain", listener: () => void): this;
+        prependListener(event: "end", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(event: "finish", listener: () => void): this;
+        prependListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "streamClosed", listener: (code: number) => void): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        prependListener(event: "wantTrailers", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "aborted", listener: () => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependOnceListener(event: "drain", listener: () => void): this;
+        prependOnceListener(event: "end", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(event: "finish", listener: () => void): this;
+        prependOnceListener(event: "frameError", listener: (frameType: number, errorCode: number) => void): this;
+        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "streamClosed", listener: (code: number) => void): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: "trailers", listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
+        prependOnceListener(event: "wantTrailers", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ClientHttp2Stream extends Http2Stream {
+        addListener(event: "continue", listener: () => {}): this;
+        addListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        addListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        addListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "continue"): boolean;
+        emit(event: "headers", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
+        emit(event: "push", headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "response", headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "continue", listener: () => {}): this;
+        on(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        on(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        on(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "continue", listener: () => {}): this;
+        once(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        once(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        once(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "continue", listener: () => {}): this;
+        prependListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        prependListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "continue", listener: () => {}): this;
+        prependOnceListener(
+            event: "headers",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "push", listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
+        prependOnceListener(
+            event: "response",
+            listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ServerHttp2Stream extends Http2Stream {
+        /**
+         * True if headers were sent, false otherwise (read-only).
+         * @since v8.4.0
+         */
+        readonly headersSent: boolean;
+        /**
+         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
+         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
+         * accepts push streams, `false` otherwise. Settings are the same for every `Http2Stream` in the same `Http2Session`.
+         * @since v8.4.0
+         */
+        readonly pushAllowed: boolean;
+        /**
+         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
+         * @since v8.4.0
+         */
+        additionalHeaders(headers: OutgoingHttpHeaders): void;
+        /**
+         * Initiates a push stream. The callback is invoked with the new `Http2Stream` instance created for the push stream passed as the second argument, or an `Error` passed as the first argument.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 });
+         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
+         *     if (err) throw err;
+         *     pushStream.respond({ ':status': 200 });
+         *     pushStream.end('some pushed data');
+         *   });
+         *   stream.end('some data');
+         * });
+         * ```
+         *
+         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
+         * a `weight` value to `http2stream.priority` with the `silent` option set to `true` to enable server-side bandwidth balancing between concurrent streams.
+         *
+         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
+         * and will throw an error.
+         * @since v8.4.0
+         * @param callback Callback that is called once the push stream has been initiated.
+         */
+        pushStream(
+            headers: OutgoingHttpHeaders,
+            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
+        ): void;
+        pushStream(
+            headers: OutgoingHttpHeaders,
+            options?: Pick<ClientSessionRequestOptions, "exclusive" | "parent">,
+            callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void,
+        ): void;
+        /**
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 });
+         *   stream.end('some data');
+         * });
+         * ```
+         *
+         * Initiates a response. When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be sent.
+         * The `http2stream.sendTrailers()` method can then be used to send trailing header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either `http2stream.sendTrailers()` or `http2stream.close()` to close the `Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         *   stream.end('some data');
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
+        /**
+         * Initiates a response whose data is read from the given file descriptor. No
+         * validation is performed on the given file descriptor. If an error occurs while
+         * attempting to read data using the file descriptor, the `Http2Stream` will be
+         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
+         *
+         * When used, the `Http2Stream` object's `Duplex` interface will be closed
+         * automatically.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * import fs from 'node:fs';
+         *
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   const fd = fs.openSync('/some/file', 'r');
+         *
+         *   const stat = fs.fstatSync(fd);
+         *   const headers = {
+         *     'content-length': stat.size,
+         *     'last-modified': stat.mtime.toUTCString(),
+         *     'content-type': 'text/plain; charset=utf-8',
+         *   };
+         *   stream.respondWithFD(fd, headers);
+         *   stream.on('close', () => fs.closeSync(fd));
+         * });
+         * ```
+         *
+         * The optional `options.statCheck` function may be specified to give user code
+         * an opportunity to set additional content headers based on the `fs.Stat` details
+         * of the given fd. If the `statCheck` function is provided, the `http2stream.respondWithFD()` method will
+         * perform an `fs.fstat()` call to collect details on the provided file descriptor.
+         *
+         * The `offset` and `length` options may be used to limit the response to a
+         * specific range subset. This can be used, for instance, to support HTTP Range
+         * requests.
+         *
+         * The file descriptor or `FileHandle` is not closed when the stream is closed,
+         * so it will need to be closed manually once it is no longer needed.
+         * Using the same file descriptor concurrently for multiple streams
+         * is not supported and may result in data loss. Re-using a file descriptor
+         * after a stream has finished is supported.
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be
+         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
+         * header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code _must_ call either `http2stream.sendTrailers()`
+         * or `http2stream.close()` to close the `Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * import fs from 'node:fs';
+         *
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   const fd = fs.openSync('/some/file', 'r');
+         *
+         *   const stat = fs.fstatSync(fd);
+         *   const headers = {
+         *     'content-length': stat.size,
+         *     'last-modified': stat.mtime.toUTCString(),
+         *     'content-type': 'text/plain; charset=utf-8',
+         *   };
+         *   stream.respondWithFD(fd, headers, { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         *
+         *   stream.on('close', () => fs.closeSync(fd));
+         * });
+         * ```
+         * @since v8.4.0
+         * @param fd A readable file descriptor.
+         */
+        respondWithFD(
+            fd: number | fs.promises.FileHandle,
+            headers?: OutgoingHttpHeaders,
+            options?: ServerStreamFileResponseOptions,
+        ): void;
+        /**
+         * Sends a regular file as the response. The `path` must specify a regular file
+         * or an `'error'` event will be emitted on the `Http2Stream` object.
+         *
+         * When used, the `Http2Stream` object's `Duplex` interface will be closed
+         * automatically.
+         *
+         * The optional `options.statCheck` function may be specified to give user code
+         * an opportunity to set additional content headers based on the `fs.Stat` details
+         * of the given file:
+         *
+         * If an error occurs while attempting to read the file data, the `Http2Stream` will be closed using an
+         * `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
+         * If the `onError` callback is defined, then it will be called. Otherwise, the stream will be destroyed.
+         *
+         * Example using a file path:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   function statCheck(stat, headers) {
+         *     headers['last-modified'] = stat.mtime.toUTCString();
+         *   }
+         *
+         *   function onError(err) {
+         *     // stream.respond() can throw if the stream has been destroyed by
+         *     // the other side.
+         *     try {
+         *       if (err.code === 'ENOENT') {
+         *         stream.respond({ ':status': 404 });
+         *       } else {
+         *         stream.respond({ ':status': 500 });
+         *       }
+         *     } catch (err) {
+         *       // Perform actual error handling.
+         *       console.error(err);
+         *     }
+         *     stream.end();
+         *   }
+         *
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { statCheck, onError });
+         * });
+         * ```
+         *
+         * The `options.statCheck` function may also be used to cancel the send operation
+         * by returning `false`. For instance, a conditional request may check the stat
+         * results to determine if the file has been modified to return an appropriate `304` response:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   function statCheck(stat, headers) {
+         *     // Check the stat here...
+         *     stream.respond({ ':status': 304 });
+         *     return false; // Cancel the send operation
+         *   }
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { statCheck });
+         * });
+         * ```
+         *
+         * The `content-length` header field will be automatically set.
+         *
+         * The `offset` and `length` options may be used to limit the response to a
+         * specific range subset. This can be used, for instance, to support HTTP Range
+         * requests.
+         *
+         * The `options.onError` function may also be used to handle all the errors
+         * that could happen before the delivery of the file is initiated. The
+         * default behavior is to destroy the stream.
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * will be emitted immediately after queuing the last chunk of payload data to be
+         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
+         * header fields to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer();
+         * server.on('stream', (stream) => {
+         *   stream.respondWithFile('/some/file',
+         *                          { 'content-type': 'text/plain; charset=utf-8' },
+         *                          { waitForTrailers: true });
+         *   stream.on('wantTrailers', () => {
+         *     stream.sendTrailers({ ABC: 'some value to send' });
+         *   });
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        respondWithFile(
+            path: string,
+            headers?: OutgoingHttpHeaders,
+            options?: ServerStreamFileResponseOptionsWithError,
+        ): void;
+    }
+    // Http2Session
+    export interface Settings {
+        headerTableSize?: number | undefined;
+        enablePush?: boolean | undefined;
+        initialWindowSize?: number | undefined;
+        maxFrameSize?: number | undefined;
+        maxConcurrentStreams?: number | undefined;
+        maxHeaderListSize?: number | undefined;
+        enableConnectProtocol?: boolean | undefined;
+    }
+    export interface ClientSessionRequestOptions {
+        endStream?: boolean | undefined;
+        exclusive?: boolean | undefined;
+        parent?: number | undefined;
+        waitForTrailers?: boolean | undefined;
+        signal?: AbortSignal | undefined;
+    }
+    export interface SessionState {
+        effectiveLocalWindowSize?: number | undefined;
+        effectiveRecvDataLength?: number | undefined;
+        nextStreamID?: number | undefined;
+        localWindowSize?: number | undefined;
+        lastProcStreamID?: number | undefined;
+        remoteWindowSize?: number | undefined;
+        outboundQueueSize?: number | undefined;
+        deflateDynamicTableSize?: number | undefined;
+        inflateDynamicTableSize?: number | undefined;
+    }
+    export interface Http2Session extends EventEmitter {
+        /**
+         * Value will be `undefined` if the `Http2Session` is not yet connected to a
+         * socket, `h2c` if the `Http2Session` is not connected to a `TLSSocket`, or
+         * will return the value of the connected `TLSSocket`'s own `alpnProtocol` property.
+         * @since v9.4.0
+         */
+        readonly alpnProtocol?: string | undefined;
+        /**
+         * Will be `true` if this `Http2Session` instance has been closed, otherwise `false`.
+         * @since v9.4.0
+         */
+        readonly closed: boolean;
+        /**
+         * Will be `true` if this `Http2Session` instance is still connecting, will be set
+         * to `false` before emitting `connect` event and/or calling the `http2.connect` callback.
+         * @since v10.0.0
+         */
+        readonly connecting: boolean;
+        /**
+         * Will be `true` if this `Http2Session` instance has been destroyed and must no
+         * longer be used, otherwise `false`.
+         * @since v8.4.0
+         */
+        readonly destroyed: boolean;
+        /**
+         * Value is `undefined` if the `Http2Session` session socket has not yet been
+         * connected, `true` if the `Http2Session` is connected with a `TLSSocket`,
+         * and `false` if the `Http2Session` is connected to any other kind of socket
+         * or stream.
+         * @since v9.4.0
+         */
+        readonly encrypted?: boolean | undefined;
+        /**
+         * A prototype-less object describing the current local settings of this `Http2Session`.
+         * The local settings are local to _this_`Http2Session` instance.
+         * @since v8.4.0
+         */
+        readonly localSettings: Settings;
+        /**
+         * If the `Http2Session` is connected to a `TLSSocket`, the `originSet` property
+         * will return an `Array` of origins for which the `Http2Session` may be
+         * considered authoritative.
+         *
+         * The `originSet` property is only available when using a secure TLS connection.
+         * @since v9.4.0
+         */
+        readonly originSet?: string[] | undefined;
+        /**
+         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
+         * a sent `SETTINGS` frame. Will be `true` after calling the `http2session.settings()` method.
+         * Will be `false` once all sent `SETTINGS` frames have been acknowledged.
+         * @since v8.4.0
+         */
+        readonly pendingSettingsAck: boolean;
+        /**
+         * A prototype-less object describing the current remote settings of this`Http2Session`.
+         * The remote settings are set by the _connected_ HTTP/2 peer.
+         * @since v8.4.0
+         */
+        readonly remoteSettings: Settings;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * limits available methods to ones safe to use with HTTP/2.
+         *
+         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
+         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
+         *
+         * `setTimeout` method will be called on this `Http2Session`.
+         *
+         * All other interactions will be routed directly to the socket.
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * Provides miscellaneous information about the current state of the`Http2Session`.
+         *
+         * An object describing the current status of this `Http2Session`.
+         * @since v8.4.0
+         */
+        readonly state: SessionState;
+        /**
+         * The `http2session.type` will be equal to `http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
+         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
+         * client.
+         * @since v8.4.0
+         */
+        readonly type: number;
+        /**
+         * Gracefully closes the `Http2Session`, allowing any existing streams to
+         * complete on their own and preventing new `Http2Stream` instances from being
+         * created. Once closed, `http2session.destroy()`_might_ be called if there
+         * are no open `Http2Stream` instances.
+         *
+         * If specified, the `callback` function is registered as a handler for the`'close'` event.
+         * @since v9.4.0
+         */
+        close(callback?: () => void): void;
+        /**
+         * Immediately terminates the `Http2Session` and the associated `net.Socket` or `tls.TLSSocket`.
+         *
+         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error` is not undefined, an `'error'` event will be emitted immediately before the `'close'` event.
+         *
+         * If there are any remaining open `Http2Streams` associated with the `Http2Session`, those will also be destroyed.
+         * @since v8.4.0
+         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
+         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
+         */
+        destroy(error?: Error, code?: number): void;
+        /**
+         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
+         * @since v9.4.0
+         * @param code An HTTP/2 error code
+         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
+         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
+         */
+        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
+        /**
+         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
+         * be provided. The method will return `true` if the `PING` was sent, `false` otherwise.
+         *
+         * The maximum number of outstanding (unacknowledged) pings is determined by the `maxOutstandingPings` configuration option. The default maximum is 10.
+         *
+         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView` containing 8 bytes of data that will be transmitted with the `PING` and
+         * returned with the ping acknowledgment.
+         *
+         * The callback will be invoked with three arguments: an error argument that will
+         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
+         * that reports the number of milliseconds elapsed since the ping was sent and the
+         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING` payload.
+         *
+         * ```js
+         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
+         *   if (!err) {
+         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
+         *     console.log(`With payload '${payload.toString()}'`);
+         *   }
+         * });
+         * ```
+         *
+         * If the `payload` argument is not specified, the default payload will be the
+         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
+         * @since v8.9.3
+         * @param payload Optional ping payload.
+         */
+        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
+        ping(
+            payload: NodeJS.ArrayBufferView,
+            callback: (err: Error | null, duration: number, payload: Buffer) => void,
+        ): boolean;
+        /**
+         * Calls `ref()` on this `Http2Session` instance's underlying `net.Socket`.
+         * @since v9.4.0
+         */
+        ref(): void;
+        /**
+         * Sets the local endpoint's window size.
+         * The `windowSize` is the total window size to set, not
+         * the delta.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         *
+         * const server = http2.createServer();
+         * const expectedWindowSize = 2 ** 20;
+         * server.on('connect', (session) => {
+         *
+         *   // Set local window size to be 2 ** 20
+         *   session.setLocalWindowSize(expectedWindowSize);
+         * });
+         * ```
+         * @since v15.3.0, v14.18.0
+         */
+        setLocalWindowSize(windowSize: number): void;
+        /**
+         * Used to set a callback function that is called when there is no activity on
+         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
+         * registered as a listener on the `'timeout'` event.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * Updates the current local settings for this `Http2Session` and sends a new `SETTINGS` frame to the connected HTTP/2 peer.
+         *
+         * Once called, the `http2session.pendingSettingsAck` property will be `true` while the session is waiting for the remote peer to acknowledge the new
+         * settings.
+         *
+         * The new settings will not become effective until the `SETTINGS` acknowledgment
+         * is received and the `'localSettings'` event is emitted. It is possible to send
+         * multiple `SETTINGS` frames while acknowledgment is still pending.
+         * @since v8.4.0
+         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
+         */
+        settings(
+            settings: Settings,
+            callback?: (err: Error | null, settings: Settings, duration: number) => void,
+        ): void;
+        /**
+         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
+         * @since v9.4.0
+         */
+        unref(): void;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        addListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        addListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        addListener(event: "ping", listener: () => void): this;
+        addListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "close"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: "frameError", frameType: number, errorCode: number, streamID: number): boolean;
+        emit(event: "goaway", errorCode: number, lastStreamID: number, opaqueData?: Buffer): boolean;
+        emit(event: "localSettings", settings: Settings): boolean;
+        emit(event: "ping"): boolean;
+        emit(event: "remoteSettings", settings: Settings): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "close", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
+        on(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
+        on(event: "localSettings", listener: (settings: Settings) => void): this;
+        on(event: "ping", listener: () => void): this;
+        on(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: "frameError", listener: (frameType: number, errorCode: number, streamID: number) => void): this;
+        once(event: "goaway", listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void): this;
+        once(event: "localSettings", listener: (settings: Settings) => void): this;
+        once(event: "ping", listener: () => void): this;
+        once(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        prependListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        prependListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        prependListener(event: "ping", listener: () => void): this;
+        prependListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "frameError",
+            listener: (frameType: number, errorCode: number, streamID: number) => void,
+        ): this;
+        prependOnceListener(
+            event: "goaway",
+            listener: (errorCode: number, lastStreamID: number, opaqueData?: Buffer) => void,
+        ): this;
+        prependOnceListener(event: "localSettings", listener: (settings: Settings) => void): this;
+        prependOnceListener(event: "ping", listener: () => void): this;
+        prependOnceListener(event: "remoteSettings", listener: (settings: Settings) => void): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface ClientHttp2Session extends Http2Session {
+        /**
+         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()` creates and returns an `Http2Stream` instance that can be used to send an
+         * HTTP/2 request to the connected server.
+         *
+         * When a `ClientHttp2Session` is first created, the socket may not yet be
+         * connected. if `clienthttp2session.request()` is called during this time, the
+         * actual request will be deferred until the socket is ready to go.
+         * If the `session` is closed before the actual request be executed, an `ERR_HTTP2_GOAWAY_SESSION` is thrown.
+         *
+         * This method is only available if `http2session.type` is equal to `http2.constants.NGHTTP2_SESSION_CLIENT`.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const clientSession = http2.connect('https://localhost:1234');
+         * const {
+         *   HTTP2_HEADER_PATH,
+         *   HTTP2_HEADER_STATUS,
+         * } = http2.constants;
+         *
+         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
+         * req.on('response', (headers) => {
+         *   console.log(headers[HTTP2_HEADER_STATUS]);
+         *   req.on('data', (chunk) => { // ..  });
+         *   req.on('end', () => { // ..  });
+         * });
+         * ```
+         *
+         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
+         * is emitted immediately after queuing the last chunk of payload data to be sent.
+         * The `http2stream.sendTrailers()` method can then be called to send trailing
+         * headers to the peer.
+         *
+         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
+         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
+         *
+         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
+         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
+         *
+         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
+         * they respectively default to:
+         *
+         * * `:method` \= `'GET'`
+         * * `:path` \= `/`
+         * @since v8.4.0
+         */
+        request(
+            headers?: OutgoingHttpHeaders | readonly string[],
+            options?: ClientSessionRequestOptions,
+        ): ClientHttp2Stream;
+        addListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        addListener(event: "origin", listener: (origins: string[]) => void): this;
+        addListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        addListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "altsvc", alt: string, origin: string, stream: number): boolean;
+        emit(event: "origin", origins: readonly string[]): boolean;
+        emit(event: "connect", session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
+        emit(
+            event: "stream",
+            stream: ClientHttp2Stream,
+            headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+            flags: number,
+        ): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        on(event: "origin", listener: (origins: string[]) => void): this;
+        on(event: "connect", listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
+        on(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        once(event: "origin", listener: (origins: string[]) => void): this;
+        once(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        once(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        prependListener(event: "origin", listener: (origins: string[]) => void): this;
+        prependListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        prependListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "altsvc", listener: (alt: string, origin: string, stream: number) => void): this;
+        prependOnceListener(event: "origin", listener: (origins: string[]) => void): this;
+        prependOnceListener(
+            event: "connect",
+            listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+        ): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (
+                stream: ClientHttp2Stream,
+                headers: IncomingHttpHeaders & IncomingHttpStatusHeader,
+                flags: number,
+            ) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface AlternativeServiceOptions {
+        origin: number | string | url.URL;
+    }
+    export interface ServerHttp2Session<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends Http2Session {
+        readonly server:
+            | Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>
+            | Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
+        /**
+         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         *
+         * const server = http2.createServer();
+         * server.on('session', (session) => {
+         *   // Set altsvc for origin https://example.org:80
+         *   session.altsvc('h2=":8000"', 'https://example.org:80');
+         * });
+         *
+         * server.on('stream', (stream) => {
+         *   // Set altsvc for a specific stream
+         *   stream.session.altsvc('h2=":8000"', stream.id);
+         * });
+         * ```
+         *
+         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
+         * service is associated with the origin of the given `Http2Stream`.
+         *
+         * The `alt` and origin string _must_ contain only ASCII bytes and are
+         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
+         * domain.
+         *
+         * When a string is passed for the `originOrStream` argument, it will be parsed as
+         * a URL and the origin will be derived. For instance, the origin for the
+         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
+         * cannot be parsed as a URL or if a valid origin cannot be derived.
+         *
+         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
+         * used. The value of the `origin` property _must_ be a properly serialized
+         * ASCII origin.
+         * @since v9.4.0
+         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
+         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
+         * `http2stream.id` property.
+         */
+        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
+        /**
+         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
+         * to advertise the set of origins for which the server is capable of providing
+         * authoritative responses.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const options = getSecureOptionsSomehow();
+         * const server = http2.createSecureServer(options);
+         * server.on('stream', (stream) => {
+         *   stream.respond();
+         *   stream.end('ok');
+         * });
+         * server.on('session', (session) => {
+         *   session.origin('https://example.com', 'https://example.org');
+         * });
+         * ```
+         *
+         * When a string is passed as an `origin`, it will be parsed as a URL and the
+         * origin will be derived. For instance, the origin for the HTTP URL `'https://example.org/foo/bar'` is the ASCII string` 'https://example.org'`. An error will be thrown if either the given
+         * string
+         * cannot be parsed as a URL or if a valid origin cannot be derived.
+         *
+         * A `URL` object, or any object with an `origin` property, may be passed as
+         * an `origin`, in which case the value of the `origin` property will be
+         * used. The value of the `origin` property _must_ be a properly serialized
+         * ASCII origin.
+         *
+         * Alternatively, the `origins` option may be used when creating a new HTTP/2
+         * server using the `http2.createSecureServer()` method:
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const options = getSecureOptionsSomehow();
+         * options.origins = ['https://example.com', 'https://example.org'];
+         * const server = http2.createSecureServer(options);
+         * server.on('stream', (stream) => {
+         *   stream.respond();
+         *   stream.end('ok');
+         * });
+         * ```
+         * @since v10.12.0
+         * @param origins One or more URL Strings passed as separate arguments.
+         */
+        origin(
+            ...origins: Array<
+                | string
+                | url.URL
+                | {
+                    origin: string;
+                }
+            >
+        ): void;
+        addListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "connect",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+            socket: net.Socket | tls.TLSSocket,
+        ): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "connect",
+            listener: (
+                session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+                socket: net.Socket | tls.TLSSocket,
+            ) => void,
+        ): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    // Http2Server
+    export interface SessionOptions {
+        /**
+         * Sets the maximum dynamic table size for deflating header fields.
+         * @default 4Kib
+         */
+        maxDeflateDynamicTableSize?: number | undefined;
+        /**
+         * Sets the maximum number of settings entries per `SETTINGS` frame.
+         * The minimum value allowed is `1`.
+         * @default 32
+         */
+        maxSettings?: number | undefined;
+        /**
+         * Sets the maximum memory that the `Http2Session` is permitted to use.
+         * The value is expressed in terms of number of megabytes, e.g. `1` equal 1 megabyte.
+         * The minimum value allowed is `1`.
+         * This is a credit based limit, existing `Http2Stream`s may cause this limit to be exceeded,
+         * but new `Http2Stream` instances will be rejected while this limit is exceeded.
+         * The current number of `Http2Stream` sessions, the current memory use of the header compression tables,
+         * current data queued to be sent, and unacknowledged `PING` and `SETTINGS` frames are all counted towards the current limit.
+         * @default 10
+         */
+        maxSessionMemory?: number | undefined;
+        /**
+         * Sets the maximum number of header entries.
+         * This is similar to `server.maxHeadersCount` or `request.maxHeadersCount` in the `node:http` module.
+         * The minimum value is `1`.
+         * @default 128
+         */
+        maxHeaderListPairs?: number | undefined;
+        /**
+         * Sets the maximum number of outstanding, unacknowledged pings.
+         * @default 10
+         */
+        maxOutstandingPings?: number | undefined;
+        /**
+         * Sets the maximum allowed size for a serialized, compressed block of headers.
+         * Attempts to send headers that exceed this limit will result in
+         * a `'frameError'` event being emitted and the stream being closed and destroyed.
+         */
+        maxSendHeaderBlockLength?: number | undefined;
+        /**
+         * Strategy used for determining the amount of padding to use for `HEADERS` and `DATA` frames.
+         * @default http2.constants.PADDING_STRATEGY_NONE
+         */
+        paddingStrategy?: number | undefined;
+        /**
+         * Sets the maximum number of concurrent streams for the remote peer as if a `SETTINGS` frame had been received.
+         * Will be overridden if the remote peer sets its own value for `maxConcurrentStreams`.
+         * @default 100
+         */
+        peerMaxConcurrentStreams?: number | undefined;
+        /**
+         * The initial settings to send to the remote peer upon connection.
+         */
+        settings?: Settings | undefined;
+        /**
+         * The array of integer values determines the settings types,
+         * which are included in the `CustomSettings`-property of the received remoteSettings.
+         * Please see the `CustomSettings`-property of the `Http2Settings` object for more information, on the allowed setting types.
+         */
+        remoteCustomSettings?: number[] | undefined;
+        /**
+         * Specifies a timeout in milliseconds that
+         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the
+         * socket has not been destroyed by that time the server will destroy it.
+         * @default 100000
+         */
+        unknownProtocolTimeout?: number | undefined;
+        /**
+         * If `true`, it turns on strict leading
+         * and trailing whitespace validation for HTTP/2 header field names and values
+         * as per [RFC-9113](https://www.rfc-editor.org/rfc/rfc9113.html#section-8.2.1).
+         * @since v24.2.0
+         * @default true
+         */
+        strictFieldWhitespaceValidation?: boolean | undefined;
+    }
+    export interface ClientSessionOptions extends SessionOptions {
+        /**
+         * Sets the maximum number of reserved push streams the client will accept at any given time.
+         * Once the current number of currently reserved push streams exceeds reaches this limit,
+         * new push streams sent by the server will be automatically rejected.
+         * The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
+         * A negative value sets this option to the maximum allowed value.
+         * @default 200
+         */
+        maxReservedRemoteStreams?: number | undefined;
+        /**
+         * An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
+         * and returns any `Duplex` stream that is to be used as the connection for this session.
+         */
+        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
+        /**
+         * The protocol to connect with, if not set in the `authority`.
+         * Value may be either `'http:'` or `'https:'`.
+         * @default 'https:'
+         */
+        protocol?: "http:" | "https:" | undefined;
+    }
+    export interface ServerSessionOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends SessionOptions {
+        streamResetBurst?: number | undefined;
+        streamResetRate?: number | undefined;
+        Http1IncomingMessage?: Http1Request | undefined;
+        Http1ServerResponse?: Http1Response | undefined;
+        Http2ServerRequest?: Http2Request | undefined;
+        Http2ServerResponse?: Http2Response | undefined;
+    }
+    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
+    export interface SecureServerSessionOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response>, tls.TlsOptions {}
+    export interface ServerOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends ServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {}
+    export interface SecureServerOptions<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends SecureServerSessionOptions<Http1Request, Http1Response, Http2Request, Http2Response> {
+        allowHTTP1?: boolean | undefined;
+        origins?: string[] | undefined;
+    }
+    interface HTTP2ServerCommon {
+        setTimeout(msec?: number, callback?: () => void): this;
+        /**
+         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
+         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
+         */
+        updateSettings(settings: Settings): void;
+    }
+    export interface Http2Server<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends net.Server, HTTP2ServerCommon {
+        addListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        addListener(event: "sessionError", listener: (err: Error) => void): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "checkContinue",
+            request: InstanceType<Http2Request>,
+            response: InstanceType<Http2Response>,
+        ): boolean;
+        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
+        emit(
+            event: "session",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+        ): boolean;
+        emit(event: "sessionError", err: Error): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        on(event: "sessionError", listener: (err: Error) => void): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        once(event: "sessionError", listener: (err: Error) => void): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export interface Http2SecureServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    > extends tls.Server, HTTP2ServerCommon {
+        addListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        addListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        addListener(event: "sessionError", listener: (err: Error) => void): this;
+        addListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        addListener(event: "timeout", listener: () => void): this;
+        addListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(
+            event: "checkContinue",
+            request: InstanceType<Http2Request>,
+            response: InstanceType<Http2Response>,
+        ): boolean;
+        emit(event: "request", request: InstanceType<Http2Request>, response: InstanceType<Http2Response>): boolean;
+        emit(
+            event: "session",
+            session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>,
+        ): boolean;
+        emit(event: "sessionError", err: Error): boolean;
+        emit(event: "stream", stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
+        emit(event: "timeout"): boolean;
+        emit(event: "unknownProtocol", socket: tls.TLSSocket): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        on(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        on(event: "sessionError", listener: (err: Error) => void): this;
+        on(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        on(event: "timeout", listener: () => void): this;
+        on(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        once(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        once(event: "sessionError", listener: (err: Error) => void): this;
+        once(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        once(event: "timeout", listener: () => void): this;
+        once(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependListener(event: "timeout", listener: () => void): this;
+        prependListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(
+            event: "checkContinue",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "request",
+            listener: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+        ): this;
+        prependOnceListener(
+            event: "session",
+            listener: (session: ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>) => void,
+        ): this;
+        prependOnceListener(event: "sessionError", listener: (err: Error) => void): this;
+        prependOnceListener(
+            event: "stream",
+            listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void,
+        ): this;
+        prependOnceListener(event: "timeout", listener: () => void): this;
+        prependOnceListener(event: "unknownProtocol", listener: (socket: tls.TLSSocket) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    /**
+     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
+     * headers, and
+     * data.
+     * @since v8.4.0
+     */
+    export class Http2ServerRequest extends stream.Readable {
+        constructor(
+            stream: ServerHttp2Stream,
+            headers: IncomingHttpHeaders,
+            options: stream.ReadableOptions,
+            rawHeaders: readonly string[],
+        );
+        /**
+         * The `request.aborted` property will be `true` if the request has
+         * been aborted.
+         * @since v10.1.0
+         */
+        readonly aborted: boolean;
+        /**
+         * The request authority pseudo header field. Because HTTP/2 allows requests
+         * to set either `:authority` or `host`, this value is derived from `req.headers[':authority']` if present. Otherwise, it is derived from `req.headers['host']`.
+         * @since v8.4.0
+         */
+        readonly authority: string;
+        /**
+         * See `request.socket`.
+         * @since v8.4.0
+         * @deprecated Since v13.0.0 - Use `socket`.
+         */
+        readonly connection: net.Socket | tls.TLSSocket;
+        /**
+         * The `request.complete` property will be `true` if the request has
+         * been completed, aborted, or destroyed.
+         * @since v12.10.0
+         */
+        readonly complete: boolean;
+        /**
+         * The request/response headers object.
+         *
+         * Key-value pairs of header names and values. Header names are lower-cased.
+         *
+         * ```js
+         * // Prints something like:
+         * //
+         * // { 'user-agent': 'curl/7.22.0',
+         * //   host: '127.0.0.1:8000',
+         * //   accept: '*' }
+         * console.log(request.headers);
+         * ```
+         *
+         * See `HTTP/2 Headers Object`.
+         *
+         * In HTTP/2, the request path, host name, protocol, and method are represented as
+         * special headers prefixed with the `:` character (e.g. `':path'`). These special
+         * headers will be included in the `request.headers` object. Care must be taken not
+         * to inadvertently modify these special headers or errors may occur. For instance,
+         * removing all headers from the request will cause errors to occur:
+         *
+         * ```js
+         * removeAllHeaders(request.headers);
+         * assert(request.url);   // Fails because the :path header has been removed
+         * ```
+         * @since v8.4.0
+         */
+        readonly headers: IncomingHttpHeaders;
+        /**
+         * In case of server request, the HTTP version sent by the client. In the case of
+         * client response, the HTTP version of the connected-to server. Returns `'2.0'`.
+         *
+         * Also `message.httpVersionMajor` is the first integer and `message.httpVersionMinor` is the second.
+         * @since v8.4.0
+         */
+        readonly httpVersion: string;
+        readonly httpVersionMinor: number;
+        readonly httpVersionMajor: number;
+        /**
+         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
+         * @since v8.4.0
+         */
+        readonly method: string;
+        /**
+         * The raw request/response headers list exactly as they were received.
+         *
+         * The keys and values are in the same list. It is _not_ a
+         * list of tuples. So, the even-numbered offsets are key values, and the
+         * odd-numbered offsets are the associated values.
+         *
+         * Header names are not lowercased, and duplicates are not merged.
+         *
+         * ```js
+         * // Prints something like:
+         * //
+         * // [ 'user-agent',
+         * //   'this is invalid because there can be only one',
+         * //   'User-Agent',
+         * //   'curl/7.22.0',
+         * //   'Host',
+         * //   '127.0.0.1:8000',
+         * //   'ACCEPT',
+         * //   '*' ]
+         * console.log(request.rawHeaders);
+         * ```
+         * @since v8.4.0
+         */
+        readonly rawHeaders: string[];
+        /**
+         * The raw request/response trailer keys and values exactly as they were
+         * received. Only populated at the `'end'` event.
+         * @since v8.4.0
+         */
+        readonly rawTrailers: string[];
+        /**
+         * The request scheme pseudo header field indicating the scheme
+         * portion of the target URL.
+         * @since v8.4.0
+         */
+        readonly scheme: string;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * applies getters, setters, and methods based on HTTP/2 logic.
+         *
+         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
+         * set on `request.stream`.
+         *
+         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `request.stream`.
+         *
+         * `setTimeout` method will be called on `request.stream.session`.
+         *
+         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
+         * more information.
+         *
+         * All other interactions will be routed directly to the socket. With TLS support,
+         * use `request.socket.getPeerCertificate()` to obtain the client's
+         * authentication details.
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * The `Http2Stream` object backing the request.
+         * @since v8.4.0
+         */
+        readonly stream: ServerHttp2Stream;
+        /**
+         * The request/response trailers object. Only populated at the `'end'` event.
+         * @since v8.4.0
+         */
+        readonly trailers: IncomingHttpHeaders;
+        /**
+         * Request URL string. This contains only the URL that is present in the actual
+         * HTTP request. If the request is:
+         *
+         * ```http
+         * GET /status?name=ryan HTTP/1.1
+         * Accept: text/plain
+         * ```
+         *
+         * Then `request.url` will be:
+         *
+         * ```js
+         * '/status?name=ryan'
+         * ```
+         *
+         * To parse the url into its parts, `new URL()` can be used:
+         *
+         * ```console
+         * $ node
+         * > new URL('/status?name=ryan', 'http://example.com')
+         * URL {
+         *   href: 'http://example.com/status?name=ryan',
+         *   origin: 'http://example.com',
+         *   protocol: 'http:',
+         *   username: '',
+         *   password: '',
+         *   host: 'example.com',
+         *   hostname: 'example.com',
+         *   port: '',
+         *   pathname: '/status',
+         *   search: '?name=ryan',
+         *   searchParams: URLSearchParams { 'name' => 'ryan' },
+         *   hash: ''
+         * }
+         * ```
+         * @since v8.4.0
+         */
+        url: string;
+        /**
+         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
+         * provided, then it is added as a listener on the `'timeout'` event on
+         * the response object.
+         *
+         * If no `'timeout'` listener is added to the request, the response, or
+         * the server, then `Http2Stream`s are destroyed when they time out. If a
+         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        read(size?: number): Buffer | string | null;
+        addListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        addListener(event: "end", listener: () => void): this;
+        addListener(event: "readable", listener: () => void): this;
+        addListener(event: "error", listener: (err: Error) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "aborted", hadError: boolean, code: number): boolean;
+        emit(event: "close"): boolean;
+        emit(event: "data", chunk: Buffer | string): boolean;
+        emit(event: "end"): boolean;
+        emit(event: "readable"): boolean;
+        emit(event: "error", err: Error): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        on(event: "close", listener: () => void): this;
+        on(event: "data", listener: (chunk: Buffer | string) => void): this;
+        on(event: "end", listener: () => void): this;
+        on(event: "readable", listener: () => void): this;
+        on(event: "error", listener: (err: Error) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "data", listener: (chunk: Buffer | string) => void): this;
+        once(event: "end", listener: () => void): this;
+        once(event: "readable", listener: () => void): this;
+        once(event: "error", listener: (err: Error) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependListener(event: "end", listener: () => void): this;
+        prependListener(event: "readable", listener: () => void): this;
+        prependListener(event: "error", listener: (err: Error) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "aborted", listener: (hadError: boolean, code: number) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "data", listener: (chunk: Buffer | string) => void): this;
+        prependOnceListener(event: "end", listener: () => void): this;
+        prependOnceListener(event: "readable", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (err: Error) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    /**
+     * This object is created internally by an HTTP server, not by the user. It is
+     * passed as the second parameter to the `'request'` event.
+     * @since v8.4.0
+     */
+    export class Http2ServerResponse<Request extends Http2ServerRequest = Http2ServerRequest> extends stream.Writable {
+        constructor(stream: ServerHttp2Stream);
+        /**
+         * See `response.socket`.
+         * @since v8.4.0
+         * @deprecated Since v13.0.0 - Use `socket`.
+         */
+        readonly connection: net.Socket | tls.TLSSocket;
+        /**
+         * Append a single header value to the header object.
+         *
+         * If the value is an array, this is equivalent to calling this method multiple times.
+         *
+         * If there were no previous values for the header, this is equivalent to calling {@link setHeader}.
+         *
+         * Attempting to set a header field name or value that contains invalid characters will result in a
+         * [TypeError](https://nodejs.org/docs/latest-v24.x/api/errors.html#class-typeerror) being thrown.
+         *
+         * ```js
+         * // Returns headers including "set-cookie: a" and "set-cookie: b"
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('set-cookie', 'a');
+         *   res.appendHeader('set-cookie', 'b');
+         *   res.writeHead(200);
+         *   res.end('ok');
+         * });
+         * ```
+         * @since v20.12.0
+         */
+        appendHeader(name: string, value: string | string[]): void;
+        /**
+         * Boolean value that indicates whether the response has completed. Starts
+         * as `false`. After `response.end()` executes, the value will be `true`.
+         * @since v8.4.0
+         * @deprecated Since v13.4.0,v12.16.0 - Use `writableEnded`.
+         */
+        readonly finished: boolean;
+        /**
+         * True if headers were sent, false otherwise (read-only).
+         * @since v8.4.0
+         */
+        readonly headersSent: boolean;
+        /**
+         * A reference to the original HTTP2 `request` object.
+         * @since v15.7.0
+         */
+        readonly req: Request;
+        /**
+         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
+         * applies getters, setters, and methods based on HTTP/2 logic.
+         *
+         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
+         * set on `response.stream`.
+         *
+         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on `response.stream`.
+         *
+         * `setTimeout` method will be called on `response.stream.session`.
+         *
+         * `pause`, `read`, `resume`, and `write` will throw an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
+         * more information.
+         *
+         * All other interactions will be routed directly to the socket.
+         *
+         * ```js
+         * import http2 from 'node:http2';
+         * const server = http2.createServer((req, res) => {
+         *   const ip = req.socket.remoteAddress;
+         *   const port = req.socket.remotePort;
+         *   res.end(`Your IP address is ${ip} and your source port is ${port}.`);
+         * }).listen(3000);
+         * ```
+         * @since v8.4.0
+         */
+        readonly socket: net.Socket | tls.TLSSocket;
+        /**
+         * The `Http2Stream` object backing the response.
+         * @since v8.4.0
+         */
+        readonly stream: ServerHttp2Stream;
+        /**
+         * When true, the Date header will be automatically generated and sent in
+         * the response if it is not already present in the headers. Defaults to true.
+         *
+         * This should only be disabled for testing; HTTP requires the Date header
+         * in responses.
+         * @since v8.4.0
+         */
+        sendDate: boolean;
+        /**
+         * When using implicit headers (not calling `response.writeHead()` explicitly),
+         * this property controls the status code that will be sent to the client when
+         * the headers get flushed.
+         *
+         * ```js
+         * response.statusCode = 404;
+         * ```
+         *
+         * After response header was sent to the client, this property indicates the
+         * status code which was sent out.
+         * @since v8.4.0
+         */
+        statusCode: number;
+        /**
+         * Status message is not supported by HTTP/2 (RFC 7540 8.1.2.4). It returns
+         * an empty string.
+         * @since v8.4.0
+         */
+        statusMessage: "";
+        /**
+         * This method adds HTTP trailing headers (a header but at the end of the
+         * message) to the response.
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         * @since v8.4.0
+         */
+        addTrailers(trailers: OutgoingHttpHeaders): void;
+        /**
+         * This method signals to the server that all of the response headers and body
+         * have been sent; that server should consider this message complete.
+         * The method, `response.end()`, MUST be called on each response.
+         *
+         * If `data` is specified, it is equivalent to calling `response.write(data, encoding)` followed by `response.end(callback)`.
+         *
+         * If `callback` is specified, it will be called when the response stream
+         * is finished.
+         * @since v8.4.0
+         */
+        end(callback?: () => void): this;
+        end(data: string | Uint8Array, callback?: () => void): this;
+        end(data: string | Uint8Array, encoding: BufferEncoding, callback?: () => void): this;
+        /**
+         * Reads out a header that has already been queued but not sent to the client.
+         * The name is case-insensitive.
+         *
+         * ```js
+         * const contentType = response.getHeader('content-type');
+         * ```
+         * @since v8.4.0
+         */
+        getHeader(name: string): string;
+        /**
+         * Returns an array containing the unique names of the current outgoing headers.
+         * All header names are lowercase.
+         *
+         * ```js
+         * response.setHeader('Foo', 'bar');
+         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
+         *
+         * const headerNames = response.getHeaderNames();
+         * // headerNames === ['foo', 'set-cookie']
+         * ```
+         * @since v8.4.0
+         */
+        getHeaderNames(): string[];
+        /**
+         * Returns a shallow copy of the current outgoing headers. Since a shallow copy
+         * is used, array values may be mutated without additional calls to various
+         * header-related http module methods. The keys of the returned object are the
+         * header names and the values are the respective header values. All header names
+         * are lowercase.
+         *
+         * The object returned by the `response.getHeaders()` method _does not_ prototypically inherit from the JavaScript `Object`. This means that typical `Object` methods such as `obj.toString()`,
+         * `obj.hasOwnProperty()`, and others
+         * are not defined and _will not work_.
+         *
+         * ```js
+         * response.setHeader('Foo', 'bar');
+         * response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
+         *
+         * const headers = response.getHeaders();
+         * // headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
+         * ```
+         * @since v8.4.0
+         */
+        getHeaders(): OutgoingHttpHeaders;
+        /**
+         * Returns `true` if the header identified by `name` is currently set in the
+         * outgoing headers. The header name matching is case-insensitive.
+         *
+         * ```js
+         * const hasContentType = response.hasHeader('content-type');
+         * ```
+         * @since v8.4.0
+         */
+        hasHeader(name: string): boolean;
+        /**
+         * Removes a header that has been queued for implicit sending.
+         *
+         * ```js
+         * response.removeHeader('Content-Encoding');
+         * ```
+         * @since v8.4.0
+         */
+        removeHeader(name: string): void;
+        /**
+         * Sets a single header value for implicit headers. If this header already exists
+         * in the to-be-sent headers, its value will be replaced. Use an array of strings
+         * here to send multiple headers with the same name.
+         *
+         * ```js
+         * response.setHeader('Content-Type', 'text/html; charset=utf-8');
+         * ```
+         *
+         * or
+         *
+         * ```js
+         * response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
+         * ```
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         *
+         * When headers have been set with `response.setHeader()`, they will be merged
+         * with any headers passed to `response.writeHead()`, with the headers passed
+         * to `response.writeHead()` given precedence.
+         *
+         * ```js
+         * // Returns content-type = text/plain
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
+         *   res.setHeader('X-Foo', 'bar');
+         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
+         *   res.end('ok');
+         * });
+         * ```
+         * @since v8.4.0
+         */
+        setHeader(name: string, value: number | string | readonly string[]): void;
+        /**
+         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
+         * provided, then it is added as a listener on the `'timeout'` event on
+         * the response object.
+         *
+         * If no `'timeout'` listener is added to the request, the response, or
+         * the server, then `Http2Stream` s are destroyed when they time out. If a
+         * handler is assigned to the request, the response, or the server's `'timeout'` events, timed out sockets must be handled explicitly.
+         * @since v8.4.0
+         */
+        setTimeout(msecs: number, callback?: () => void): void;
+        /**
+         * If this method is called and `response.writeHead()` has not been called,
+         * it will switch to implicit header mode and flush the implicit headers.
+         *
+         * This sends a chunk of the response body. This method may
+         * be called multiple times to provide successive parts of the body.
+         *
+         * In the `node:http` module, the response body is omitted when the
+         * request is a HEAD request. Similarly, the `204` and `304` responses _must not_ include a message body.
+         *
+         * `chunk` can be a string or a buffer. If `chunk` is a string,
+         * the second parameter specifies how to encode it into a byte stream.
+         * By default the `encoding` is `'utf8'`. `callback` will be called when this chunk
+         * of data is flushed.
+         *
+         * This is the raw HTTP body and has nothing to do with higher-level multi-part
+         * body encodings that may be used.
+         *
+         * The first time `response.write()` is called, it will send the buffered
+         * header information and the first chunk of the body to the client. The second
+         * time `response.write()` is called, Node.js assumes data will be streamed,
+         * and sends the new data separately. That is, the response is buffered up to the
+         * first chunk of the body.
+         *
+         * Returns `true` if the entire data was flushed successfully to the kernel
+         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
+         * @since v8.4.0
+         */
+        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
+        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
+        /**
+         * Sends a status `100 Continue` to the client, indicating that the request body
+         * should be sent. See the `'checkContinue'` event on `Http2Server` and `Http2SecureServer`.
+         * @since v8.4.0
+         */
+        writeContinue(): void;
+        /**
+         * Sends a status `103 Early Hints` to the client with a Link header,
+         * indicating that the user agent can preload/preconnect the linked resources.
+         * The `hints` is an object containing the values of headers to be sent with
+         * early hints message.
+         *
+         * **Example**
+         *
+         * ```js
+         * const earlyHintsLink = '</styles.css>; rel=preload; as=style';
+         * response.writeEarlyHints({
+         *   'link': earlyHintsLink,
+         * });
+         *
+         * const earlyHintsLinks = [
+         *   '</styles.css>; rel=preload; as=style',
+         *   '</scripts.js>; rel=preload; as=script',
+         * ];
+         * response.writeEarlyHints({
+         *   'link': earlyHintsLinks,
+         * });
+         * ```
+         * @since v18.11.0
+         */
+        writeEarlyHints(hints: Record<string, string | string[]>): void;
+        /**
+         * Sends a response header to the request. The status code is a 3-digit HTTP
+         * status code, like `404`. The last argument, `headers`, are the response headers.
+         *
+         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.
+         *
+         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
+         * passed as the second argument. However, because the `statusMessage` has no
+         * meaning within HTTP/2, the argument will have no effect and a process warning
+         * will be emitted.
+         *
+         * ```js
+         * const body = 'hello world';
+         * response.writeHead(200, {
+         *   'Content-Length': Buffer.byteLength(body),
+         *   'Content-Type': 'text/plain; charset=utf-8',
+         * });
+         * ```
+         *
+         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
+         * given encoding. On outbound messages, Node.js does not check if Content-Length
+         * and the length of the body being transmitted are equal or not. However, when
+         * receiving messages, Node.js will automatically reject messages when the `Content-Length` does not match the actual payload size.
+         *
+         * This method may be called at most one time on a message before `response.end()` is called.
+         *
+         * If `response.write()` or `response.end()` are called before calling
+         * this, the implicit/mutable headers will be calculated and call this function.
+         *
+         * When headers have been set with `response.setHeader()`, they will be merged
+         * with any headers passed to `response.writeHead()`, with the headers passed
+         * to `response.writeHead()` given precedence.
+         *
+         * ```js
+         * // Returns content-type = text/plain
+         * const server = http2.createServer((req, res) => {
+         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
+         *   res.setHeader('X-Foo', 'bar');
+         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
+         *   res.end('ok');
+         * });
+         * ```
+         *
+         * Attempting to set a header field name or value that contains invalid characters
+         * will result in a `TypeError` being thrown.
+         * @since v8.4.0
+         */
+        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
+        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
+        /**
+         * Call `http2stream.pushStream()` with the given headers, and wrap the
+         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
+         * parameter if successful. When `Http2ServerRequest` is closed, the callback is
+         * called with an error `ERR_HTTP2_INVALID_STREAM`.
+         * @since v8.4.0
+         * @param headers An object describing the headers
+         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
+         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
+         */
+        createPushResponse(
+            headers: OutgoingHttpHeaders,
+            callback: (err: Error | null, res: Http2ServerResponse) => void,
+        ): void;
+        addListener(event: "close", listener: () => void): this;
+        addListener(event: "drain", listener: () => void): this;
+        addListener(event: "error", listener: (error: Error) => void): this;
+        addListener(event: "finish", listener: () => void): this;
+        addListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        emit(event: "close"): boolean;
+        emit(event: "drain"): boolean;
+        emit(event: "error", error: Error): boolean;
+        emit(event: "finish"): boolean;
+        emit(event: "pipe", src: stream.Readable): boolean;
+        emit(event: "unpipe", src: stream.Readable): boolean;
+        emit(event: string | symbol, ...args: any[]): boolean;
+        on(event: "close", listener: () => void): this;
+        on(event: "drain", listener: () => void): this;
+        on(event: "error", listener: (error: Error) => void): this;
+        on(event: "finish", listener: () => void): this;
+        on(event: "pipe", listener: (src: stream.Readable) => void): this;
+        on(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        on(event: string | symbol, listener: (...args: any[]) => void): this;
+        once(event: "close", listener: () => void): this;
+        once(event: "drain", listener: () => void): this;
+        once(event: "error", listener: (error: Error) => void): this;
+        once(event: "finish", listener: () => void): this;
+        once(event: "pipe", listener: (src: stream.Readable) => void): this;
+        once(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        once(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependListener(event: "close", listener: () => void): this;
+        prependListener(event: "drain", listener: () => void): this;
+        prependListener(event: "error", listener: (error: Error) => void): this;
+        prependListener(event: "finish", listener: () => void): this;
+        prependListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
+        prependOnceListener(event: "close", listener: () => void): this;
+        prependOnceListener(event: "drain", listener: () => void): this;
+        prependOnceListener(event: "error", listener: (error: Error) => void): this;
+        prependOnceListener(event: "finish", listener: () => void): this;
+        prependOnceListener(event: "pipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: "unpipe", listener: (src: stream.Readable) => void): this;
+        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
+    }
+    export namespace constants {
+        const NGHTTP2_SESSION_SERVER: number;
+        const NGHTTP2_SESSION_CLIENT: number;
+        const NGHTTP2_STREAM_STATE_IDLE: number;
+        const NGHTTP2_STREAM_STATE_OPEN: number;
+        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
+        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
+        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
+        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
+        const NGHTTP2_STREAM_STATE_CLOSED: number;
+        const NGHTTP2_NO_ERROR: number;
+        const NGHTTP2_PROTOCOL_ERROR: number;
+        const NGHTTP2_INTERNAL_ERROR: number;
+        const NGHTTP2_FLOW_CONTROL_ERROR: number;
+        const NGHTTP2_SETTINGS_TIMEOUT: number;
+        const NGHTTP2_STREAM_CLOSED: number;
+        const NGHTTP2_FRAME_SIZE_ERROR: number;
+        const NGHTTP2_REFUSED_STREAM: number;
+        const NGHTTP2_CANCEL: number;
+        const NGHTTP2_COMPRESSION_ERROR: number;
+        const NGHTTP2_CONNECT_ERROR: number;
+        const NGHTTP2_ENHANCE_YOUR_CALM: number;
+        const NGHTTP2_INADEQUATE_SECURITY: number;
+        const NGHTTP2_HTTP_1_1_REQUIRED: number;
+        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
+        const NGHTTP2_FLAG_NONE: number;
+        const NGHTTP2_FLAG_END_STREAM: number;
+        const NGHTTP2_FLAG_END_HEADERS: number;
+        const NGHTTP2_FLAG_ACK: number;
+        const NGHTTP2_FLAG_PADDED: number;
+        const NGHTTP2_FLAG_PRIORITY: number;
+        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
+        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
+        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
+        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
+        const MAX_MAX_FRAME_SIZE: number;
+        const MIN_MAX_FRAME_SIZE: number;
+        const MAX_INITIAL_WINDOW_SIZE: number;
+        const NGHTTP2_DEFAULT_WEIGHT: number;
+        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
+        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
+        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
+        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
+        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
+        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
+        const PADDING_STRATEGY_NONE: number;
+        const PADDING_STRATEGY_MAX: number;
+        const PADDING_STRATEGY_CALLBACK: number;
+        const HTTP2_HEADER_STATUS: string;
+        const HTTP2_HEADER_METHOD: string;
+        const HTTP2_HEADER_AUTHORITY: string;
+        const HTTP2_HEADER_SCHEME: string;
+        const HTTP2_HEADER_PATH: string;
+        const HTTP2_HEADER_ACCEPT_CHARSET: string;
+        const HTTP2_HEADER_ACCEPT_ENCODING: string;
+        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
+        const HTTP2_HEADER_ACCEPT_RANGES: string;
+        const HTTP2_HEADER_ACCEPT: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS: string;
+        const HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD: string;
+        const HTTP2_HEADER_AGE: string;
+        const HTTP2_HEADER_ALLOW: string;
+        const HTTP2_HEADER_AUTHORIZATION: string;
+        const HTTP2_HEADER_CACHE_CONTROL: string;
+        const HTTP2_HEADER_CONNECTION: string;
+        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
+        const HTTP2_HEADER_CONTENT_ENCODING: string;
+        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
+        const HTTP2_HEADER_CONTENT_LENGTH: string;
+        const HTTP2_HEADER_CONTENT_LOCATION: string;
+        const HTTP2_HEADER_CONTENT_MD5: string;
+        const HTTP2_HEADER_CONTENT_RANGE: string;
+        const HTTP2_HEADER_CONTENT_TYPE: string;
+        const HTTP2_HEADER_COOKIE: string;
+        const HTTP2_HEADER_DATE: string;
+        const HTTP2_HEADER_ETAG: string;
+        const HTTP2_HEADER_EXPECT: string;
+        const HTTP2_HEADER_EXPIRES: string;
+        const HTTP2_HEADER_FROM: string;
+        const HTTP2_HEADER_HOST: string;
+        const HTTP2_HEADER_IF_MATCH: string;
+        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
+        const HTTP2_HEADER_IF_NONE_MATCH: string;
+        const HTTP2_HEADER_IF_RANGE: string;
+        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
+        const HTTP2_HEADER_LAST_MODIFIED: string;
+        const HTTP2_HEADER_LINK: string;
+        const HTTP2_HEADER_LOCATION: string;
+        const HTTP2_HEADER_MAX_FORWARDS: string;
+        const HTTP2_HEADER_PREFER: string;
+        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
+        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
+        const HTTP2_HEADER_RANGE: string;
+        const HTTP2_HEADER_REFERER: string;
+        const HTTP2_HEADER_REFRESH: string;
+        const HTTP2_HEADER_RETRY_AFTER: string;
+        const HTTP2_HEADER_SERVER: string;
+        const HTTP2_HEADER_SET_COOKIE: string;
+        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
+        const HTTP2_HEADER_TRANSFER_ENCODING: string;
+        const HTTP2_HEADER_TE: string;
+        const HTTP2_HEADER_UPGRADE: string;
+        const HTTP2_HEADER_USER_AGENT: string;
+        const HTTP2_HEADER_VARY: string;
+        const HTTP2_HEADER_VIA: string;
+        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
+        const HTTP2_HEADER_HTTP2_SETTINGS: string;
+        const HTTP2_HEADER_KEEP_ALIVE: string;
+        const HTTP2_HEADER_PROXY_CONNECTION: string;
+        const HTTP2_METHOD_ACL: string;
+        const HTTP2_METHOD_BASELINE_CONTROL: string;
+        const HTTP2_METHOD_BIND: string;
+        const HTTP2_METHOD_CHECKIN: string;
+        const HTTP2_METHOD_CHECKOUT: string;
+        const HTTP2_METHOD_CONNECT: string;
+        const HTTP2_METHOD_COPY: string;
+        const HTTP2_METHOD_DELETE: string;
+        const HTTP2_METHOD_GET: string;
+        const HTTP2_METHOD_HEAD: string;
+        const HTTP2_METHOD_LABEL: string;
+        const HTTP2_METHOD_LINK: string;
+        const HTTP2_METHOD_LOCK: string;
+        const HTTP2_METHOD_MERGE: string;
+        const HTTP2_METHOD_MKACTIVITY: string;
+        const HTTP2_METHOD_MKCALENDAR: string;
+        const HTTP2_METHOD_MKCOL: string;
+        const HTTP2_METHOD_MKREDIRECTREF: string;
+        const HTTP2_METHOD_MKWORKSPACE: string;
+        const HTTP2_METHOD_MOVE: string;
+        const HTTP2_METHOD_OPTIONS: string;
+        const HTTP2_METHOD_ORDERPATCH: string;
+        const HTTP2_METHOD_PATCH: string;
+        const HTTP2_METHOD_POST: string;
+        const HTTP2_METHOD_PRI: string;
+        const HTTP2_METHOD_PROPFIND: string;
+        const HTTP2_METHOD_PROPPATCH: string;
+        const HTTP2_METHOD_PUT: string;
+        const HTTP2_METHOD_REBIND: string;
+        const HTTP2_METHOD_REPORT: string;
+        const HTTP2_METHOD_SEARCH: string;
+        const HTTP2_METHOD_TRACE: string;
+        const HTTP2_METHOD_UNBIND: string;
+        const HTTP2_METHOD_UNCHECKOUT: string;
+        const HTTP2_METHOD_UNLINK: string;
+        const HTTP2_METHOD_UNLOCK: string;
+        const HTTP2_METHOD_UPDATE: string;
+        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
+        const HTTP2_METHOD_VERSION_CONTROL: string;
+        const HTTP_STATUS_CONTINUE: number;
+        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
+        const HTTP_STATUS_PROCESSING: number;
+        const HTTP_STATUS_OK: number;
+        const HTTP_STATUS_CREATED: number;
+        const HTTP_STATUS_ACCEPTED: number;
+        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
+        const HTTP_STATUS_NO_CONTENT: number;
+        const HTTP_STATUS_RESET_CONTENT: number;
+        const HTTP_STATUS_PARTIAL_CONTENT: number;
+        const HTTP_STATUS_MULTI_STATUS: number;
+        const HTTP_STATUS_ALREADY_REPORTED: number;
+        const HTTP_STATUS_IM_USED: number;
+        const HTTP_STATUS_MULTIPLE_CHOICES: number;
+        const HTTP_STATUS_MOVED_PERMANENTLY: number;
+        const HTTP_STATUS_FOUND: number;
+        const HTTP_STATUS_SEE_OTHER: number;
+        const HTTP_STATUS_NOT_MODIFIED: number;
+        const HTTP_STATUS_USE_PROXY: number;
+        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
+        const HTTP_STATUS_PERMANENT_REDIRECT: number;
+        const HTTP_STATUS_BAD_REQUEST: number;
+        const HTTP_STATUS_UNAUTHORIZED: number;
+        const HTTP_STATUS_PAYMENT_REQUIRED: number;
+        const HTTP_STATUS_FORBIDDEN: number;
+        const HTTP_STATUS_NOT_FOUND: number;
+        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
+        const HTTP_STATUS_NOT_ACCEPTABLE: number;
+        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
+        const HTTP_STATUS_REQUEST_TIMEOUT: number;
+        const HTTP_STATUS_CONFLICT: number;
+        const HTTP_STATUS_GONE: number;
+        const HTTP_STATUS_LENGTH_REQUIRED: number;
+        const HTTP_STATUS_PRECONDITION_FAILED: number;
+        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
+        const HTTP_STATUS_URI_TOO_LONG: number;
+        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
+        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
+        const HTTP_STATUS_EXPECTATION_FAILED: number;
+        const HTTP_STATUS_TEAPOT: number;
+        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
+        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
+        const HTTP_STATUS_LOCKED: number;
+        const HTTP_STATUS_FAILED_DEPENDENCY: number;
+        const HTTP_STATUS_UNORDERED_COLLECTION: number;
+        const HTTP_STATUS_UPGRADE_REQUIRED: number;
+        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
+        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
+        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
+        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
+        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
+        const HTTP_STATUS_NOT_IMPLEMENTED: number;
+        const HTTP_STATUS_BAD_GATEWAY: number;
+        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
+        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
+        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
+        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
+        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
+        const HTTP_STATUS_LOOP_DETECTED: number;
+        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
+        const HTTP_STATUS_NOT_EXTENDED: number;
+        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
+    }
+    /**
+     * This symbol can be set as a property on the HTTP/2 headers object with
+     * an array value in order to provide a list of headers considered sensitive.
+     */
+    export const sensitiveHeaders: symbol;
+    /**
+     * Returns an object containing the default settings for an `Http2Session` instance. This method returns a new object instance every time it is called
+     * so instances returned may be safely modified for use.
+     * @since v8.4.0
+     */
+    export function getDefaultSettings(): Settings;
+    /**
+     * Returns a `Buffer` instance containing serialized representation of the given
+     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
+     * for use with the `HTTP2-Settings` header field.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     *
+     * const packed = http2.getPackedSettings({ enablePush: false });
+     *
+     * console.log(packed.toString('base64'));
+     * // Prints: AAIAAAAA
+     * ```
+     * @since v8.4.0
+     */
+    export function getPackedSettings(settings: Settings): Buffer;
+    /**
+     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
+     * the given `Buffer` as generated by `http2.getPackedSettings()`.
+     * @since v8.4.0
+     * @param buf The packed settings.
+     */
+    export function getUnpackedSettings(buf: Uint8Array): Settings;
+    /**
+     * Returns a `net.Server` instance that creates and manages `Http2Session` instances.
+     *
+     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
+     * communicating
+     * with browser clients.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     *
+     * // Create an unencrypted HTTP/2 server.
+     * // Since there are no browsers known that support
+     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
+     * // is necessary when communicating with browser clients.
+     * const server = http2.createServer();
+     *
+     * server.on('stream', (stream, headers) => {
+     *   stream.respond({
+     *     'content-type': 'text/html; charset=utf-8',
+     *     ':status': 200,
+     *   });
+     *   stream.end('<h1>Hello World</h1>');
+     * });
+     *
+     * server.listen(8000);
+     * ```
+     * @since v8.4.0
+     * @param onRequestHandler See `Compatibility API`
+     */
+    export function createServer(
+        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
+    ): Http2Server;
+    export function createServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        options: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+    ): Http2Server<Http1Request, Http1Response, Http2Request, Http2Response>;
+    /**
+     * Returns a `tls.Server` instance that creates and manages `Http2Session` instances.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     * import fs from 'node:fs';
+     *
+     * const options = {
+     *   key: fs.readFileSync('server-key.pem'),
+     *   cert: fs.readFileSync('server-cert.pem'),
+     * };
+     *
+     * // Create a secure HTTP/2 server
+     * const server = http2.createSecureServer(options);
+     *
+     * server.on('stream', (stream, headers) => {
+     *   stream.respond({
+     *     'content-type': 'text/html; charset=utf-8',
+     *     ':status': 200,
+     *   });
+     *   stream.end('<h1>Hello World</h1>');
+     * });
+     *
+     * server.listen(8443);
+     * ```
+     * @since v8.4.0
+     * @param onRequestHandler See `Compatibility API`
+     */
+    export function createSecureServer(
+        onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void,
+    ): Http2SecureServer;
+    export function createSecureServer<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        options: SecureServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+        onRequestHandler?: (request: InstanceType<Http2Request>, response: InstanceType<Http2Response>) => void,
+    ): Http2SecureServer<Http1Request, Http1Response, Http2Request, Http2Response>;
+    /**
+     * Returns a `ClientHttp2Session` instance.
+     *
+     * ```js
+     * import http2 from 'node:http2';
+     * const client = http2.connect('https://localhost:1234');
+     *
+     * // Use the client
+     *
+     * client.close();
+     * ```
+     * @since v8.4.0
+     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
+     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
+     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
+     */
+    export function connect(
+        authority: string | url.URL,
+        listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+    ): ClientHttp2Session;
+    export function connect(
+        authority: string | url.URL,
+        options?: ClientSessionOptions | SecureClientSessionOptions,
+        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void,
+    ): ClientHttp2Session;
+    /**
+     * Create an HTTP/2 server session from an existing socket.
+     * @param socket A Duplex Stream
+     * @param options Any `{@link createServer}` options can be provided.
+     * @since v20.12.0
+     */
+    export function performServerHandshake<
+        Http1Request extends typeof IncomingMessage = typeof IncomingMessage,
+        Http1Response extends typeof ServerResponse<InstanceType<Http1Request>> = typeof ServerResponse,
+        Http2Request extends typeof Http2ServerRequest = typeof Http2ServerRequest,
+        Http2Response extends typeof Http2ServerResponse<InstanceType<Http2Request>> = typeof Http2ServerResponse,
+    >(
+        socket: stream.Duplex,
+        options?: ServerOptions<Http1Request, Http1Response, Http2Request, Http2Response>,
+    ): ServerHttp2Session<Http1Request, Http1Response, Http2Request, Http2Response>;
+}
+declare module "node:http2" {
+    export * from "http2";
+}
diff -ruN .cache/node/http2.d.ts.rej types/node/http2.d.ts.rej
--- .cache/node/http2.d.ts.rej	1970-01-01 00:00:00.000000000 +0000
+++ types/node/http2.d.ts.rej	2025-08-08 18:07:15.883589580 +0000
@@ -0,0 +1,31 @@
+--- http2.d.ts	2025-07-31 18:08:35.853691805 +0000
++++ http2.d.ts	2025-07-31 18:08:26.787648014 +0000
+@@ -1242,27 +1190,11 @@
+          * @default 100000
+          */
+         unknownProtocolTimeout?: number | undefined;
++        selectPadding?(frameLen: number, maxFrameLen: number): number;
+     }
+     export interface ClientSessionOptions extends SessionOptions {
+-        /**
+-         * Sets the maximum number of reserved push streams the client will accept at any given time.
+-         * Once the current number of currently reserved push streams exceeds reaches this limit,
+-         * new push streams sent by the server will be automatically rejected.
+-         * The minimum allowed value is 0. The maximum allowed value is 2<sup>32</sup>-1.
+-         * A negative value sets this option to the maximum allowed value.
+-         * @default 200
+-         */
+         maxReservedRemoteStreams?: number | undefined;
+-        /**
+-         * An optional callback that receives the `URL` instance passed to `connect` and the `options` object,
+-         * and returns any `Duplex` stream that is to be used as the connection for this session.
+-         */
+         createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
+-        /**
+-         * The protocol to connect with, if not set in the `authority`.
+-         * Value may be either `'http:'` or `'https:'`.
+-         * @default 'https:'
+-         */
+         protocol?: "http:" | "https:" | undefined;
+     }
+     export interface ServerSessionOptions<
diff -ruN .cache/node/package.json types/node/package.json
--- .cache/node/package.json	2025-08-08 18:07:24.921681473 +0000
+++ types/node/package.json	2025-08-08 18:07:15.883589580 +0000
@@ -124,6 +124,11 @@
             "name": "Yagiz Nizipli",
             "githubUsername": "anonrig",
             "url": "https://github.com/anonrig"
+        },
+        {
+            "name": "Xvezda",
+            "githubUsername": "Xvezda",
+            "url": "https://github.com/Xvezda"
         }
     ],
     "main": "",
@@ -142,7 +147,7 @@
     },
     "repository": {
         "type": "git",
-        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
+        "url": "https://github.com/Xvezda/types-with-exceptions.git",
         "directory": "types/node"
     },
     "scripts": {},
diff -ruN .cache/node/package.json.orig types/node/package.json.orig
--- .cache/node/package.json.orig	1970-01-01 00:00:00.000000000 +0000
+++ types/node/package.json.orig	2025-08-08 18:07:15.788588615 +0000
@@ -0,0 +1,155 @@
+{
+    "name": "@types/node",
+    "version": "24.2.1",
+    "description": "TypeScript definitions for node",
+    "homepage": "https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/node",
+    "license": "MIT",
+    "contributors": [
+        {
+            "name": "Microsoft TypeScript",
+            "githubUsername": "Microsoft",
+            "url": "https://github.com/Microsoft"
+        },
+        {
+            "name": "Alberto Schiabel",
+            "githubUsername": "jkomyno",
+            "url": "https://github.com/jkomyno"
+        },
+        {
+            "name": "Andrew Makarov",
+            "githubUsername": "r3nya",
+            "url": "https://github.com/r3nya"
+        },
+        {
+            "name": "Benjamin Toueg",
+            "githubUsername": "btoueg",
+            "url": "https://github.com/btoueg"
+        },
+        {
+            "name": "David Junger",
+            "githubUsername": "touffy",
+            "url": "https://github.com/touffy"
+        },
+        {
+            "name": "Mohsen Azimi",
+            "githubUsername": "mohsen1",
+            "url": "https://github.com/mohsen1"
+        },
+        {
+            "name": "Nikita Galkin",
+            "githubUsername": "galkin",
+            "url": "https://github.com/galkin"
+        },
+        {
+            "name": "Sebastian Silbermann",
+            "githubUsername": "eps1lon",
+            "url": "https://github.com/eps1lon"
+        },
+        {
+            "name": "Wilco Bakker",
+            "githubUsername": "WilcoBakker",
+            "url": "https://github.com/WilcoBakker"
+        },
+        {
+            "name": "Marcin Kopacz",
+            "githubUsername": "chyzwar",
+            "url": "https://github.com/chyzwar"
+        },
+        {
+            "name": "Trivikram Kamat",
+            "githubUsername": "trivikr",
+            "url": "https://github.com/trivikr"
+        },
+        {
+            "name": "Junxiao Shi",
+            "githubUsername": "yoursunny",
+            "url": "https://github.com/yoursunny"
+        },
+        {
+            "name": "Ilia Baryshnikov",
+            "githubUsername": "qwelias",
+            "url": "https://github.com/qwelias"
+        },
+        {
+            "name": "ExE Boss",
+            "githubUsername": "ExE-Boss",
+            "url": "https://github.com/ExE-Boss"
+        },
+        {
+            "name": "Piotr Baejewicz",
+            "githubUsername": "peterblazejewicz",
+            "url": "https://github.com/peterblazejewicz"
+        },
+        {
+            "name": "Anna Henningsen",
+            "githubUsername": "addaleax",
+            "url": "https://github.com/addaleax"
+        },
+        {
+            "name": "Victor Perin",
+            "githubUsername": "victorperin",
+            "url": "https://github.com/victorperin"
+        },
+        {
+            "name": "NodeJS Contributors",
+            "githubUsername": "NodeJS",
+            "url": "https://github.com/NodeJS"
+        },
+        {
+            "name": "Linus Unnebck",
+            "githubUsername": "LinusU",
+            "url": "https://github.com/LinusU"
+        },
+        {
+            "name": "wafuwafu13",
+            "githubUsername": "wafuwafu13",
+            "url": "https://github.com/wafuwafu13"
+        },
+        {
+            "name": "Matteo Collina",
+            "githubUsername": "mcollina",
+            "url": "https://github.com/mcollina"
+        },
+        {
+            "name": "Dmitry Semigradsky",
+            "githubUsername": "Semigradsky",
+            "url": "https://github.com/Semigradsky"
+        },
+        {
+            "name": "Ren",
+            "githubUsername": "Renegade334",
+            "url": "https://github.com/Renegade334"
+        },
+        {
+            "name": "Yagiz Nizipli",
+            "githubUsername": "anonrig",
+            "url": "https://github.com/anonrig"
+        }
+    ],
+    "main": "",
+    "types": "index.d.ts",
+    "typesVersions": {
+        "<=5.6": {
+            "*": [
+                "ts5.6/*"
+            ]
+        },
+        "<=5.7": {
+            "*": [
+                "ts5.7/*"
+            ]
+        }
+    },
+    "repository": {
+        "type": "git",
+        "url": "https://github.com/DefinitelyTyped/DefinitelyTyped.git",
+        "directory": "types/node"
+    },
+    "scripts": {},
+    "dependencies": {
+        "undici-types": "~7.10.0"
+    },
+    "peerDependencies": {},
+    "typesPublisherContentHash": "c642826dc621e8df9fa43f5471ad2dd77883f4fff1a3c22d8d18322f596ed09d",
+    "typeScriptVersion": "5.2"
+}
\ No newline at end of file
diff -ruN .cache/node/package.json.rej types/node/package.json.rej
--- .cache/node/package.json.rej	1970-01-01 00:00:00.000000000 +0000
+++ types/node/package.json.rej	2025-08-08 18:07:15.883589580 +0000
@@ -0,0 +1,7 @@
+--- package.json	2025-07-31 18:08:35.838691728 +0000
++++ package.json	2025-07-31 18:08:26.787648014 +0000
+@@ -162,4 +167,4 @@
+     "peerDependencies": {},
+     "typesPublisherContentHash": "83cb68186fcf703a4b7951de645e523dc4495aa83f0ef95d9b64cb5032c5b1d6",
+     "typeScriptVersion": "5.1"
+-}+}
diff -ruN .cache/node/path.d.ts types/node/path.d.ts
--- .cache/node/path.d.ts	2025-08-08 18:07:24.939681656 +0000
+++ types/node/path.d.ts	2025-08-08 18:07:15.883589580 +0000
@@ -70,14 +70,12 @@
              * When multiple slashes are found, they're replaced by a single one; when the path contains a trailing slash, it is preserved. On Windows backslashes are used.
              *
              * @param path string path to normalize.
-             * @throws {TypeError} if `path` is not a string.
              */
             normalize(path: string): string;
             /**
              * Join all arguments together and normalize the resulting path.
              *
              * @param paths paths to join.
-             * @throws {TypeError} if any of the path segments is not a string.
              */
             join(...paths: string[]): string;
             /**
@@ -91,7 +89,6 @@
              * and trailing slashes are removed unless the path gets resolved to the root directory.
              *
              * @param paths A sequence of paths or path segments.
-             * @throws {TypeError} if any of the arguments is not a string.
              */
             resolve(...paths: string[]): string;
             /**
@@ -99,7 +96,6 @@
              * @param path The path to glob-match against.
              * @param pattern The glob to check the path against.
              * @returns Whether or not the `path` matched the `pattern`.
-             * @throws {TypeError} if `path` or `pattern` are not strings.
              * @since v22.5.0
              */
             matchesGlob(path: string, pattern: string): boolean;
@@ -109,21 +105,17 @@
              * If the given {path} is a zero-length string, `false` will be returned.
              *
              * @param path path to test.
-             * @throws {TypeError} if `path` is not a string.
              */
             isAbsolute(path: string): boolean;
             /**
              * Solve the relative path from {from} to {to} based on the current working directory.
              * At times we have two absolute paths, and we need to derive the relative path from one to the other. This is actually the reverse transform of path.resolve.
-             *
-             * @throws {TypeError} if either `from` or `to` is not a string.
              */
             relative(from: string, to: string): string;
             /**
              * Return the directory name of a path. Similar to the Unix dirname command.
              *
              * @param path the path to evaluate.
-             * @throws {TypeError} if `path` is not a string.
              */
             dirname(path: string): string;
             /**
@@ -132,7 +124,6 @@
              *
              * @param path the path to evaluate.
              * @param suffix optionally, an extension to remove from the result.
-             * @throws {TypeError} if `path` is not a string or if `ext` is given and is not a string.
              */
             basename(path: string, suffix?: string): string;
             /**
@@ -140,7 +131,6 @@
              * If there is no '.' in the last portion of the path or the first character of it is '.', then it returns an empty string.
              *
              * @param path the path to evaluate.
-             * @throws {TypeError} if `path` is not a string.
              */
             extname(path: string): string;
             /**
@@ -155,7 +145,6 @@
              * Returns an object from a path string - the opposite of format().
              *
              * @param path path to evaluate.
-             * @throws {TypeError} if `path` is not a string.
              */
             parse(path: string): ParsedPath;
             /**
diff -ruN .cache/node/util.d.ts types/node/util.d.ts
--- .cache/node/util.d.ts	2025-08-08 18:07:24.926681524 +0000
+++ types/node/util.d.ts	2025-08-08 18:07:15.884589590 +0000
@@ -1121,7 +1121,7 @@
      * @param content The raw contents of a `.env` file.
      * @since v20.12.0
      */
-    export function parseEnv(content: string): NodeJS.Dict<string>;
+    export function parseEnv(content: string): object;
     // https://nodejs.org/docs/latest/api/util.html#foreground-colors
     type ForegroundColors =
         | "black"
